<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Little Monste&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-28T09:48:20.859Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小怪兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拦截器</title>
    <link href="http://example.com/2024/11/28/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://example.com/2024/11/28/%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2024-11-28T08:45:27.964Z</published>
    <updated>2024-11-28T09:48:20.859Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring中，当请求发送到 Controller 时，在被Controller处理之前，它必须经过 Interceptors（0或多个）。<br>拦截器的底层原理是AOP</p><h1 id="Interceptor-作用"><a href="#Interceptor-作用" class="headerlink" title="Interceptor 作用"></a>Interceptor 作用</h1><ul><li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算 PV（Page View）等；</li><li>权限检查：如登录检测，进入处理器检测是否登录；</li><li>性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间。（反向代理，如 Apache 也可以自动记录）</li></ul><p>HandlerInterceptor接口方法的作用：</p><ul><li>preHandle：处理器执行之前执行，如果返回 false 将跳过处理器、拦截器 postHandle 方法、视图渲染等，直接执行拦截器 afterCompletion 方法。</li><li>postHandle：处理器执行后，视图渲染前执行，如果处理器抛出异常，将跳过该方法直接执行拦截器 afterCompletion 方法。</li><li>afterCompletion：视图渲染后执行，不管处理器是否抛出异常，该方法都将执行</li></ul><h1 id="自定义Interceptor"><a href="#自定义Interceptor" class="headerlink" title="自定义Interceptor"></a>自定义Interceptor</h1><p>这是一个自定义的jwt令牌拦截器 需要实现HandlerInterceptor接口中的两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jwt令牌校验的拦截器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenUserInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtProperties jwtProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验jwt</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//判断当前拦截到的是Controller的方法还是其他资源</span><br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-comment">//当前拦截到的不是动态方法，直接放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//1、从请求头中获取令牌</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(jwtProperties.getUserTokenName());<br>        <span class="hljs-comment">//2、校验令牌</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;jwt校验user:&#123;&#125;&quot;</span>, token);<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">empId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());<br>            log.info(<span class="hljs-string">&quot;当前员工id：&quot;</span>, empId);<br>            BaseContext.setCurrentId(empId);<br>            <span class="hljs-comment">//3、通过，放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-comment">//4、不通过，响应401状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//请求结束后清空线程</span><br>        BaseContext.removeCurrentId();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>配置类配置拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtTokenAdminInterceptor jwtTokenAdminInterceptor;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtTokenUserInterceptor jwtTokenUserInterceptor;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册自定义拦截器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始注册自定义拦截器...&quot;</span>);<br>        registry.addInterceptor(jwtTokenAdminInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/admin/**&quot;</span>)<br>               <span class="hljs-comment">// .addPathPatterns(&quot;/user/shoppingCart/add&quot;)</span><br>               <span class="hljs-comment">// .excludePathPatterns(&quot;/user/user/**&quot;)</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/admin/employee/login&quot;</span>);<br>        registry.addInterceptor(jwtTokenUserInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/user/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/user/login&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="AOP实现拦截器"><a href="#AOP实现拦截器" class="headerlink" title="AOP实现拦截器"></a>AOP实现拦截器</h1><p>拦截器的底层其实就是AOP，下面是一个AOP配合注解完成拦截器的功能</p><p>定义切面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component(&quot;operationAspect&quot;)</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalOperationAspect</span> &#123;<br><br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisUtils redisUtils;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(GlobalOperationAspect.class);<br><br><br>    <span class="hljs-meta">@Before(&quot;@annotation(com.easychat.annotation.GlobalInterceptor)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interceptorDo</span><span class="hljs-params">(JoinPoint point)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取切入点的方法</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> ((MethodSignature) point.getSignature()).getMethod();<br>            <span class="hljs-comment">// 获取注解并判断注解类型</span><br>            <span class="hljs-type">GlobalInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> method.getAnnotation(GlobalInterceptor.class);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == interceptor) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 校验登录</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (interceptor.checkLogin() || interceptor.checkAdmin()) &#123;<br>                <span class="hljs-comment">//调用自定义拦截方法</span><br>                checkLogin(interceptor.checkAdmin());<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BusinessException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;全局拦截器异常&quot;</span>, e);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;全局拦截器异常&quot;</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ResponseCodeEnum.CODE_500);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            logger.error(<span class="hljs-string">&quot;全局拦截器异常&quot;</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ResponseCodeEnum.CODE_500);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//校验登录</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkLogin</span><span class="hljs-params">(Boolean checkAdmin)</span> &#123;<br>        <span class="hljs-comment">//获取Springboot 提供的HttpServletRequest对象request, 这里我觉得其实可以实现 HandlerInterceptor接口</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();<br>        <span class="hljs-comment">//下面是获取token，判断的逻辑根据具体需求具体分析</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-type">TokenUserInfoDto</span> <span class="hljs-variable">tokenUserInfoDto</span> <span class="hljs-operator">=</span> (TokenUserInfoDto) redisUtils.get(Constants.REDIS_KEY_WS_TOKEN + token);<br>        <span class="hljs-keyword">if</span> (tokenUserInfoDto == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ResponseCodeEnum.CODE_901);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (checkAdmin &amp;&amp; !tokenUserInfoDto.getAdmin()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(ResponseCodeEnum.CODE_404);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>注解代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Mapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> GlobalInterceptor &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验登录</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验管理员</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkAdmin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">springboot拦截器</summary>
    
    
    
    <category term="Springboot" scheme="http://example.com/categories/Springboot/"/>
    
    
    <category term="Springboot" scheme="http://example.com/tags/Springboot/"/>
    
    <category term="拦截器" scheme="http://example.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>easychat</title>
    <link href="http://example.com/2024/11/25/EasyChat/"/>
    <id>http://example.com/2024/11/25/EasyChat/</id>
    <published>2024-11-25T09:23:01.124Z</published>
    <updated>2024-11-28T07:53:22.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识socket"><a href="#初识socket" class="headerlink" title="初识socket"></a>初识socket</h1><p>socket 是一种通信机制，它提供了不同主机上的进程（程序）之间进行双向通信的端点。<br>无论是客户端还是服务器端，都首先需要创建一个 socket 对象来开启通信的基础。<br>例如在 Java 中，使用 Socket 类（客户端创建 socket 时常用）和 ServerSocket 类（服务器端创建 socket 时常用）来创建相应的 socket 对象<br>Socket客户端就像是我们，而ServerSocket服务端就像是电话商(移动，联通)，我们打电话会先把消息发给电话商，然后电话商转发给目标<br>以下实现一个服务端接收客户端消息</p><p>Socket服务端:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//定义socke对象server,并监听1024端口是否有人连接</span><br>             server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">1024</span>);<br>             System.out.println(<span class="hljs-string">&quot;服务启动&quot;</span>);<br>             <span class="hljs-comment">// 阻塞服务，等待客户端连接</span><br>             <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span>server.accept();<br>             <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> socket.getInetAddress().getHostAddress();<br>             System.out.println(<span class="hljs-string">&quot;客服端连接&quot;</span>+ip+<span class="hljs-string">&quot;端口&quot;</span>+socket.getPort());<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                         <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">//获取客户端发到服务端的数据流</span><br>                             <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>                            <span class="hljs-comment">// 将数据流由字节流转换成字符流</span><br>                             <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">isr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(is);<br>                             <span class="hljs-comment">// 将字符流进一步包装为带有缓冲的字符流</span><br>                             <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(isr);<br>                             <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> br.readLine();<br>                             System.out.println(<span class="hljs-string">&quot;收到客户端消息-&gt;&quot;</span>+msg);<br>                         &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                         &#125;<br>                     &#125;<br>                 &#125;<br>             &#125;).start();<br><br>        &#125;<span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><div class="note primary flat"><p>accept() 方法：<br>它是 ServerSocket 类的一个方法，其返回类型是 Socket。当服务器端调用这个方法时，就如同在门口安排了一个 “接待员”，一直守在那里等待客户端这个 “客人” 上门，并且在客户端到来时，会为这个客户端专门开启一条和服务器端通信的 “通道”，这个 “通道” 就以 Socket 对象的形式体现出来。返回的这个 Socket 对象和普通客户端创建的 Socket 对象类似，都可以通过获取其输入流（InputStream ）和输出流（OutputStream ）来进行数据的接收和发送，只是它代表的是服务器端与当前连接的客户端之间的通信连接。<br>值得注意的是，accept() 方法是阻塞式的，即在没有客户端连接过来之前，服务器端执行到这一步的线程就会一直停在这里等待，不会继续执行后续代码，直到有客户端连接成功，它才会获取到对应的 Socket 对象，然后继续往下执行代码，允许服务器端与刚连接上的客户端开展通信操作。</p></div></p><p>Socket客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//创建socket对象，并连接本地的1024端口</span><br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">//获取socket的输出流对象os，给os赋值就相当于把消息用输出流发送到服务端</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-comment">//将os对象包装成PrintWriter类型的对象，因为PrintWriter更方便传输文本</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(os);<br>        System.out.println(<span class="hljs-string">&quot;请输入&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>                    <span class="hljs-comment">// 传输文本</span><br>                    pw.println(msg);<br>                    pw.flush();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><div class="note primary flat"><p>PrintWriter 是 Java 中一个方便用于文本输出的类，它提供了很多便捷的方法（比如 println() 、print() 等）来输出文本内容<br>OutputStream 对象 os 作为参数传递给 PrintWriter 的构造函数。这样做的目的是将基于字节的原始输出流 os 包装成一个可以更方便地进行文本输出的 PrintWriter 形式<br>后续就可以使用 pw 通过文本形式向网络连接的另一端发送消息了，例如可以直接使用 pw.println(“这是要发送的文本消息”);<br>这种方式来发送文本内容，而不需要手动去处理字节层面的转换等操作（它内部会帮我们把文本转换为对应的字节形式发送出去</p></div></p><p>最终效果如下<br><a href="https://imgse.com/i/pAhBPGn"><img src="https://s21.ax1x.com/2024/11/25/pAhBPGn.png" alt="pAhBPGn.png"></a><br><a href="https://imgse.com/i/pAhBCPs"><img src="https://s21.ax1x.com/2024/11/25/pAhBCPs.png" alt="pAhBCPs.png"></a></p><h1 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h1><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ol><li>导入验证码依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">&lt;!--验证码--&gt;<br>       &lt;dependency&gt;<br>           &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt;<br>           &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;<br>           &lt;version&gt;$&#123;captcha.verion&#125;&lt;/version&gt;<br>       &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>验证码的使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 验证码</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(value = &quot;/checkCode&quot;)</span><br>   <span class="hljs-keyword">public</span> ResponseVO <span class="hljs-title function_">checkCode</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 验证码的边框高度和宽度</span><br>       <span class="hljs-type">ArithmeticCaptcha</span> <span class="hljs-variable">captcha</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCaptcha</span>(<span class="hljs-number">100</span>, <span class="hljs-number">42</span>);<br>       <span class="hljs-comment">//验证码的答案</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> captcha.text();<br>       <span class="hljs-comment">//设置验证码id,为了登录或注册时在redis中查找对应的验证码</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">checkCodeKey</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>       <span class="hljs-comment">//将验证码缓存到redis中</span><br>       redisUtils.setex(Constants.REDIS_KEY_CHECK_CODE + checkCodeKey, code, <span class="hljs-number">60</span> * <span class="hljs-number">10</span>);<br>       <span class="hljs-comment">//获取验证码</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">checkCodeBase64</span> <span class="hljs-operator">=</span> captcha.toBase64();<br>       Map&lt;String, String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       <span class="hljs-comment">//将验证码和验证码的id返回前端，返回验证码id是为了登录或注册时前端再将验证码id传回来</span><br>       result.put(<span class="hljs-string">&quot;checkCode&quot;</span>, checkCodeBase64);<br>       result.put(<span class="hljs-string">&quot;checkCodeKey&quot;</span>, checkCodeKey);<br>       <span class="hljs-keyword">return</span> getSuccessResponseVO(result);<br>   &#125;<br></code></pre></td></tr></table></figure>最终结果：<br><a href="https://imgse.com/i/pA4yfIO"><img src="https://s21.ax1x.com/2024/11/27/pA4yfIO.png" alt="pA4yfIO.png"></a><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2>这里的参数我认为可以创建一个实体类用requestboby接收看着更舒服<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@RequestMapping(value = &quot;/register&quot;)</span><br><span class="hljs-keyword">public</span> ResponseVO <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@NotEmpty</span> String checkCodeKey,</span><br><span class="hljs-params">                           <span class="hljs-meta">@NotEmpty</span> <span class="hljs-meta">@Email</span> String email,</span><br><span class="hljs-params">                           <span class="hljs-meta">@NotEmpty</span> String password,</span><br><span class="hljs-params">                           <span class="hljs-meta">@NotEmpty</span> String nickName,</span><br><span class="hljs-params">                           <span class="hljs-meta">@NotEmpty</span> String checkCode)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//这里的checkCode其实就是验证码答案与缓存进行对比</span><br>        <span class="hljs-keyword">if</span> (!checkCode.equalsIgnoreCase((String) redisUtils.get(Constants.REDIS_KEY_CHECK_CODE + checkCodeKey))) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;图片验证码不正确&quot;</span>);<br>        &#125;<br>        userInfoService.register(email, nickName, password);<br>        <span class="hljs-keyword">return</span> getSuccessResponseVO(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//校验一次就删除因为成功会登录失败会刷新</span><br>        redisUtils.delete(Constants.REDIS_KEY_CHECK_CODE + checkCodeKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note info flat"><p>equalsIgnoreCase() :用于比较两个字符串在忽略大小写的情况下是否相等。由String提供</p></div></li></ol><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ol><li>controller层的登录依旧中规中矩，没什么东西 简单看一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;)</span><br> <span class="hljs-keyword">public</span> ResponseVO <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@NotEmpty</span> String checkCodeKey,</span><br><span class="hljs-params">                         <span class="hljs-meta">@NotEmpty</span> <span class="hljs-meta">@Email</span> String email,</span><br><span class="hljs-params">                         <span class="hljs-meta">@NotEmpty</span> String password,</span><br><span class="hljs-params">                         <span class="hljs-meta">@NotEmpty</span> String checkCode)</span> &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">if</span> (!checkCode.equalsIgnoreCase((String) redisUtils.get(Constants.REDIS_KEY_CHECK_CODE + checkCodeKey))) &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;图片验证码不正确&quot;</span>);<br>         &#125;<br>         <span class="hljs-type">UserInfoVO</span> <span class="hljs-variable">userInfoVO</span> <span class="hljs-operator">=</span> userInfoService.login(email, password);<br>         <span class="hljs-keyword">return</span> getSuccessResponseVO(userInfoVO);<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         redisUtils.delete(Constants.REDIS_KEY_CHECK_CODE + checkCodeKey);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li>service层代码就是业务逻辑：<div class="note info flat"><p>首先校验账号密码，然后会把账号密码放进 tokenUserInfoDto对象中，顺便判断是不是管理员<br>接着判断账号是否存在(根据redis中是是否存有缓存,)接着将登录信息保存到redis,并返回vo</p><p>这里有些不理解，我以为会在登录成功时就会在redis中存入心跳，但是并没有。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> UserInfoVO <span class="hljs-title function_">login</span><span class="hljs-params">(String email, String password)</span> &#123;<br>     <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userInfoMapper.selectByEmail(email);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == userInfo || !userInfo.getPassword().equals(password)) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;账号或者密码错误&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">if</span> (UserStatusEnum.DISABLE.getStatus().equals(userInfo.getStatus())) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;账号已禁用&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-comment">//设置TokenUserInfoDto实体类对象(包含 userID，email token, admin 四个信息)</span><br>     <span class="hljs-type">TokenUserInfoDto</span> <span class="hljs-variable">tokenUserInfoDto</span> <span class="hljs-operator">=</span> getTokenUserInfoDto(userInfo);<br>     <span class="hljs-comment">//这是判断账号是否已经登陆，账号登录会在redis中存入一个 字符串+id组成的key(心跳) 如果存在就说明已经登陆</span><br>     <span class="hljs-type">Long</span> <span class="hljs-variable">lastHeartBeat</span> <span class="hljs-operator">=</span> redisComponet.getUserHeartBeat(tokenUserInfoDto.getUserId());<br>     <span class="hljs-keyword">if</span> (lastHeartBeat != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;此账号已经在别处登录，请退出后再登录&quot;</span>);<br>     &#125;<br><br>     <br>     <span class="hljs-comment">// 以前所用的登录校验是JWT令牌，JWT令牌的token所包含的是由id+时间戳组成的一段加密字符串</span><br>     <span class="hljs-comment">// 这里的校验token 是由id+随机生成的20位字符串加密成md5形式的字符串</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> StringTools.encodeByMD5(tokenUserInfoDto.getUserId() + StringTools.getRandomString(Constants.LENGTH_20));<br>     <span class="hljs-comment">//保存登录信息到redis中</span><br>     tokenUserInfoDto.setToken(token);<br>     redisComponet.saveTokenUserInfoDto(tokenUserInfoDto);<br>     <span class="hljs-comment">// 返回VO对象</span><br>     <span class="hljs-type">UserInfoVO</span> <span class="hljs-variable">userInfoVO</span> <span class="hljs-operator">=</span> CopyTools.copy(userInfo, UserInfoVO.class);<br>     userInfoVO.setToken(tokenUserInfoDto.getToken());<br>     userInfoVO.setAdmin(tokenUserInfoDto.getAdmin());<br>     <span class="hljs-keyword">return</span> userInfoVO;<br> &#125;<br><br> <span class="hljs-keyword">private</span> TokenUserInfoDto <span class="hljs-title function_">getTokenUserInfoDto</span><span class="hljs-params">(UserInfo userInfo)</span> &#123;<br>     <span class="hljs-type">TokenUserInfoDto</span> <span class="hljs-variable">tokenUserInfoDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenUserInfoDto</span>();<br>     tokenUserInfoDto.setUserId(userInfo.getUserId());<br>     tokenUserInfoDto.setNickName(userInfo.getNickName());<br>     <span class="hljs-comment">//查询是否是管理员</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">adminEmails</span> <span class="hljs-operator">=</span> appConfig.getAdminEmails();<br>     <span class="hljs-keyword">if</span> (!StringTools.isEmpty(adminEmails) &amp;&amp; ArrayUtils.contains(adminEmails.split(<span class="hljs-string">&quot;,&quot;</span>), userInfo.getEmail())) &#123;<br>         tokenUserInfoDto.setAdmin(<span class="hljs-literal">true</span>);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         tokenUserInfoDto.setAdmin(<span class="hljs-literal">false</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> tokenUserInfoDto;<br> &#125;<br></code></pre></td></tr></table></figure>RedisComponet类中将登录信息保存到redis中的saveTokenUserInfoDto 方法<br>这里的实现逻辑是登录信息分成两份，第一份是由token获取 tokenUserInfoDto 对象<br>第二份是由Id获取token； emmm 不明白这里为什么这么搞，有点麻烦<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveTokenUserInfoDto</span><span class="hljs-params">(TokenUserInfoDto tokenUserInfoDto)</span> &#123;<br>    redisUtils.setex(Constants.REDIS_KEY_WS_TOKEN + tokenUserInfoDto.getToken(), tokenUserInfoDto, Constants.REDIS_KEY_EXPIRES_DAY * <span class="hljs-number">2</span>);<br>    redisUtils.setex(Constants.REDIS_KEY_WS_TOKEN_USERID + tokenUserInfoDto.getUserId(), tokenUserInfoDto.getToken(), Constants.REDIS_KEY_EXPIRES_DAY * <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">仿微信项目</summary>
    
    
    
    <category term="Springboot" scheme="http://example.com/categories/Springboot/"/>
    
    
    <category term="Springboot" scheme="http://example.com/tags/Springboot/"/>
    
    <category term="socket" scheme="http://example.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://example.com/2024/11/19/HTML/"/>
    <id>http://example.com/2024/11/19/HTML/</id>
    <published>2024-11-19T09:31:58.057Z</published>
    <updated>2024-11-19T09:57:57.941Z</updated>
    
    <content type="html"><![CDATA[<p>事情是这样的，我之前一直没有系统学习过HTML，但是今天在完成分配的需求时，需要使用一个表格，但是element的表格并不适用，因为呢element的表格基本都是定义每一列的属性，然后绑定数据。这个需求中并不适用，所以我去学习了一下HTML的table</p><h1 id="HTML之table"><a href="#HTML之table" class="headerlink" title="HTML之table"></a>HTML之table</h1><p>来看我所遇见的需求:展示一个项目的详情信息<br>这是我利用element的列表组件所展示的最后结果，但是这个组件有缺点，不能控制宽度。所以最后很不美观，我就被要求重做啦<br><img src="https://pic.imgdb.cn/item/673c5c18d29ded1a8cbafbff.png" alt=""><br>这是我利用table所完成的，最后看起来整齐多了<br><img src="https://pic.imgdb.cn/item/673c5ca1d29ded1a8cbbc365.png" alt=""></p><ol><li>table的标签</li></ol><ul><li>tr标签：定义表格中的一行，嵌套在 &lt; table &gt;&lt; /table &gt;中</li><li>th标签：定义表格中的表头单元格，嵌套在&lt; tr &gt;&lt; /tr&gt;中</li><li>td标签：定义表格中的数据单元格，嵌套在&lt; tr&gt;&lt; /tr&gt;中</li><li>caption标签：定义表格上方的数据 嵌套在&lt; table&gt;&lt; /table&gt;中<br>table表格的标签很少，以上几个就可以简单做出一个表格了，其实表格制作不难，更过的利用css来控制样式<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span><br>    Front-end web developer course 2021<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;col&quot;</span>&gt;</span>Person<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;col&quot;</span>&gt;</span>Most interest in<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;col&quot;</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span>Chris<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>HTML tables<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>22<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span>Dennis<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Web accessibility<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>45<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span>Sarah<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>JavaScript frameworks<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>29<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span>Karen<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Web performance<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>36<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;row&quot;</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Average age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>33<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">table</span> &#123;<br>  <span class="hljs-attribute">border-collapse</span>: collapse;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">140</span> <span class="hljs-number">140</span> <span class="hljs-number">140</span>);<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8rem</span>;<br>  <span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">1px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">caption</span> &#123;<br>  <span class="hljs-attribute">caption-side</span>: bottom;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-tag">thead</span>,<br><span class="hljs-selector-tag">tfoot</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">228</span> <span class="hljs-number">240</span> <span class="hljs-number">245</span>);<br>&#125;<br><br><span class="hljs-selector-tag">th</span>,<br><span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">160</span> <span class="hljs-number">160</span> <span class="hljs-number">160</span>);<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">td</span><span class="hljs-selector-pseudo">:last-of-type</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-tag">tbody</span> &gt; <span class="hljs-selector-tag">tr</span><span class="hljs-selector-pseudo">:nth-of-type</span>(even) &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">237</span> <span class="hljs-number">238</span> <span class="hljs-number">242</span>);<br>&#125;<br><br><span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">th</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: right;<br>&#125;<br><br><span class="hljs-selector-tag">tfoot</span> <span class="hljs-selector-tag">td</span> &#123;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure>以上便是一个表格的示例，效果如下<br><img src="https://pic.imgdb.cn/item/673c5f5ad29ded1a8cbf01cd.png" alt=""></li></ul>]]></content>
    
    
    <summary type="html">重新认识HTML</summary>
    
    
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL进阶</title>
    <link href="http://example.com/2024/11/16/MYSQL/"/>
    <id>http://example.com/2024/11/16/MYSQL/</id>
    <published>2024-11-16T02:22:46.306Z</published>
    <updated>2024-11-24T03:03:00.042Z</updated>
    
    <content type="html"><![CDATA[<p>MYSQL基础语句本人已在学校的课程中学习过，本章学习MYSQL的进阶学习</p><h1 id="MYSQL事务"><a href="#MYSQL事务" class="headerlink" title="MYSQL事务"></a>MYSQL事务</h1><p>事务：一组操作的集合，不可分割 事务会把这组集合中的操作当作一个整体一起向系统提交或撤回请求，这些操作要么同成功要么同失败<br>例如 转账操作 张三 转账给李四 需要两条sql语句 这两条sql语句必须同成功或同失败</p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>MYSQL中的事务默认是自动提交的，及每一条sql都会当作一个事务，sql的结束都会自动提交事务</p><h3 id="修改MYSQL事务的默认设置"><a href="#修改MYSQL事务的默认设置" class="headerlink" title="修改MYSQL事务的默认设置"></a>修改MYSQL事务的默认设置</h3><ul><li>SELECT @@autocommit; 查看当前会话事务是否自动提交 1 代表是 0 代表不是</li><li>SET @@autocommit=0;  设置当前会话事务不自动提交</li><li>COMMIT ; 提交事务</li><li>ROLLBACK; 回滚事务<br>当我们将事务设置成不自动提交后， 我们需要手动提交事务（执行多条sql语句后手动执行 COMMIT 或者 ROLLBACK）<br><img src="https://pic.imgdb.cn/item/67380414d29ded1a8c41a658.jpg" alt=""><h3 id="命令开启事务"><a href="#命令开启事务" class="headerlink" title="命令开启事务"></a>命令开启事务</h3></li><li>START TRANSACTION 或 BEGIN; 开启事务</li><li>COMMIT ; 提交事务</li><li>ROLLBACK; 回滚事务<br>执行sql语句前需要手动开启事务，需要的sql语句执行结束后同手动执行 COMMIT 或者 ROLLBACK<br><img src="https://pic.imgdb.cn/item/6738055dd29ded1a8c428ff2.jpg" alt=""><h2 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性 ACID"></a>事务的四大特性 ACID</h2></li><li>原子性(Atomicity):桑作单元，要么全部成功，要么全部失败。事务是不可分割的最小</li><li>一致性(Consistency):事务完成时，必须使听有的数据都保持一致状态，</li><li>隔离性(lsolation):数据库系统提供的隔离,制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性(Durability):事务一旦提交或回滚它对数据库中的数据的改变就是永久的。<h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2>这三个问题我学的时候有一点疑惑，事务没有提交的话并不会影响到原来数据表中的数据，但仍是发生了这些问题<br>后面学了事务的隔离，<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3>一个事务读到了另一个事务还没有提交的数据<br>例如：<br>事务A更新了数据，但是并未提交事务，但是事务B此时查询了数据，但是查询的数据是更新过的数据<div class="note info flat"><p>但是这个时候查看表的数据仍是更新前的数据，只有当A事务提交了，表中的数据才会更新。<br>这种情况在MYSQL的默认隔离中是不会发生的</p></div><img src="https://pic.imgdb.cn/item/6738082ad29ded1a8c449e94.jpg" alt=""><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3>一个事务先后读取同一条记录，但两条读取的数据不同<div class="note warning flat"><p>不可重复读问题是在解决了脏读的基础上发生的</p></div>例如：<br>事务A 查询了两次数据。但是事务B在事务A第一次查询完数据后，对数据进行了更新并提交了事务，事务A第二次查询的数据将会是更新后的数据<br><img src="https://pic.imgdb.cn/item/673809abd29ded1a8c45d30c.jpg" alt=""><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3>一个事务按照条件查询数据，但并没有查询到数据，但是在插入数据时，又发现数据已经存在<div class="note warning flat"><p>幻读问题是在解决了不可重复读的基础上发生的</p></div>例如：<br>事务A 第一步查询数据，发现并没有数据，然后事务B插入数据并提交了事务 此时A第二步插入数据就会报错，但是A第三步查询数据 并没有查询到数据<br>(有点像我考试的时候看着题很眼熟 ，明明学过但是大脑有印象但是想不起了 称为幻学)<br><img src="https://pic.imgdb.cn/item/67380b64d29ded1a8c476f80.jpg" alt=""><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3>MYSQL默认的是Repeatable Read 解决了脏读和不可重复读 有幻读的风险<br>从上到下效率依次降低<br><img src="https://pic.imgdb.cn/item/67380c76d29ded1a8c48385a.jpg" alt=""><h1 id="MYSQL存储引擎"><a href="#MYSQL存储引擎" class="headerlink" title="MYSQL存储引擎"></a>MYSQL存储引擎</h1>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。<div class="note info flat"><p>存储引擎更像是规定的规则，存储数据，建立索引，更新/查询数据等都需要遵循指定的存储引擎<br>MYSQL在5.5版本后的默认存储引擎为InnoDB<br>每张表都可以指定不同的存储引擎，不指定默认为InnoDB。</p></div>show engines 展示数据库支持的存储引擎<br><img src="https://pic.imgdb.cn/item/67399a5ad29ded1a8c73d4e8.png" alt=""><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2></li></ul><ol><li>介绍<br>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MVSOL5.5之后，InnoDB是默认的 MVSOL 存储引擎。</li><li>特点</li></ol><ul><li>DML操作遵循ACID摸型，支持事务;</li><li>行级锁，提高并发访问性能;</li><li>支持外键 FOREIGN KEY约束，保证数据的完整性和正确性;</li></ul><ol><li>存储结构<br>这里的Row行就是表中每一行的数据 例如<br><img src="https://pic.imgdb.cn/item/67399cfdd29ded1a8c760f09.png" alt=""><br>Page页相当于一张表 里面包含多行数据<br>这里的TableSpece表空间指的是MYSQL文件下InnoDB为每张表生成的 xxx.idb文件<br><img src="https://pic.imgdb.cn/item/67399c9bd29ded1a8c75befc.jpg" alt=""><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2></li><li>介绍<br>MyISAM是MySOL早期的默认存储引擎。</li><li>特点</li></ol><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1></li></ul><ol><li>介绍<br>索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。<div class="note info flat"><p>索引本质是一种数据结构，用来查找数据的</p></div></li><li>演示</li></ol><ul><li>无索引查找<br>当我们查找数据时，会从上到下依次查找所有的数据的age进行对比(全表扫描，效率极低)<br><img src="https://pic.imgdb.cn/item/6739adb9d29ded1a8c8463b0.jpg" alt=""></li><li>有索引查找 (假设索引是二叉树)<br>查找数据时会根据索引生成一颗二叉树，如图查询age=45时只需要查询三次即可<br><img src="https://pic.imgdb.cn/item/6739ae6cd29ded1a8c850464.jpg" alt=""></li></ul><ol><li>优点</li></ol><ul><li>提高数据检索的效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><ol><li>缺点</li></ol><ul><li>索引列要占用空间</li><li>索引提高查询效率的同时，降低了增删改的效率<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2></li></ul><ol><li>二叉树<br><img src="https://pic.imgdb.cn/item/6739b029d29ded1a8c865766.jpg" alt=""><br>缺点：顺序插入时，会形成链表，查询性能大大降低</li><li>红黑树(变种二叉树)<br>大数据量情况下，层级较深，检索速度慢<br><img src="https://pic.imgdb.cn/item/6739b590d29ded1a8c8ae42c.jpg" alt=""></li></ol><h3 id="B-Tree-多路平衡查找树"><a href="#B-Tree-多路平衡查找树" class="headerlink" title="B-Tree(多路平衡查找树)"></a>B-Tree(多路平衡查找树)</h3><p>在图中的5阶B 树中 分别有5个指针，分别为自己，小于20，20~39，39~62，62~89<br>根据需要查找的数据选择不同的指针进行索引，大大提高了查询效率<br><a href="https://imgse.com/i/pARMPv6"><img src="https://s21.ax1x.com/2024/11/17/pARMPv6.jpg" alt="pARMPv6.jpg"></a><br><div class="note info flat"><p>B-Tree的构建过程也很有趣，有点像二叉排序树构建过程的升级版，这里我不详细介绍了，因为我不知道怎么描述<br>要描述清楚需要很多很多照片。可以简单叙述一下，例如5阶的B-Tree 最大KEY为4，当来第5个KEY时，会将中间的KEY值向上移</p></div><br>例如 第一层已经有4个key了，当要插入1200时会有5个key，此时中间的KEY会上移<br><a href="https://imgse.com/i/pARMa2q"><img src="https://s21.ax1x.com/2024/11/17/pARMa2q.jpg" alt="pARMa2q.jpg"></a><br><a href="https://imgse.com/i/pARM0MV"><img src="https://s21.ax1x.com/2024/11/17/pARM0MV.jpg" alt="pARM0MV.jpg"></a></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是B树的一个变种</p><ol><li><p>特点：</p><ul><li>所有数据都会出现在叶子节点</li><li>叶子节点形成单向链表<div class="note info flat"><p>除了叶子节点，其他节点只起到索引的作用并没有具体数据</p></div><a href="https://imgse.com/i/pARU3UP"><img src="https://s21.ax1x.com/2024/11/18/pARU3UP.jpg" alt="pARU3UP.jpg"></a></li></ul></li><li><p>构建过程<br>构建过程相比于普通的B-Tree也做出了一些改变<br>例如 5阶的B+Tree 最多也只有4个KEY，当我们插入第5个KEY时，中间元素会向上移，但是子节点仍会保留中间KEY<br><a href="https://imgse.com/i/pARUzIP"><img src="https://s21.ax1x.com/2024/11/18/pARUzIP.jpg" alt="pARUzIP.jpg"></a><br><a href="https://imgse.com/i/pARUxat"><img src="https://s21.ax1x.com/2024/11/18/pARUxat.jpg" alt="pARUxat.jpg"></a></p></li><li><p>MYSQL的B+Tree<br>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><div class="note info flat"><p>MYSQL的B+Tree的叶子节点不在是单向链表，而是双向链表</p></div></li><li><p>为什么InnoDB存储引擎选择使用B+tree索引结构?</p><div class="note primary flat"><ol><li>相对于二叉树，层级更少，搜索效率高;</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低;</li><li>相对Hash索引，B+tree支持范围匹配及排序操作</li></ol></div></li></ol><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="普通分类"><a href="#普通分类" class="headerlink" title="普通分类"></a>普通分类</h3><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建,只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table></div><h3 id="在InnoDB中根据存储形式又可以将上面索引分为"><a href="#在InnoDB中根据存储形式又可以将上面索引分为" class="headerlink" title="在InnoDB中根据存储形式又可以将上面索引分为"></a>在InnoDB中根据存储形式又可以将上面索引分为</h3><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>=必须有，而且只有一个</td></tr><tr><td>二级索引</td><td>将数据存储与索引分开存储，索引结构的叶子节点关联的对应的主键</td><td>可以有多个</td></tr></tbody></table></div><ol><li>聚集索引的选定规则<ul><li>存在主键，主键索引就是聚集索引</li><li>不存在主键，第一个唯一索引作为聚集索引</li><li>没有主键，也没有合适的唯一索引，则InnoDB自动生成一个rowid作为隐藏的聚集索引</li></ul></li></ol><p>例如图中 在MYSQL中默认的结构为B+Tree， 这里的Id为主键，所以为主键生成了主键索引也是聚集索引，他的叶子节点对应的数据是一整行的数据<br>而其他字段的索引是二级索引，叶子节点对应的数据是他们的主键<br><img src="https://pic.imgdb.cn/item/673aad9ed29ded1a8c358e47.jpg" alt=""><br>例如我们进行数据查询时，如果不是根据Id来查，会进行回表查询<br><a href="https://imgse.com/i/pARahQg"><img src="https://s21.ax1x.com/2024/11/18/pARahQg.jpg" alt="pARahQg.jpg"></a></p><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><ol><li>创建索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">create [unique|Fulltext] index 索引名 on 表名(字段名)<br></code></pre></td></tr></table></figure></li></ol><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>字段名可以有多个</p></div><ol><li>查看索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">show index from 表名<br></code></pre></td></tr></table></figure></li><li>删除索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">drop index 索引名 on 表名<br></code></pre></td></tr></table></figure><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3>如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效(后面的字段索引失效)。<br>例如：我们先在一个表中创建一个索引TESTINDEX，关联三个属性列<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">create  index TESTINDEX on table(A,B,C)<br></code></pre></td></tr></table></figure>分别执行三条查询语句</li></ol><ul><li>select * from table where A=’0’ and B=’1’ and C=’2’;</li><li>select * from table where A=’0’ and B=’1’;</li><li>select * from table where A=’0’ ;<details class="toggle" style="border: 1px solid  [bg]"><summary class="toggle-button" style="background-color:  [bg];color:  [fg]">[猜猜结果]</summary><div class="toggle-content"><p>答案是这三条sql都会走索引，加快查询</p></div></details>接着看</li><li>select * from table where B=’1’ and C=’2’;</li><li>select * from table where A=’0’ and C=’2’;<details class="toggle" style="border: 1px solid  [bg]"><summary class="toggle-button" style="background-color:  [bg];color:  [fg]">[再猜一次]</summary><div class="toggle-content"><p>答案是第4条sql会完全不走索引，走的是全表查询，第5条sql查询 A=’0’时会走索引，由于中间跳过了一列，所以查询C=2 时索引失效，会走全表查询</p></div></details><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3>联合索引中，范围查询(&gt;,&lt;)，右边的索引会失效<br>例如 select * from table where A=’0’ and B&gt;’1’ and C=’2’;<br>出现了范围查询，所以 C=2 会索引失效 走全表查询<div class="note success flat"><p>只有 &gt;,&lt; 会失效 &gt;=,&lt;= 并不会失效</p></div><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3></li></ul><ol><li>不遵循最左前缀法则</li><li>范围查询出现&gt;,&lt;</li><li>对索引列进行了运算<br>例如：查询手机号最后两位是81的用户 会对phone进行substring函数运算，所以索引会失效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> PHONE <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;18639254981&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">substring</span>(phone,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<span class="hljs-operator">=</span><span class="hljs-string">&#x27;81&#x27;</span>;<br></code></pre></td></tr></table></figure><div class="note success flat"><p>substring(phone,10,2) 表示从第10 位开始截取两位字符串</p></div></li><li>字符串不加引号</li><li>模糊查询 <div class="note success flat"><p>头部模糊会失效，尾部模糊不会失效</p></div></li><li>or连接的条件<ul><li>用or分隔开的条件，如果or前面的条件有索引，后面条件列没有索引，那么涉及的索引都会失效</li></ul></li><li>数据分布影响<ul><li>如果MYSQL评估使用索引比全表更慢，则不使用索引</li></ul></li><li>查询时 条件用and连接，且前后就是单列索引，那么后面条件的索引会失效<h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3>SQL提示，是优化数据库的一个重要手段，简单来说就是在SQL语句加入一些人为的提示来达到优化的目的。</li></ol><div class="note info flat"><p>使用SQL提示的场景是：一个属性列拥有多个索引的情况</p></div><ol><li>use index (建议使用) //MYSQL会判断是否会用</li><li>ignore index (忽略某索引)</li><li>force index(强制使用某索引)<br>以上关键字均用在SQL语句中表名的后面<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3>尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中也经全部能够找到)，减少select*<br>如下示例中，第二条select语句就是覆盖索引，查询的列是 id和name，这两个字段都有索引，所以只需要查询一次即可<br>但是第三个select语句需要多查询一个字段gender,需要先根据name的索引查找到Arm,然后根据Id进行回表查询<br><a href="https://imgse.com/i/pAW8AiD"><img src="https://s21.ax1x.com/2024/11/20/pAW8AiD.jpg" alt="pAW8AiD.jpg"></a><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3></li><li>应用场景<ul><li>字段类型为 varchar text等时，创建普通索引可能字符串很长，这会让索引变得很大，查询时，浪费磁盘IO，影响效率。此时可以将字符传的一部分前缀作为索引</li></ul></li><li>语法<br>相比于正常创建索引多了一个(n),表示截取字段的前几个字符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">create [unique|Fulltext] index 索引名 on 表名(字段名(n))<br></code></pre></td></tr></table></figure></li><li>前缀长度</li></ol><ul><li>可以根据索引的选择性来决定，索引选择性越高则查询效率越高唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<div class="note info flat"><p>选择性是指 一个字段属性中所不重复数据的数量 和 全部数据的数量 的比值<br>例如 select count( distinct substring(A,1,5))/ count(*) from user</p><ul><li>该sql语句表示 查询 A属性中前五个字符不相同的数据的数量和总数量的比值</li><li>distinct 表示去重</li></ul></div><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3></li></ul><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件(where)、排序(orderby)、分组(groupby)操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。4.</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个7索引最有效地用于查询。<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据-insert"><a href="#插入数据-insert" class="headerlink" title="插入数据  insert"></a>插入数据  insert</h2></li><li>批量插入  Insert into tb test values(1,’Tom’),(2,’Cat’),(3, jerry’);</li><li>手动提交事务<br>减少了MYSQL开启提交事务的时间<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>, jerry<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">insert into tb test values(4,&#x27;</span>Tom<span class="hljs-string">&#x27;),(5,&#x27;</span>Cat<span class="hljs-string">&#x27;),(6, jerry&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;cat&#x27;</span>),(<span class="hljs-number">9</span>, jerry<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">commit;</span><br></code></pre></td></tr></table></figure></li><li><p>主键顺序插入</p></li><li><p>插入数据量极大</p><ul><li>使用 load命令将本地文件插入数据库<div class="note primary flat"><p>注意：本地文件数据需要有一定顺序</p></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL">#客户端连接服务端时，加上参数<span class="hljs-comment">--local-infile</span><br>mysql<span class="hljs-comment">--local-infile -u root -p</span><br>#设置全局参数<span class="hljs-keyword">local</span> infie为<span class="hljs-number">1</span>，开启从本地加载文件导入数据的开关<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">local</span> infile<span class="hljs-operator">=</span><span class="hljs-number">1</span>:<br></code></pre></td></tr></table></figure></li><li>使用load将下图数据插入数据库<br><a href="https://imgse.com/i/pAWfC34"><img src="https://s21.ax1x.com/2024/11/21/pAWfC34.jpg" alt="pAWfC34.jpg"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL">#执行load指令将准备好的数据，用逗号隔开，换行代表一行数据的结束 加载到表结构中<br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> `tb <span class="hljs-keyword">user</span>’ fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,’ lines terminated by &#x27;</span>\n<span class="hljs-string">&#x27;;</span><br></code></pre></td></tr></table></figure><h2 id="排序优化-order-by"><a href="#排序优化-order-by" class="headerlink" title="排序优化 order by"></a>排序优化 order by</h2>order by 在MySQL底层实现中分为两种</li></ul></li></ol><ul><li>Using filesor:通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort bufer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li><li>Using index:通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。<div class="note primary flat"><p>注意： order by的优化策略其实就是建立合适的索引，通过索引直接返回，不需要重新排序</p></div></li></ul><ol><li>优化</li></ol><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。减少 select *。<ul><li>因为 如果有些字段没有设置索引会回表查询，然后Using filesor排序</li></ul></li><li>多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort buffer size(默认256K)。<h2 id="分组优化-group-by"><a href="#分组优化-group-by" class="headerlink" title="分组优化 group by"></a>分组优化 group by</h2>group by 默认在MYSQL查询中，会创建一个临时表来存储分组后的数据，利用索引后就可以无需临时表<br>所以优化group by 也是创建合适的索引即可<br>create  index TESTINDEX on table(A,B,C)<div class="note primary flat"><p>注意： group by使用联合索引时页遵守最左前缀法则，以下sql也遵循最左前缀法则<br>      create  index TESTINDEX on table(A,B,C)<br>      select A，B count(*) from table where A=’1’ group by B;</p></div><h2 id="分页查询优化-limit"><a href="#分页查询优化-limit" class="headerlink" title="分页查询优化 limit"></a>分页查询优化 limit</h2>我们先来看一条普通的分页查询,查询9000000到9000010的数据 最后耗时19s<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> item limit <span class="hljs-number">9000000</span>,<span class="hljs-number">10</span> ;<br></code></pre></td></tr></table></figure>优化分页查询，我们可以子查询 最后耗时11s<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> item <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> item <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="更新语句-update优化"><a href="#更新语句-update优化" class="headerlink" title="更新语句 update优化"></a>更新语句 update优化</h2>学习了这么多优化，针对更新的优化当然也是索引<br>值得一提的是<div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>值得一提的是 在InnoDB存储引擎中 默认是添加行级锁，但是如果更新的where所跟条件字段没有索引，会升级为表锁<br>            InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁</p></div><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1>锁分类 按照锁的粒度</li></ul><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th></tr></thead><tbody><tr><td>全局锁</td><td>锁定数据库中所有的表</td></tr><tr><td>表级锁</td><td>每次操作锁住整张表</td></tr><tr><td>行级锁</td><td>每次操作锁住对应的行数据</td></tr></tbody></table></div><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<br>备份当然要加全局锁啦，总不能刚备份完一张表，结果立马来了条新数据，那不就乱套了吗</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 添加全局锁<br>flush tables <span class="hljs-keyword">with</span> read lock ;<br># 数据备份<br>mysqldump <span class="hljs-operator">-</span>uroot<span class="hljs-operator">-</span>p1234 itcast<span class="hljs-operator">&gt;</span>itcast.sql<br># 解锁<br>unlock tables ;<br></code></pre></td></tr></table></figure><p> <a href="https://imgse.com/i/pAf9Uvd"><img src="https://s21.ax1x.com/2024/11/22/pAf9Uvd.jpg" alt="pAf9Uvd.jpg"></a></p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。<br>对于表级锁 主要分为三类</p><ul><li>表锁</li><li>元数据锁</li><li>意向锁<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3>表锁分为</li></ul><ol><li>表共享写锁(read lock)<ul><li>对一张表加 read lock后所有写操作都会堵塞，只能进行读操作</li></ul></li><li>表独占写锁(write lock)<ul><li>加写锁后只有自己可以进行读写操作，其他人的所有操作都会堵塞<br>语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 加锁<br>lock tables 表名... read<span class="hljs-operator">/</span>write;<br># 解锁<br>unlock tables<br></code></pre></td></tr></table></figure><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性<div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>简单来说 当有未提交的事务时，会对表结构加锁，此时不能修改表结构</p></div><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>分类</th><th>特点</th></tr></thead><tbody><tr><td>意向共享锁(IS)</td><td>与表锁共享锁(read)兼容，与表锁排它锁(write)互斥</td></tr><tr><td>意向排他锁(IX)</td><td>与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥</td></tr></tbody></table></div><p>可以通过这条sql查看该表的意向锁<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> object_schema,object_ name, index_name,lock type,lock_ mode,lock_data <span class="hljs-keyword">from</span> performance_schema.data_ locks;<br></code></pre></td></tr></table></figure></p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中<br>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。<br>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。<br>对于行级锁，主要分为以下三类</p><div class="table-container"><table><thead><tr><th>分类</th><th>含义</th></tr></thead><tbody><tr><td>行锁(Record Lock)</td><td>锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC，RR隔离级别下都支持</td></tr><tr><td>间隙锁(GapLock)</td><td>锁定索引记录间隙(不含该记录)，确保索引记录间除不变，防止其他事务在这个间隙进行inser，产生幻读。在RR隔离级别下都支持</td></tr><tr><td>临键锁(Next-Key Lock)</td><td>每次操作锁住对应的行数据行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持</td></tr></tbody></table></div><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB中有两种类型的行锁</p><ol><li>共享锁(S):允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁</li><li>排他锁(X):允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的排他锁和共享锁<br>如图是行锁的加锁方式，说明了在InnoDB中行锁是针对索引，而不是数据记录<br><a href="https://imgse.com/i/pAfWqy9"><img src="https://s21.ax1x.com/2024/11/23/pAfWqy9.jpg" alt="pAfWqy9.jpg"></a><div class="note primary flat"><p>注意：如果不通过索引条件检索数据，那么行锁会升级为表锁，例如 where所跟的条件字段没有建立索引，那么会升级为表锁</p></div></li></ol><div class="table-container"><table><thead><tr><th>分类</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>update</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>delete</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>select</td><td>不加锁</td><td></td></tr><tr><td>select … lock in share mode</td><td>共享锁</td><td>需要手动在select之后加 lock in share mode</td></tr><tr><td>select.. for update</td><td>排他锁</td><td>需要手动在select后加for update</td></tr></tbody></table></div><h3 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><ol><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁。</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)—会访问到不满足条件的第一个值为止。<br>间隙锁：锁的是两个索引之间的间隙 例如 6-12之间的间隙 但是不包括6和12<br><a href="https://imgse.com/i/pAfhB8S"><img src="https://s21.ax1x.com/2024/11/23/pAfhB8S.jpg" alt="pAfhB8S.jpg"></a><div class="note primary flat"><p>注意:间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></div>临键锁：行锁和间隙锁的结合<br><a href="https://imgse.com/i/pAfh0C8"><img src="https://s21.ax1x.com/2024/11/23/pAfh0C8.jpg" alt="pAfh0C8.jpg"></a></li></ol><h1 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h1><p>介绍原理之前我们需要先回顾一下事务的四大特性ACID</p><div class="table-container"><table><thead><tr><th>ACID</th><th>特性</th><th>实现</th></tr></thead><tbody><tr><td>原子性(Atomicity)</td><td>操作作单元，要么全部成功，要么全部失败。事务是不可分割的最小</td><td>redo.log undo.log</td></tr><tr><td>一致性(Consistency)</td><td>:事务完成时，必须使听有的数据都保持一致状态</td><td>redo.log undo.log</td></tr><tr><td>隔离性(lsolation)</td><td>数据库系统提供的隔离,制，保证事务在不受外部并发操作影响的独立环境下运行</td><td>锁，MVCC</td></tr><tr><td>持久性(Durability)</td><td>事务一旦提交或回滚它对数据库中的数据的改变就是永久的</td><td>redo.log undo.log</td></tr></tbody></table></div><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><ul><li>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。<br>该日志文件由两部分组成:重做日志缓冲(redolog buffer)以及重做日志文件(redolog file),前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。</li><li>redo log 的工作流程<br>当执行增删改sql时，会先访问内存中的Buffer Pool(缓存池)，如果缓存池中没有要操作的数据，缓存池会访问磁盘中的数据，并磁盘中的数据存入缓存池中，然后在缓存池中进行增删改的操作。增删改的操作结束后，会得到一些修改之后的数据(图中深橙色)，此时缓存池和磁盘数据不一致，我们称为脏页<br>，接着应该有缓存池将脏页数据刷新存储到磁盘中<br><a href="https://imgse.com/i/pAf4VG8"><img src="https://s21.ax1x.com/2024/11/23/pAf4VG8.jpg" alt="pAf4VG8.jpg"></a><br>为了防止脏页刷新存储失败我们引入了 redo.log, redolog buffer(日志缓冲) 会记录脏页的数据 并存入磁盘的 redolog file(日志文件)中，当发生脏页刷新失败时，通过redolog file 进行数据恢复<br><a href="https://imgse.com/i/pAf4RLd"><img src="https://s21.ax1x.com/2024/11/23/pAf4RLd.md.jpg" alt="pAf4RLd.md.jpg"></a></li></ul><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>回滚日志，用于记录数据被修改前的信息<br>作用包含两个:</p><ol><li>提供回滚 <ul><li>undolog和redolog记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当 update一条记录时，它记录一条对应相反的update记录。当执行rolback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。<div class="note primary flat"><p>注意:undo log在事务执行时产生，事务提交时，并不会立即删除undolog，因为这些日志可能还用于MVCC<br>    Undolog存储:undolog采用段的方式进行管理和记录，存放在前面介绍的 rollbacksegment 回滚段中，内部包含1024个undolog</p></div></li></ul></li><li>MVCC(多版本并发控制)。</li></ol><h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h2><p>基本概念</p><ol><li>快照读：<ul><li>简单的select(不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据。</li></ul></li><li>当前读：<ul><li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁<details class="toggle" style="border: 1px solid  [bg]"><summary class="toggle-button" style="background-color:  [bg];color:  [fg]">[快照读&当前读小例子]</summary><div class="toggle-content"><p>当我们执行一条 select <em> from user 的sql语句后，另一个客服端执行了 update set name= “小怪兽” where id =1 的sql语句并提交了事务<br>此时我们再次执行 select </em> from user 的结果 id为1 的name 并不等于 “小怪兽”,而是和第一次查询的结果相同。这是因为MYSQL的默认事务隔离级别解决了不可重复读的问题所以读到的数据是一样的，本质上是第一次的查询语句会进行一个快照，后面的查询都将是快照读。想要查到最新数据也很简单，第二次大的sql更改为 select * from user lock in share mode 就可以查询到最新数据了也就是当前读</p></div></details></li></ul></li><li>MVCC：<ul><li>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undolog日志、readView。<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3>其实我们创建的每张表中，MYSQL都会为我们自动生成两个或者三个隐藏字段 用于MVCC管理</li></ul></li></ol><div class="table-container"><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table></div><h3 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h3><p>不同事物或者相同事务对同一记录进行修改，会导致该记录的undolog生成一条记录版本链，链表的头部是最新的旧纪录，尾部是最早的旧纪录<br>例如：<br>多个事务一次对一条记录进行修改<br><a href="https://imgse.com/i/pAfI13T"><img src="https://s21.ax1x.com/2024/11/23/pAfI13T.jpg" alt="pAfI13T.jpg"></a><br>在事务2修改时会现在undolog备份原始记录，然后进行修改，隐式字段DB_TRX_ID 也会记录事务的Id,DB_ROLL_PTR会保存备份的地址<br><a href="https://imgse.com/i/pAfI3gU"><img src="https://s21.ax1x.com/2024/11/23/pAfI3gU.jpg" alt="pAfI3gU.jpg"></a><br>以此类推最终形成一个链表<br><a href="https://imgse.com/i/pAfI8vF"><img src="https://s21.ax1x.com/2024/11/23/pAfI8vF.jpg" alt="pAfI8vF.jpg"></a></p><h3 id="readView"><a href="#readView" class="headerlink" title="readView"></a>readView</h3><ol><li>ReadView是快照读SQL执行时MVCC提供的依据，记录并维护系统当前活跃的事务ID(未提交的ID)<div class="note primary flat"><p>我们在介绍快照读的时候介绍了快照读，读的可能是历史版本，那么读的是哪一个历史版本，这个问题就是由ReadView提供规则，MVCC根据规则判断读哪一个历史版本</p></div></li><li>首先介绍readView的四个字段</li></ol><div class="table-container"><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃事务Id集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务的ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，最大事务ID+1</td></tr><tr><td>creator_trx_id</td><td>ReadView创造者的事务ID</td></tr></tbody></table></div><ol><li>版本链访问规则(trx_id指当前事务ID也就是隐藏字段DB_TRX_ID)</li></ol><div class="table-container"><table><thead><tr><th>规则</th><th>是否成立</th><th>结果</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id?</td><td>成立，说明数据是当前这个事务更改的。</td><td>可以访问该版本</td></tr><tr><td>trx_id&lt;min_trx_id?</td><td>成立，说明数据已经提交了。</td><td>可以访问该版本</td></tr><tr><td>min_trx_id &lt;= trx_id&lt;= max trx id?</td><td>成立，说明数据已经提交。</td><td>如果trx id不在m ids中是可以访问该版本的</td></tr><tr><td>trx_id&gt;max_trx_id?</td><td>成立，说明该事务是在ReadView生成后才开启。</td><td>不可以访问该版本</td></tr></tbody></table></div><ol><li>RC(读已提交)隔离级别下 MVCC实现<br>RC隔离级别下 在事务中每一次执行快照读时生成ReadView。<br>我们仍用undo log 版本的例子来解释<br>当事务5执行第一次查询时，事务2已经提交事务，所以m_ids中只有3，4，5(未提交的事务ID)，此时readView的四个字段都已经明确了，<br>然后需要将trx_id代入规则判断是否成立，当前记录的trx_id为4代入四条规则均不成立，则根据undo log链进行下一个比对，即trx_id=3，进行对比；<br>直到trx_id=2时 第二条规则成立，所以访问的是DB_TRX_ID=2 的历史版本<br><a href="https://imgse.com/i/pAhSic9"><img src="https://s21.ax1x.com/2024/11/24/pAhSic9.jpg" alt="pAhSic9.jpg"></a></li></ol>]]></content>
    
    
    <summary type="html">数据库进阶学习</summary>
    
    
    
    
    <category term="MYSQL" scheme="http://example.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>AOP</title>
    <link href="http://example.com/2024/11/11/AOP/"/>
    <id>http://example.com/2024/11/11/AOP/</id>
    <published>2024-11-11T02:14:39.124Z</published>
    <updated>2024-11-18T13:38:41.165Z</updated>
    
    <content type="html"><![CDATA[<p>AOP 面向切面编程 是一种编程思想 可以在不惊动原始设计的基础上为其进行功能增强</p><ul><li>连接点（JoinPoint） 在 springAOP 中 表示 方法的执行</li><li>切入点（Pointcut）匹配连接点的式子<div class="note red icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>切入点可以匹配多个连接点</p></div></li><li>切面：描述通知与切入点的关系</li><li>编写通知类 其中包含切面和通知方法</li></ul><h1 id="AOP-的工作流程"><a href="#AOP-的工作流程" class="headerlink" title="AOP 的工作流程"></a>AOP 的工作流程</h1><ol><li>Spring 容器启动</li><li>读取所有切面配置中的切入点</li><li>初始化 bean，判定 Bean 对应的类中的方法是否匹配到任意切入点</li></ol><ul><li>匹配成功：创建目标对象的代理对象（在 spring 初始化 bean 的时候将代理对象存入 IOC 容器中）</li><li>匹配失败：创建对象（在 spring 初始化 bean 的时候一般会是创建对象 存入 IOC 容器中）</li></ul><ol><li>获取 bean 执行方法</li></ol><ul><li>获取 bean,调用方法并执行（正常执行，相当于没有用到 AOP）</li><li>获取的 bean 是代理对象时，根据代理对象的运行模式运行原来方法和增强内容</li></ul><h1 id="AOP-的通知类型"><a href="#AOP-的通知类型" class="headerlink" title="AOP 的通知类型"></a>AOP 的通知类型</h1><ol><li>前置通知（@Before 注解 在方法执行前执行增强内容）</li><li>后置通知（@After）</li><li>环绕通知（@Around 方法执行前后都会执行指定增强内容）<div class="note primary flat"><p>需要一个 ProceedingJoinPoint 类型的参数<br>pjp.proceed()表示原代码的执行（这样就可以指定增强的内容在方法执行前后执行了）</p></div><div class="note warning flat"><p>使用环绕通知的时候需要 接收原方法的返回值例如 Object ret = pjp.proceed(); 并 return。（原方法返回值类型是 void 除外）<br>否则会报错</p></div><img src="https://pic.imgdb.cn/item/6731bee4d29ded1a8c535c21.jpg" alt=""></li><li>返回后执行 （@AfterReturning） 方法成功执行完后通知<div class="note primary flat"><p>@AfterReturning 只有方法成功执行了后才通知<br>@Around 方法只要执行完就会通知（报错也会）</p></div></li><li>抛异常后执行（@AfterThrowing）</li></ol><h1 id="AOP-通知获取数据"><a href="#AOP-通知获取数据" class="headerlink" title="AOP 通知获取数据"></a>AOP 通知获取数据</h1><ul><li>获取切入点方法的参数<br>JoinPoint:适用于前置、后置、返回后、抛出异常后通知<br>ProceedJointPoint:适用于环绕通知<br>使用getArgs方法即可<div class="note primary flat"><p>环绕通知时可以接收并更改参数，并传入源代码中  </p></div><img src="https://pic.imgdb.cn/item/6731c411d29ded1a8c59de63.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/6731c454d29ded1a8c5a3082.jpg" alt=""></li><li>获取切入点方法返回值<br>返回后通知<br>环绕通知<br><img src="https://pic.imgdb.cn/item/6731c581d29ded1a8c5b99c0.jpg" alt=""></li><li>获取切入点方法运行异常信息<br>抛出异常后通知<br>环绕通知<br><img src="https://pic.imgdb.cn/item/6731c59ad29ded1a8c5bb85f.jpg" alt=""></li></ul><h1 id="AOP-和自定义注解实现公共字段填充"><a href="#AOP-和自定义注解实现公共字段填充" class="headerlink" title="AOP 和自定义注解实现公共字段填充"></a>AOP 和自定义注解实现公共字段填充</h1><div class="note primary flat"><p>@Component 注解：将这个类定义为 bean 交给 spring 容器管理<br>@Aspect ：告诉 sring 容器 这个 bean 是 AOP</p></div><div class="note primary flat"><ol><li>@Pointcut(“execution(<em> com.sky.mapper.</em>.*(..))&amp;&amp; @annotation(com.sky.anno.AutofILL)” )</li></ol><pre><code>- @Pointcut 注解：切入点用于匹配 连接点- execution(* com.sky.mapper.*.*(..)) : 连接点的表达式，意思是 在执行 com.sky.mapper下的所有类中的所有方法的时候 ，com前面的*表示方法的返回值可以是所有类型- @annotation(com.sky.anno.AutofILL) ：也是一个练级点的表达式 意思是 添加了com.sky.anno.AutofILL这个注解的方法</code></pre><ol><li>使用@Pointcut 需要一个空的方法 例如 public void pointcut() {}</li></ol></div><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutofILL &#123;<br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFILL</span> &#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..))&amp;&amp; @annotation(com.sky.anno.AutofILL)&quot; )</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-comment">//获取当前拦截方法的类型</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">Signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="hljs-comment">//这行代码是获取方法的签名对象</span><br>        AutofILL autofILL= Signature.getMethod().getAnnotation(AutofILL.class);<span class="hljs-comment">// 获得方法上的注解对象</span><br>        OperationType operationType= autofILL.value();<span class="hljs-comment">// 获取注解中的值</span><br>        <span class="hljs-comment">//获取实体对象</span><br>        Object[] args = joinPoint.getArgs();<span class="hljs-comment">// 获取方法的参数</span><br>        <span class="hljs-keyword">if</span>(args.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//准备复制数据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span>LocalDateTime.now();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>        <span class="hljs-comment">//赋值</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateTime</span> <span class="hljs-operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME,LocalDateTime.class);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,LocalDateTime.class);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUesr</span> <span class="hljs-operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER,Long.class);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,Long.class);<br>        <span class="hljs-comment">/* 这里利用了反射去获取到原参数的set方法  首先object.getClass()获取到了object的类（及参数的实体类）</span><br><span class="hljs-comment">          getDeclaredMethod 是获取当前类的一个方法（需要用参数指定获取方法的方法名，以及该方法需要的参数类型）</span><br><span class="hljs-comment">          最后获取到的是一个set方法 所以返回值类型是 Method */</span><br>        <span class="hljs-keyword">if</span> (operationType==OperationType.INSERT) &#123;<br>            setCreateTime.invoke(object,now);<span class="hljs-comment">// 通过反射赋值</span><br>            setUpdateTime.invoke(object,now);<br>            setCreateUesr.invoke(object,id);<br>            setUpdateUser.invoke(object,id);<br><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operationType==OperationType.UPDATE) &#123;<br>            setUpdateUser.invoke(object,id);<br>            setUpdateTime.invoke(object,now);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">AOP实现公共字段自动填充</summary>
    
    
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师错题</title>
    <link href="http://example.com/2024/10/17/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E9%94%99%E9%A2%98/"/>
    <id>http://example.com/2024/10/17/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E9%94%99%E9%A2%98/</id>
    <published>2024-10-17T12:41:39.135Z</published>
    <updated>2024-11-11T09:37:28.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><img src="https://pic.imgdb.cn/item/67110830d29ded1a8c4c4a86.jpg" alt=""><br>信号量的最小值为 -（进程数n-资源可用数） 最大值为资源可用数</p><h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><ol><li>编译方式生成逻辑上与源程序等价的目标程序，解释语言不会<h1 id="霍夫曼编码-字符序列"><a href="#霍夫曼编码-字符序列" class="headerlink" title="霍夫曼编码- 字符序列"></a>霍夫曼编码- 字符序列</h1><img src="https://pic.imgdb.cn/item/67110973d29ded1a8c4d5396.jpg" alt=""><br>解题思路：将字符出现的频率构造二叉树 同层下左子树要小于右子树<br><img src="https://pic.imgdb.cn/item/67110ae1d29ded1a8c4e9d7c.jpg" alt=""><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><img src="https://pic.imgdb.cn/item/6712266ad29ded1a8c9cbee9.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/671226f2d29ded1a8c9dfb45.jpg" alt=""><br>先计算出logba的值也就是3，当n足够大时比较一下n2和n3是否约等，约等就等于n3<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1></li><li>二叉排序树：左子树值最小，右子树值最大， 左小右大  只有中序遍历可以得到递增的有序序列<br>单支树：查询效率最差</li><li>这种头节点从1开始算而不是0<br><img src="https://pic.imgdb.cn/item/67137fc3d29ded1a8c80f7d6.jpg" alt=""><h1 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h1>全文件名=全路径文件名=绝对路径=完整路径<br>相对路径不以 / 开头，而是从当前目录开始<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1>动态绑定：在运行时进行<br>静态绑定：在编译时进行<br>参数多态： 应用广泛，最纯的多态<br>包含多态： 同样的操作可用于一个类型及其子类型。一般需要进行运行时的类型检查<br>强制多态： 编译程序通过语法操作，把操作对象的类型强行加以变化，以符合函数或操作符的要求<br>过载多态： 同一个名在不同的上下文中有不同类型<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2>原型模型 ：可以有效捕获系统需求<br>瀑布模型：项目开始时需求已经确定，面向对象开发的模型！！！<br>V模型 ：  说明测试活动是如何与 分析和设计相联系的<br>螺旋模型： 把开发活动和风险管控结合，将风险减到最小并控制风险<h2 id="CMM"><a href="#CMM" class="headerlink" title="CMM"></a>CMM</h2><img src="https://pic.imgdb.cn/item/6714f4bed29ded1a8ce7d16f.png" alt=""><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><img src="https://pic.imgdb.cn/item/67138594d29ded1a8c8aac2c.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/671385aed29ded1a8c8aeca7.jpg" alt=""></li><li>类图：展示了一组对象，接口，协作和他们之间的关系，在开发软件系统时，类图用于对系统的静态设计视图建模</li><li>部署图：表示待开发软件系统中软件组件和硬件之间的物理关系</li><li>顺序图：一种交互图，交互图由一组对象或参与者以及他们之间可能发送的消息构成，交互图专注系统的动态视图，顺序图是强调消息的时间次序的交互图<br><img src="https://pic.imgdb.cn/item/671385d8d29ded1a8c8b50bd.jpg" alt=""><br>实线箭头：调用方法<br>虚线箭头：返回消息</li><li>通信图 : 通信图强调手法消息的对象或参与者的结构组织<br><img src="https://pic.imgdb.cn/item/671385efd29ded1a8c8b8933.jpg" alt=""></li><li>活动图：有开始和结束（大黑点标志的是活动图）<br><img src="https://pic.imgdb.cn/item/6713860dd29ded1a8c8bd269.jpg" alt=""></li><li>状态图：给出了对象的动态视图，由状态，转移，事件和活动组成    []里的为监护条件<br><img src="https://pic.imgdb.cn/item/67138620d29ded1a8c8c0080.jpg" alt=""></li><li>构件图： 描述了一个封装的类和他的接口，端口，以及由内嵌的组件和连接组件构成的内部结构，用于表示系统的静态设计实现视图<br><img src="https://pic.imgdb.cn/item/67138634d29ded1a8c8c33ea.jpg" alt=""><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><img src="https://pic.imgdb.cn/item/6714f475d29ded1a8ce78b18.jpg" alt=""></li><li>抽象工厂模式：提供一个接口，可以创造一系列相关或者相关依赖的对象，而无需指定他们具体的类  简单来说就是工具类，抽取出来，其他类调用</li><li>工厂模式： 定义一个创建对象的接口，但由子类决定需要实例化哪一个类</li><li>原型模式： 用原型实例指定创建对象的类型，并通过拷贝原型来创造新对象， 特点是快，省资源</li><li>生成器模式：将一个复杂类的表示与其结构分离，使相同的构建过程能够得出不同的表示<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1></li><li><img src="https://pic.imgdb.cn/item/67122c84d29ded1a8ca5f774.jpg" alt=""><br>RxS是进行笛卡尔积运算，得到的结果是（A,B,C,D,B,C,E,F）不会去掉重复的<br>Π是投影 表示列； σ表示行<br>自然连接：在笛卡尔积的基础上删除重复的<h1 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h1></li><li>商标权保护期限可以延长</li><li>软件文档的著作权有公司享有<h1 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2></li><li>总线复用：减少总线中的信号线的数量</li><li>定点表示中，小数点不占用存储位<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1></li><li>https是基于SSH安全协议 端口号443<h2 id="千小时可靠度"><a href="#千小时可靠度" class="headerlink" title="千小时可靠度"></a>千小时可靠度</h2><img src="https://pic.imgdb.cn/item/67123065d29ded1a8caa6af5.jpg" alt=""><br>R1,R2并联的可靠度为 (1-(1-R1)(1-R2))<h1 id="McCabe-度量法"><a href="#McCabe-度量法" class="headerlink" title="McCabe 度量法"></a>McCabe 度量法</h1><img src="https://pic.imgdb.cn/item/67137f2fd29ded1a8c804cdf.jpg" alt=""><br>复杂度为： 边数量-顶点数量+2<br>答案：5</li></ol>]]></content>
    
    
    <summary type="html">刷题刷崩溃啦</summary>
    
    
    
    
    <category term="软件设计师" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>uniapp</title>
    <link href="http://example.com/2024/09/28/uniapp/"/>
    <id>http://example.com/2024/09/28/uniapp/</id>
    <published>2024-09-28T01:56:30.933Z</published>
    <updated>2024-11-11T09:38:57.731Z</updated>
    
    <content type="html"><![CDATA[<p>学习uniapp主要干活要用，但主要还是继续学JAVA，所以来简单了解一下</p><h1 id="了解uniapp"><a href="#了解uniapp" class="headerlink" title="了解uniapp"></a>了解uniapp</h1><p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台</p><h1 id="uniapp的常用组件"><a href="#uniapp的常用组件" class="headerlink" title="uniapp的常用组件"></a>uniapp的常用组件</h1><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>view 视图容器 类似与传统的div标签<br>添加hover-stop-propagation属性可以防止事件冒泡</p><p>  属性名    类型    默认值    说明</p><ul><li>hover-class    String    none    指定按下去的样式类。当 hover-class=”none” 时，没有点击态效果</li><li>hover-stop-propagation    Boolean    false    指定是否阻止本节点的祖先节点出现点击态，App、H5、支付宝小程序、百度小程序不支持（支付宝小程序、百度小程序文档中都有此属性，实测未支持）</li><li>hover-start-time    Number    50    按住后多久出现点击态，单位毫秒</li><li>hover-stay-time    Number    400    手指松开后点击态保留时间，单位毫秒<h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2>文本组件。用于包裹文本内容。文本只能写在text中，而不能写在view的text区域<br><img src="https://pic.imgdb.cn/item/66f7678bf21886ccc0e2258c.png" alt=""></li></ul><h2 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h2><p>可滚动视图区域。用于区域滚动。</p><p>需注意在webview渲染的页面中，区域滚动的性能不及页面滚动</p><ul><li><p>scroll-y    Boolean    false    允许纵向滚动<br><img src="https://pic.imgdb.cn/item/66f76ebff21886ccc0ec217e.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f76ea8f21886ccc0ec023c.png" alt=""></p></li><li><p>scroll-x    Boolean    false    允许横向滚动</p></li><li>子元素默认纵向排，在子元素的css样式中加 display: inline-block;</li><li>父元素css中设置不允许自动换行 white-space: nowrap;<br><img src="https://pic.imgdb.cn/item/66f76fa0f21886ccc0ed4e6e.png" alt=""></li></ul><h2 id="滑块视图容器"><a href="#滑块视图容器" class="headerlink" title="滑块视图容器"></a>滑块视图容器</h2><p>一般用于左右滑动或上下滑动，比如banner轮播图。</p><ul><li>indicator-dots    Boolean    false    是否显示面板指示点    </li><li>indicator-color    Color    rgba(0, 0, 0, .3)    指示点颜色    </li><li>indicator-active-color    Color    #000000    当前选中的指示点颜色    </li><li>active-class    String        swiper-item 可见时的 class    支付宝小程序</li><li>changing-class    String        acceleration 设置为 true 时且处于滑动过程中，中间若干屏处于可见时的class    支付宝小程序</li><li>autoplay    Boolean    false    是否自动切换<br><img src="https://pic.imgdb.cn/item/66f7749af21886ccc0f2ef09.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f7747bf21886ccc0f2d64c.png" alt=""></li></ul><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>这个是VUE的一个API，学习uniapp的时候碰到了就记录到这吧<br>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护</p><ul><li>在图中 两个view 标签展示出来的内容是一样的，第二个view采用了计算属性，第一个view是模板表达式<br><img src="https://pic.imgdb.cn/item/6704f20ad29ded1a8c6c86f1.jpg" alt=""><div class="note info no-icon flat"><p>计算属性的作用和模板表达式是一样的，但是如果计算较多建议使用计算属性</p></div></li><li>这是一个方法代替计算属性，最终展示效果也是一样的<br><img src="https://pic.imgdb.cn/item/6704f2ffd29ded1a8c6da383.jpg" alt=""></li></ul><div class="note red icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>计算属性和方法最终结果是一样的，不同之处在于计算属性会进行一个缓存，只要计算属性中响应式变量不变化就不会重新执行，而方法只要被调用几次就会执行几次。 方法需要加括号!</p></div><h1 id="页面传值"><a href="#页面传值" class="headerlink" title="页面传值"></a>页面传值</h1><p>今天已经开始进入项目帮忙开发功能了 第一个功能 部门功能<br>记录一下学到的东西<br>由于我目前只写了前端所以在添加部门这一块的时候会将数据传给index主页面，这时候用到了页面传参数的功能。所以我去了解了一下<br><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>页面传参也分为了三种</p></div></p><h2 id="上级页面传下级页面"><a href="#上级页面传下级页面" class="headerlink" title="上级页面传下级页面"></a>上级页面传下级页面</h2><p>上级页面传参数的时候可以用uni.navigateTo的url拼接参数即可<br><div class="note warning simple"><p>这种方式是单向的，只能上级传下级！！！</p></div><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">//在起始页面跳转到test.vue页面并传递参数<br>let uniapp = &#123;<br>    uniappItem: 0,<br>&#125;;<br>//当传递的参数是对象时，必须先转化为JSON格式<br>uni.navigateTo(&#123;<br>url: &#x27;test?id=1&amp;name=&#x27; + JSON.stringify(uniapp),<br>&#125;);<br></code></pre></td></tr></table></figure><br>下级页面接收参数可以在周期函数中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs []">onLoad: function (option) &#123; //option为object类型，会序列化上个页面传递的参数<br>console.log(option.id); //打印出上个页面传递的参数。<br>console.log(option.name); //打印出上个页面传递的参数。<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="下级传上级"><a href="#下级传上级" class="headerlink" title="下级传上级"></a>下级传上级</h2><p>用uni.setStorageSync设置缓存<br>下级页面在触发submit这个函数的时候会将formData存入缓存中，并跳转页面<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs []">export default &#123;<br>data() &#123;<br>return &#123;<br>formData:&#123;<br>departName: &quot;&quot;,<br>departType: &quot;&quot;,<br>isOpen: &quot;&quot;,<br>remark: &quot;&quot;,&#125;<br>&#125;<br>&#125;,<br>methods:&#123;<br>submit(ref)&#123;<br>//写死数据这里是将添加的数据传到主页面中<br>//后期应修改成发送请求到后端<br>uni.setStorageSync(&#x27;formData&#x27;, this.formData);<br>uni.navigateTo(&#123;<br>url:&#x27;/pages/flow/department/departmentindex&#x27;,<br>&#125;)<br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/670ce751d29ded1a8cf618ec.png" alt="">点击保存就会触发submit函数</p><p>上级页面通过onShow查找缓存uni.getStorageSync得到数据<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">onShow() &#123;<br>       const param = uni.getStorageSync(&#x27;formData&#x27;);<br>       if (param) &#123;<br>           // 处理从下级页面传来的参数<br>         this.formData.departmentName = param.departName<br>         this.formData.departmentTpye = param.departType<br>         this.dataList.push(this.formData)<br>         uni.removeStorageSync(&#x27;formData&#x27;);<br>       &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/670ce78ed29ded1a8cf65ec5.png" alt=""></p><h1 id="规则校验"><a href="#规则校验" class="headerlink" title="规则校验"></a>规则校验</h1><p>今日份学习小技巧<br>在uniapp中表单校验步骤</p><h2 id="1-在表头添加rules"><a href="#1-在表头添加rules" class="headerlink" title="1. 在表头添加rules"></a>1. 在表头添加rules</h2><p><img src="https://pic.imgdb.cn/item/670ddb11d29ded1a8cbfc66a.png" alt=""></p><h2 id="2-编写规则"><a href="#2-编写规则" class="headerlink" title="2. 编写规则"></a>2. 编写规则</h2><div class="note warning simple"><p>rules应写在data函数中的return中</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">rules: &#123;<br>departName: &#123;<br>rules: [&#123;<br>required: true,<br>errorMessage: &#x27;必填字段不能为空&#x27;,<br>&#125;]<br>&#125;,<br>departType: &#123;<br>rules: [&#123;<br>required: true,<br>errorMessage: &#x27;必填字段不能为空&#x27;,<br>&#125;]<br>&#125;,<br>isOpen: &#123;<br>rules: [&#123;<br>required: true,<br>errorMessage: &#x27;必填字段不能为空&#x27;,<br>&#125;]<br>&#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="3，编写方法触发规则校验"><a href="#3，编写方法触发规则校验" class="headerlink" title="3，编写方法触发规则校验"></a>3，编写方法触发规则校验</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">// 触发提交表单<br>submit() &#123;<br>this.$refs.form.validate().then(res=&gt;&#123;<br>console.log(&#x27;表单数据信息：&#x27;, res);<br>&#125;).catch(err =&gt;&#123;<br>console.log(&#x27;表单错误信息：&#x27;, err);<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习uniapp主要干活要用，但主要还是继续学JAVA，所以来简单了解一下&lt;/p&gt;
&lt;h1 id=&quot;了解uniapp&quot;&gt;&lt;a href=&quot;#了解uniapp&quot; class=&quot;headerlink&quot; title=&quot;了解uniapp&quot;&gt;&lt;/a&gt;了解uniapp&lt;/h1&gt;&lt;p&gt;u</summary>
      
    
    
    
    
    <category term="uniapp" scheme="http://example.com/tags/uniapp/"/>
    
  </entry>
  
  <entry>
    <title>springcloud</title>
    <link href="http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-09-10T08:20:20.287Z</published>
    <updated>2024-11-18T09:17:44.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>将业务的所有功能集中在一个项目中开发，打成一个包部署</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>架构简单</li><li>部署成本低<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>团队协作成本高</li><li>系统发布效率低</li><li>系统可用性差<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2>把单体架构的功能模块拆分成多个独立的项目<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3></li><li>粒度小： 拆分的项目可以可以只是一个单独的功能</li><li>团队自治</li><li>服务自治<h1 id="拆分黑马商城"><a href="#拆分黑马商城" class="headerlink" title="拆分黑马商城"></a>拆分黑马商城</h1>原单体架构的目录结构<br><img src="https://pic.imgdb.cn/item/66e2a722d9c307b7e9bb1bfa.png" alt=""><h2 id="拆分商品功能为一个微服务"><a href="#拆分商品功能为一个微服务" class="headerlink" title="拆分商品功能为一个微服务"></a>拆分商品功能为一个微服务</h2>本项目利用maven模块拆分，亦可以创建多个项目实例<h3 id="创建maven模块（item-service）"><a href="#创建maven模块（item-service）" class="headerlink" title="创建maven模块（item-service）"></a>创建maven模块（item-service）</h3>将item商品的有关代码复制粘贴到item-service中<br>需要创建启动类和修改yaml文件(端口号，和swagger的扫描路径)和添加pom的依赖<br><img src="https://pic.imgdb.cn/item/66e2a801d9c307b7e9bc13cf.png" alt=""><h3 id="创建item数据库"><a href="#创建item数据库" class="headerlink" title="创建item数据库"></a>创建item数据库</h3>因为是微服务和原本的项目已经隔离开了，所以每一个微服务都要需要对应的mysql表<br><img src="https://pic.imgdb.cn/item/66e2a957d9c307b7e9bda7b1.png" alt=""><h2 id="同理拆分购物车"><a href="#同理拆分购物车" class="headerlink" title="同理拆分购物车"></a>同理拆分购物车</h2></li></ol><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>微服务之间是互相隔离的，相当于独立的小项目，所以微服务之间不能直接相互调用<br>但在实际业务中，经常会需要商品业务的业务逻辑中需要调用购物车的api，同理购物车也要商品的api等<br>注册中心就可以解决微服务之间互相调用的问题</p><h2 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h2><p><img src="https://pic.imgdb.cn/item/66e2aac9d9c307b7e9bf65e9.png" alt=""><br>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>简介 Nacos 有阿里开发<br>实际上 Nacos也需要一台独立的计算机来部署，为了方便学习，我们在虚拟机上利用Docker部署Nacos</p><h3 id="创建Nacos数据库"><a href="#创建Nacos数据库" class="headerlink" title="创建Nacos数据库"></a>创建Nacos数据库</h3><p>数据库sql可在官方文档中查找<br><img src="https://pic.imgdb.cn/item/66e2ac6fd9c307b7e9c1afa9.png" alt=""></p><h3 id="Docker部署Nacos"><a href="#Docker部署Nacos" class="headerlink" title="Docker部署Nacos"></a>Docker部署Nacos</h3><p>nacos的数据库配置传入虚拟机<br><img src="https://pic.imgdb.cn/item/66e2ace0d9c307b7e9c24390.png" alt=""><br>创造容器并执行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">docker run -d \<br>--name nacos \<br>--env-file ./nacos/custom.env \<br>-p 8848:8848 \<br>-p 9848:9848 \<br>-p 9849:9849 \<br>--restart=always \<br>nacos/nacos-server:v2.1.0-slim<br></code></pre></td></tr></table></figure><br>部署成功页面<br><img src="https://pic.imgdb.cn/item/66e2ad7bd9c307b7e9c310a5.png" alt=""></p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><ol><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66e2b98ad9c307b7e9d11c3f.png" alt=""></li></ol><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><ol><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3></li><li>添加依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.128</span>:<span class="hljs-number">8848</span> # nacos地址<br></code></pre></td></tr></table></figure></li><li>利用DiscoveryClient工具<br>以下代码可以获取到nacos中的一个item-service的实例，然后获取该实例url发送请求即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//获取实例</span><br>      List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;item-service&quot;</span>);<br>      <span class="hljs-keyword">if</span> (CollUtils.isEmpty(instances)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">//负载均衡 选择一个实例</span><br>      <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));<br></code></pre></td></tr></table></figure><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1>OpenFeign 用于简化服务调用的过程<h2 id="OpenFeign快速入门"><a href="#OpenFeign快速入门" class="headerlink" title="OpenFeign快速入门"></a>OpenFeign快速入门</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3>在cart-service服务的pom.xml中引入OpenFeign的依赖和loadBalancer依赖<br>loadBalancer依赖是用与负载均衡的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--openFeign--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--负载均衡器--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="2-启动OpenFeign功能"><a href="#2-启动OpenFeign功能" class="headerlink" title="2.启动OpenFeign功能"></a>2.启动OpenFeign功能</h3>接下来，我们在cart-service的CartApplication启动类上添加注解，启动OpenFeign功能<br><img src="https://pic.imgdb.cn/item/66e2dd53d9c307b7e911453a.png" alt=""></li></ol><h3 id="3-编写FeignClient"><a href="#3-编写FeignClient" class="headerlink" title="3.编写FeignClient"></a>3.编写FeignClient</h3><ol><li><p>@GetMapping(“/items”)<br>List<ItemDTO> queryItemByIds(@RequestParam(“ids”) Collection<Long> ids);<br>这个方法使需要从item-service模块的controller找到对应的方法<br>例如这是未拆分前的购物车中调用item的方法这是一个通过id查询商品的功能，<br>如果需要拆分调用，我们就需要在item模块的controller中找到通过id查询商品的接口，将这个接口抽取出来<br><img src="https://pic.imgdb.cn/item/66e434e0d9c307b7e9f3889b.png" alt=""><br>如果需要拆分调用，我们就需要在item模块的controller中找到通过id查询商品的接口，将这个接口抽取出来<br><img src="https://pic.imgdb.cn/item/66e4359cd9c307b7e9f434a5.png" alt=""><br>抽取到一个公共模块中<br><img src="https://pic.imgdb.cn/item/66e435e7d9c307b7e9f47292.png" alt=""></p></li><li><p>@FeignClient(“item-service”)的作用是获取nacos中item-service的实例</p></li><li>@GetMapping(“/items”)的作用：声明请求路径，会在获得实例的http路径后加上/items <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.hmall.cart.client;<br><br><span class="hljs-keyword">import</span> com.hmall.cart.domain.dto.ItemDTO;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@FeignClient(&quot;item-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/items&quot;)</span><br>    List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-调用-ItemClient"><a href="#4-调用-ItemClient" class="headerlink" title="4.调用 ItemClient"></a>4.调用 ItemClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">List&lt;ItemDTO&gt; items = itemClient.queryItembyidList(itemIds);<br></code></pre></td></tr></table></figure>相比于之前代码比较<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">/获取实例<br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;item-service&quot;</span>);<br>        <span class="hljs-keyword">if</span> (CollUtils.isEmpty(instances)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//负载均衡 选择一个实例</span><br>        <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> instances.get(RandomUtil.randomInt(instances.size()));<br>        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(<br>                serviceInstance.getUri() + <span class="hljs-string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,<br>                HttpMethod.GET,<br>                <span class="hljs-literal">null</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<br>                Map.of(<span class="hljs-string">&quot;ids&quot;</span>, CollUtils.join(itemIds, <span class="hljs-string">&quot;,&quot;</span>))<br>        );<br>        List&lt;ItemDTO&gt; items =<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (response.getStatusCode().is2xxSuccessful()) &#123;<br>           items = response.getBody();<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="OpenFeign-的连接池"><a href="#OpenFeign-的连接池" class="headerlink" title="OpenFeign 的连接池"></a>OpenFeign 的连接池</h3>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</li></ol><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--OK http 的依赖 --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;<br>  &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h4 id="开启连接池-在yaml文件中"><a href="#开启连接池-在yaml文件中" class="headerlink" title="开启连接池 在yaml文件中"></a>开启连接池 在yaml文件中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">feign:<br>  okhttp:<br>    enabled: <span class="hljs-literal">true</span> # 开启OKHttp功能<br></code></pre></td></tr></table></figure><h3 id="抽取OpenFeign为公共模块"><a href="#抽取OpenFeign为公共模块" class="headerlink" title="抽取OpenFeign为公共模块"></a>抽取OpenFeign为公共模块</h3><p>因为很多功能模块都需要用到OpenFeign，抽取成公共模块可以使代码更优雅<br>抽取成如下，同时需要添加nacos，OpenFeign等需要的依赖<br><img src="https://pic.imgdb.cn/item/66e3f3dfd9c307b7e9aa5fa9.png" alt=""><br>当其他功能模块需要使用远程调用的时候导入hm-api的坐标即可<br>这个错误表示查找不到对应的Bean，说明扫描包并没有扫描到hm-api<br><img src="https://pic.imgdb.cn/item/66e3f469d9c307b7e9aaf1ec.png" alt=""><br>在启动类添加注解 @EnableFeignClients(basePackages = “com.heima.api.client”) 即可</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关 就是网络的关口，负责请求的路由，转发，身份校验。<br>网关一般用于微服务中，微服务中每个微服务都有各自的ip地址请求路径等，</p><ol><li>不使用网关的情况下 前端每次发送请求都需要发送到微服务的IP地址上，并且都需要身份验证，这样会很麻烦。</li><li>使用网关的情况下，前端的所有请求都可以发送到网关上，由网关分析，身份验证，处理然后转发到对应的微服务上<br>网关的作用我觉得和单体架构的拦截器有点像，都可以拦截请求路径，然后处理判断，再发送到具体的请求方法上，<br>不过网关更加强大，可以拦截不同IP地址的请求，再转发<br>网关也更像小区保安 ： 一个前端请求过来，网关就会判断请求转发的IP地址，在身份确认后转发该请求<br><img src="https://pic.imgdb.cn/item/66e55a68d9c307b7e9ee8ddd.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/66e55aced9c307b7e9eefe28.jpg" alt=""><h2 id="网关快速入门"><a href="#网关快速入门" class="headerlink" title="网关快速入门"></a>网关快速入门</h2>网关本身也是一个微服务，所以需要先创建网关微服务</li></ol><ul><li>创建网关<br><img src="https://pic.imgdb.cn/item/66e55b5ad9c307b7e9ef8904.png" alt=""></li><li>引入网关和负载均衡的依赖<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">&lt;!--网关--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--nacos discovery--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--负载均衡--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>创建启动类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.hmall.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(GatewayApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>配置yaml文件<br><img src="https://pic.imgdb.cn/item/66e55c2ad9c307b7e9f04495.jpg" alt=""></li></ul><h2 id="网关登录验证"><a href="#网关登录验证" class="headerlink" title="网关登录验证"></a>网关登录验证</h2><p>使用网关进行登录校验，首先我们需要先了解网关的执行流程</p><h3 id="网关的执行流程"><a href="#网关的执行流程" class="headerlink" title="网关的执行流程"></a>网关的执行流程</h3><p>当前端发来请求到网关，网关会先执行断言（HandlerMapper），断言的作用是根据前端传来的请求，来判断目的地微服务，断言结束后，会执行过滤器处理器，里面会有很多的过滤器，会依次执行这些过滤器，NettyRoutingFilter是最后一个过滤器，它负责将处理后的请求转发到微服务上<br>所以网关登录校验即是自定义一个过滤器用来判断身份<br><img src="https://pic.imgdb.cn/item/66e6c8b2d9c307b7e9b2d7fa.jpg" alt=""></p><h3 id="自定义网关过滤器"><a href="#自定义网关过滤器" class="headerlink" title="自定义网关过滤器"></a>自定义网关过滤器</h3><p> GlobalFilter : 全局过滤器，作用范围i是所有路由，声明后自动生效<br> 以下是一个自定义的网关过滤器：</p><ol><li>该过滤器实现了 GlobalFilter接口，其中ServerWebExchange exchange变量是存储过滤器中的数据的，所以每一个过滤器调用数据都需要从exchange中调取，经过过滤器处理后需要得到一个新的ServerWebExchange类型的变量例如exchange1，然后 利用GatewayFilterChain chain的chain.filter(exchange1)方法将处理后的数据传入下一个过滤器</li><li>该过滤器实现了  Ordered接口 ，是用来规定过滤器的执行顺序的，Ordered的方法返回值越小，则越先执行</li><li>该过滤器的作用：先获取请求头，从请求头中的路径判断是否需要拦截（因为有些功能不需要拦截，例如注册登录），需要拦截则获取请求头Authorization中的token，如果token为空则返会401，token不为空则解析token，获得token中的userId，然后将userId封装到user-info请求头中，并放入新的exchange1 中，传入下一个过滤器，最终转发到微服务上<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthProperties authProperties;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTool jwtTool;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1,获取请求头</span><br>       <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>       <span class="hljs-comment">// 判断是否需要拦截</span><br>        <span class="hljs-keyword">if</span>(isExclude(request.getPath().toString()))<br>        &#123;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 获取token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>         List&lt;String&gt; authorization = request.getHeaders().get(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>         <span class="hljs-keyword">if</span> (authorization != <span class="hljs-literal">null</span> &amp;&amp; authorization.size() &gt; <span class="hljs-number">0</span>) &#123;<br>             token = authorization.get(<span class="hljs-number">0</span>);<br>         &#125;<br>         <span class="hljs-comment">// 解析校验token</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>             userId= jwtTool.parseToken(token);<br>         &#125;<span class="hljs-keyword">catch</span> (UnauthorizedException e)<br>         &#123;<br>              <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>              response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>              <span class="hljs-keyword">return</span> response.setComplete();<br>         &#125;<br>         <span class="hljs-comment">//传递用户信息</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> userId.toString();<br>         <span class="hljs-type">ServerWebExchange</span> <span class="hljs-variable">exchange1</span> <span class="hljs-operator">=</span> exchange.mutate()<br>                .request(builder -&gt; builder.header(<span class="hljs-string">&quot;user-info&quot;</span>, userInfo))<br>                .build();<br>        <span class="hljs-keyword">return</span> chain.filter(exchange1);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExclude</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String pathPattern : authProperties.getExcludePaths())&#123;<br>            <span class="hljs-keyword">if</span> (antPathMatcher.match(pathPattern, path)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网关传递用户信息"><a href="#网关传递用户信息" class="headerlink" title="网关传递用户信息"></a>网关传递用户信息</h3><ol><li>在自定义网关过滤器中，已经将用户Id传入请求头中，所以在微服务中需要拦截器获取用户Id<br><img src="https://pic.imgdb.cn/item/66e6c8d5d9c307b7e9b2f1e1.jpg" alt=""></li><li>在公共类中创建拦截器,因为在网关中已经做过获取和解析token了，所以这个请求头里并没有加密，只有用户id<br><img src="https://pic.imgdb.cn/item/66e6c9f1d9c307b7e9b3db6a.png" alt=""></li><li>注册拦截器，拦截器需要一个配置类注册才能生效<br>需要多加一个注解@ConditionalOnClass(DispatcherServlet.class)，该注解的意思是这个配置类生效的范围是拥有DispatcherServlet.class的模块，因为网关的依赖的中并没有springmvc，其他模块微服务都是基于springmvc的，而DispatcherServlet.class正是springmvc的核心之一，所以这个配置类将不会再网关中生效<br><img src="https://pic.imgdb.cn/item/66e6ca4fd9c307b7e9b4243a.png" alt=""><h1 id="OpenFeign的补充"><a href="#OpenFeign的补充" class="headerlink" title="OpenFeign的补充"></a>OpenFeign的补充</h1></li><li>前面已经实现了用OpenFeign进行微服务之间的调用，还有一个问题微服务之间调用的同时传入用户信息需要OpenFeign解决</li><li>我们利用网关将用户登录的信息转发到了微服务上，但是微服务和微服务之间相互调用的时候并不能传入用户的登录信息，</li><li>我们又知道微服务之间的远程调用时利用OpenFeign做到的，所以OpenFeign提供了拦截器为我们解决这个问题<br><img src="https://pic.imgdb.cn/item/66e7dd28d9c307b7e908b110.jpg" alt=""><h2 id="OpenFeign的拦截器"><a href="#OpenFeign的拦截器" class="headerlink" title="OpenFeign的拦截器"></a>OpenFeign的拦截器</h2><img src="https://pic.imgdb.cn/item/66e7deadd9c307b7e90b2a17.jpg" alt=""><br>这个拦截器很简单就写在了同一个配置类下，当然可以新建一个配置类然后实现RequestInterceptor接口<br><img src="https://pic.imgdb.cn/item/66e7de5fd9c307b7e90ab226.png" alt=""></li></ol></li></ol><h1 id="Nacos的扩展-配置共享"><a href="#Nacos的扩展-配置共享" class="headerlink" title="Nacos的扩展 配置共享"></a>Nacos的扩展 配置共享</h1><p>在我们的微服务中很多配置（例如mybatispuls,日志，数据库连接池）都是微服务共有的，这需要我们在每个微服务里都写一遍，这是很麻烦的<br>所以Nacos为我们解决了这个问题</p><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><h3 id="在Nacos上添加配置"><a href="#在Nacos上添加配置" class="headerlink" title="在Nacos上添加配置"></a>在Nacos上添加配置</h3><p>注意 ：dataID不能乱写，因为是yaml格式的文件，所以 dataid的结尾必须是 .yaml<br><img src="https://pic.imgdb.cn/item/66eac48df21886ccc0d074fc.png" alt=""></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">&lt;!--nacos配置管理--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--读取bootstrap文件--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="编写bootstrap-yaml"><a href="#编写bootstrap-yaml" class="headerlink" title="编写bootstrap.yaml"></a>编写bootstrap.yaml</h3><p>在此之前我们需要先了解sringboot的启动顺序，springboot启动会先加载application.yml，然后初始化ApplicationContext；<br>在微服务Springcloud中启动，sringclound会先在bootstrap.yaml中拉取nacos的共享配置，然后初始化ApplicationContext，接着加载springboard的application.yml，进行配置整合，最后初始化<br><img src="https://pic.imgdb.cn/item/66eac6b4f21886ccc0d26cf3.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">spring:<br>  application:<br>    name: cart-service # 服务名称<br>  profiles:<br>    active: dev<br>  cloud:<br>    nacos:<br>      server-addr: <span class="hljs-number">192.168</span><span class="hljs-number">.217</span><span class="hljs-number">.128</span> # nacos地址<br>      config:<br>        file-extension: yaml # 文件后缀名<br>        shared-configs: # 共享配置<br>          - dataId: shared-jdbc.yaml # 共享mybatis配置<br>          - dataId: shared-swagger.yaml # 共享日志配置<br></code></pre></td></tr></table></figure></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>当我们在idea中修改了项目的配置的时候，一般都需要重启项目才能生效，但利用nacos可以做到热更新<br> 添加配置<br> <img src="https://pic.imgdb.cn/item/66ebf2a7f21886ccc0d3b104.png" alt=""><br>然后需要创建一个类用于接收配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.hmall.cart.config;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer maxAmount;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样maxAmount 就可以实时等于配置中的数据了</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由也一样，防止路由变化然后需要项目重启</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--统一配置管理--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--加载bootstrap--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="然后在网关gateway的resources目录创建bootstrap-yaml文件"><a href="#然后在网关gateway的resources目录创建bootstrap-yaml文件" class="headerlink" title="然后在网关gateway的resources目录创建bootstrap.yaml文件"></a>然后在网关gateway的resources目录创建bootstrap.yaml文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">spring:<br>  application:<br>    name: gateway<br>  cloud:<br>    nacos:<br>      server-addr: <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>      config:<br>        file-extension: yaml<br>        shared-configs:<br>          - dataId: shared-log.yaml # 共享日志配置<br>          - dataId: gateway-routes.json #这个需要根据自己定义的dataId<br></code></pre></td></tr></table></figure><h3 id="配置路由监听器"><a href="#配置路由监听器" class="headerlink" title="配置路由监听器"></a>配置路由监听器</h3><p>因为我们需要先监听路由是否变化，如果路由没有变化，就不用去更新路由;<br> RouteDefinitionWriter接口是由nacos提供的Bean，导入nacos的依赖就可以注入，作用是更新和删除路由。但不能批量<br>NacosConfigManager也是由nacos提供的Bean,作用是与nacos建立联系，可以实时获取nacos里的配置，并监听是否发生变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterLoader</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RouteDefinitionWriter writer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NacosConfigManager nacosConfigManager;<br><br>    <span class="hljs-comment">// 路由配置文件的id和分组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gateway-routes.json&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;<br>    <span class="hljs-comment">// 保存更新过的路由id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; routeIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRouteConfigListener</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NacosException &#123;<br>        <span class="hljs-comment">// 1.注册监听器并首次拉取配置</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">configInfo</span> <span class="hljs-operator">=</span> nacosConfigManager.getConfigService()<br>                .getConfigAndSignListener(dataId, group, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <br>                    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//路由变化则触发</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;<br>                        updateConfigInfo(configInfo);<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-comment">// 2.首次启动时，更新一次配置</span><br>        updateConfigInfo(configInfo);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);<br>        <span class="hljs-comment">// 1.反序列化</span><br>        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);<br>        <span class="hljs-comment">// 2.更新前先清空旧路由</span><br>        <span class="hljs-comment">// 2.1.清除旧路由</span><br>        <span class="hljs-keyword">for</span> (String routeId : routeIds) &#123;<br>            writer.delete(Mono.just(routeId)).subscribe();<br>        &#125;<br>        routeIds.clear();<br>        <span class="hljs-comment">// 2.2.判断是否有新的路由要更新</span><br>        <span class="hljs-keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;<br>            <span class="hljs-comment">// 无新路由配置，直接结束</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 3.更新路由</span><br>        routeDefinitions.forEach(routeDefinition -&gt; &#123;<br>            <span class="hljs-comment">// 3.1.更新路由</span><br>            writer.save(Mono.just(routeDefinition)).subscribe();<br>            <span class="hljs-comment">// 3.2.记录路由id，方便将来删除</span><br>            routeIds.add(routeDefinition.getId());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="nacos添加路由"><a href="#nacos添加路由" class="headerlink" title="nacos添加路由"></a>nacos添加路由</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">[<br>    &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;item&quot;</span>,<br>        <span class="hljs-string">&quot;predicates&quot;</span>: [&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Path&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: &#123;<span class="hljs-string">&quot;_genkey_0&quot;</span>:<span class="hljs-string">&quot;/items/**&quot;</span>, <span class="hljs-string">&quot;_genkey_1&quot;</span>:<span class="hljs-string">&quot;/search/**&quot;</span>&#125;<br>        &#125;],<br>        <span class="hljs-string">&quot;filters&quot;</span>: [],<br>        <span class="hljs-string">&quot;uri&quot;</span>: <span class="hljs-string">&quot;lb://item-service&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;cart&quot;</span>,<br>        <span class="hljs-string">&quot;predicates&quot;</span>: [&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Path&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: &#123;<span class="hljs-string">&quot;_genkey_0&quot;</span>:<span class="hljs-string">&quot;/carts/**&quot;</span>&#125;<br>        &#125;],<br>        <span class="hljs-string">&quot;filters&quot;</span>: [],<br>        <span class="hljs-string">&quot;uri&quot;</span>: <span class="hljs-string">&quot;lb://cart-service&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>        <span class="hljs-string">&quot;predicates&quot;</span>: [&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Path&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: &#123;<span class="hljs-string">&quot;_genkey_0&quot;</span>:<span class="hljs-string">&quot;/users/**&quot;</span>, <span class="hljs-string">&quot;_genkey_1&quot;</span>:<span class="hljs-string">&quot;/addresses/**&quot;</span>&#125;<br>        &#125;],<br>        <span class="hljs-string">&quot;filters&quot;</span>: [],<br>        <span class="hljs-string">&quot;uri&quot;</span>: <span class="hljs-string">&quot;lb://user-service&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;trade&quot;</span>,<br>        <span class="hljs-string">&quot;predicates&quot;</span>: [&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Path&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: &#123;<span class="hljs-string">&quot;_genkey_0&quot;</span>:<span class="hljs-string">&quot;/orders/**&quot;</span>&#125;<br>        &#125;],<br>        <span class="hljs-string">&quot;filters&quot;</span>: [],<br>        <span class="hljs-string">&quot;uri&quot;</span>: <span class="hljs-string">&quot;lb://trade-service&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">&quot;pay&quot;</span>,<br>        <span class="hljs-string">&quot;predicates&quot;</span>: [&#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Path&quot;</span>,<br>            <span class="hljs-string">&quot;args&quot;</span>: &#123;<span class="hljs-string">&quot;_genkey_0&quot;</span>:<span class="hljs-string">&quot;/pay-orders/**&quot;</span>&#125;<br>        &#125;],<br>        <span class="hljs-string">&quot;filters&quot;</span>: [],<br>        <span class="hljs-string">&quot;uri&quot;</span>: <span class="hljs-string">&quot;lb://pay-service&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h1 id="微服务的雪崩问题"><a href="#微服务的雪崩问题" class="headerlink" title="微服务的雪崩问题"></a>微服务的雪崩问题</h1><p>微服务调用链路中的某个服务故障，引起整个链路中的所有的微服务都不可用。<br>简单来说就是蝴蝶效应，因为微服务之间是错用复杂的，如果一个微服务A故障，那么由于微服务B调用A，导致B也故障，微服务C调用B，结果导致C也故障了。以此类推就会可能发生微服务大面积雪崩</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel 是一款开源的微服务限流器，可以帮助我们解决微服务的雪崩问题</p><ul><li>初识Sentinel</li></ul><ol><li>官网下载Jar，并运行<br>端口号冲突，更改了一下端口号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java -Dserver.port=<span class="hljs-number">8090</span> -Dcsp.sentinel.dashboard.server=localhost:<span class="hljs-number">8090</span> -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br></code></pre></td></tr></table></figure>运行成功即可访问</li><li>添加依赖和配置<br>这些配置可以共享到nacos中以后更加方便<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--sentinel--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; <br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br><br><br>spring:<br>  cloud: <br>    sentinel:<br>      transport:<br>        dashboard: localhost:8090<br></code></pre></td></tr></table></figure></li><li>访问8090端口<br><img src="https://pic.imgdb.cn/item/66ed294af21886ccc0e9941d.png" alt=""><h2 id="sentinel-之线程隔离"><a href="#sentinel-之线程隔离" class="headerlink" title="sentinel 之线程隔离"></a>sentinel 之线程隔离</h2>一个微服务A中可能会调用多个微服务 B,C,D等，但是如果B微服务宕机等，会导致A调用B的线程也出问题，会占用微服务A的资源。当异常线程组都多，会影响到微服务A调用其他微服务。<br>所以sentinel会我们提供了线程隔离，例如给一个请求规定5个线程，当这个请求的线程达到5个，就不允许这个请求的线程再增加。这样就不会影响到其他线程<br><img src="https://pic.imgdb.cn/item/66eeb555f21886ccc056f5c5.jpg" alt=""><br>sentinel设置线程隔离很简单，再请求的流控中设置并发线程数即可<br><img src="https://pic.imgdb.cn/item/66eeb694f21886ccc058690d.png" alt=""><h2 id="sentinel-之线程熔断"><a href="#sentinel-之线程熔断" class="headerlink" title="sentinel 之线程熔断"></a>sentinel 之线程熔断</h2>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。<br>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口熔断。当商品服务接口恢复正常后，再允许调用。这其实就是断路器的工作模式了。</li></ol><p>Sentinel中的断路器不仅可以统计某个接口的慢请求比例，还可以统计异常请求比例。当这些比例超出阈值时，就会熔断该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。<br>断路器的工作状态切换有一个状态机来控制：<br><img src="https://pic.imgdb.cn/item/66efc8e5f21886ccc05c0878.png" alt=""><br>状态机包括三个状态：</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li>open：打开状态，服务调用被熔断，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态<br><img src="https://pic.imgdb.cn/item/66efc946f21886ccc05c6653.png" alt=""><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1>首先我们以前在单体架构中实现事务的同成功同失败是需要在方法上添加@Transactional注解实现的；<br>但是这个方法已经对微服务不适用了，我们先来看一个业务流程<br><img src="https://pic.imgdb.cn/item/66efd045f21886ccc0639203.png" alt=""><br>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</li></ul></li><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务<br>这些分开的交易，购物车，库存 被称为分支事务，组合在一起被称为全局事务，分布式事务需要保证全局事务同成功同失败<h2 id="认识Seata"><a href="#认识Seata" class="headerlink" title="认识Seata"></a>认识Seata</h2>解决分布式事务的思路：分布式事务的主要问题是分支事务都可以保证自己事务的同成功同失败，但是分支事务之间不知道对方是否成功或失败，<br>所以就需要找到一个事务协调者，帮忙记录下每个分支事务的结果</li></ul><ol><li>Seata的架构图<br>在Seata的事务管理中有三个重要的角色：</li></ol><ul><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。 </li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li><li>RM (Resource Manager) - 资源管理器：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<br><img src="https://pic.imgdb.cn/item/66efd20cf21886ccc0656212.png" alt=""><br>个人理解呢：TC既是事务协调者记录每个分支事务结果，当一个业务中所有分支事务结束后判断是否需要回滚。<pre><code>    但是TC并不知道这个业务的最后一个分支事务是哪个，中间也由可能有其他业务的分支事务，所以TM出现了，    TM定义了一个业务的开始和结束，当TM开始的时候，TC会接收信号然后记录分支事务的结果，当TM结束后，TC也会结束这个业务的事务    RM即是每个分支事务结束后会通过RM向TC传入自己分支事务的状态和结果。    个人觉得RM中还会带有TM的标识，TC根据标识可以分辨出这个事务是否属于TM，这样可以多个全局事务一起执行</code></pre><h3 id="部署Seata"><a href="#部署Seata" class="headerlink" title="部署Seata"></a>部署Seata</h3></li></ul><ol><li>准备Seata的数据库<br>具体sql语句可以查询Seata的官方文档有给出<br><img src="https://pic.imgdb.cn/item/66efd4dbf21886ccc0682856.png" alt=""></li><li>在Docker上部署Seata<ul><li>准备好seata的配置文件application.yml上传到虚拟机中<br>配置文件官网中也有，也可以之下在seata的镜像文件，然后修改</li><li>启动容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []"> docker run --name seata \<br>-p 8099:8099 \<br>-p 7099:7099 \<br>-e SEATA_IP=192.168.150.101 \<br>-v ./seata:/seata-server/resources \<br>--privileged=true \<br>--network hm-net \<br>-d \<br>seataio/seata-server:1.5.2<br></code></pre></td></tr></table></figure>这里我出现了报错，docker ps -a 查看后发现状态码为139，<br>查看日志发现报错是<br><img src="https://pic.imgdb.cn/item/66efe7f0f21886ccc07a89a4.png" alt=""><br>查询了半天后需要添加一项命令在run命令后<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []">  docker run --name seata \<br>-p 8099:8099 \<br>-p 7099:7099 \<br>-e SEATA_IP=192.168.150.101 \<br>-v ./seata:/seata-server/resources \<br>--privileged=true \<br>--network hm-net \<br>-d --ulimit nofile=1024:1024 \<br>seataio/seata-server:1.5.2<br></code></pre></td></tr></table></figure></li></ul></li><li>启动成功<br><img src="https://pic.imgdb.cn/item/66efe861f21886ccc07aebce.png" alt=""><h3 id="微服务整合seata"><a href="#微服务整合seata" class="headerlink" title="微服务整合seata"></a>微服务整合seata</h3></li><li>添加相关依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--统一配置管理--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br>  &lt;!--读取bootstrap文件--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br>  &lt;!--seata--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>seata的配置添加到nacos上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址<br>    type: nacos # 注册中心类型 nacos<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br>      namespace: &quot;&quot; # namespace，默认为空<br>      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP<br>      application: seata-server # seata服务名称<br>      username: nacos<br>      password: nacos<br>  tx-service-group: hmall # 事务组名称<br>  service:<br>    vgroup-mapping: # 事务组与tc集群的映射关系<br>      hmall: &quot;default&quot;<br></code></pre></td></tr></table></figure></li><li>在bootstrap.yaml文件中添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: trade-service # 服务名称<br>  profiles:<br>    active: dev<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128 # nacos地址<br>      config:<br>        file-extension: yaml # 文件后缀名<br>        shared-configs: # 共享配置<br>          - dataId: shared-jdbc.yaml # 共享mybatis配置<br>          - dataId: shared-log.yaml # 共享日志配置<br>          - dataId: shared-swagger.yaml # 共享日志配置<br>          - dataId: shared-seata.yaml # 共享seata配置<br></code></pre></td></tr></table></figure>之后就可以启动服务啦，不过这里记录一下JDK21我启动遇见的问题<br><img src="https://pic.imgdb.cn/item/66efff7cf21886ccc0937a79.png" alt=""><br>解决方法JVM启动添加—add-opens=java.base/java.lang=ALL-UNNAMED<br><img src="https://pic.imgdb.cn/item/66efffcaf21886ccc093e689.png" alt=""><br>百度了一下：—add-opens选项是Java 9引入的一个命令行选项，用于打开模块之间的包，以便其他模块可以访问这些包中的类和成员。通过使用—add-opens选项，我们可以解决由于模块的隔离性而导致的访问限制问题</li></ol><h2 id="Seata之XA模式"><a href="#Seata之XA模式" class="headerlink" title="Seata之XA模式"></a>Seata之XA模式</h2><p>XA模式比较依赖关系型数据库，XA模式和上面提到的Seata架构的执行顺序基本相同，不过XA模式的特点是当分支事务执行完后并不会提交事务，而是当所有分支事务都执行完后，TC端如果记录的执行状态全部成功，则所有分支事务一起提交事务，如有有一个执行失败，则TC通知所有分支事务全部回滚。以这样的方式保证了数据的强一致性。但是也消耗性能。因为分支事务再执行完后并不会提交事务，所以分支事务会占着数据库该表的锁，mysql数据库的锁又是排他锁，所以如果这个分支事务不提交事务，就无法释放锁，其他业务也就没办法操作数据库<br><img src="https://pic.imgdb.cn/item/66f11769f21886ccc08bd838.png" alt=""><br>RM一阶段的工作：</p><ol><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ol><p>TC二阶段的工作：</p><ol><li>TC检测各分支事务执行状态<ol><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务 </li></ol></li></ol><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务<h3 id="XA的实现"><a href="#XA的实现" class="headerlink" title="XA的实现"></a>XA的实现</h3></li></ul><ol><li>在Seata的yaml文件中指定XA模式（可以在nacos中添加）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  data-source-proxy-mode: XA<br></code></pre></td></tr></table></figure></li><li>添加全局事务注解<br>在需要的方法上添加@GlobalTransactional(rollbackFor = Exception.class)即可</li></ol><h2 id="Seata之AT模式"><a href="#Seata之AT模式" class="headerlink" title="Seata之AT模式"></a>Seata之AT模式</h2><p>AT模式相比与XA模式提升了性能,在AT模式的架构图中可以看出，AT模式提升性能的主要原因是分支事务在执行完后会直接提交事务，而不是等待其他分支执行完。所以AT模式明显提升了性能。但是由于分支事务执行完后就会直接提交事务，如果当另一个分支事务执行失败时，已经提交完事务的分支事务就无法进行回滚，AT模式显然也考虑到这点，所以使用了快照的方法（其实就是备份）快照会记录分支事务执行前的数据，如果有分支事务失败了，那么就会通过快照进行数据还原，如果所有事务都成功了，则会清楚快照<br><img src="https://pic.imgdb.cn/item/66f11aeaf21886ccc08f391f.png" alt=""><br>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态<br>阶段二提交时RM的工作：</li><li>删除undo-log即可<br>阶段二回滚时RM的工作：</li><li>根据undo-log恢复数据到更新前<br>流程图：<br><img src="https://pic.imgdb.cn/item/66f11c46f21886ccc0905373.png" alt=""><br>注意！！AT模式会有短暂的数据不一致的情况</li></ul><h3 id="AT的实现"><a href="#AT的实现" class="headerlink" title="AT的实现"></a>AT的实现</h3><ol><li>由于需要快照，所以每一个微服务都需要一张单独的表存储快照<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs []">CREATE TABLE IF NOT EXISTS `undo_log`<br>(<br>    `branch_id`     BIGINT       NOT NULL COMMENT &#x27;branch transaction id&#x27;,<br>    `xid`           VARCHAR(128) NOT NULL COMMENT &#x27;global transaction id&#x27;,<br>    `context`       VARCHAR(128) NOT NULL COMMENT &#x27;undo_log context,such as serialization&#x27;,<br>    `rollback_info` LONGBLOB     NOT NULL COMMENT &#x27;rollback info&#x27;,<br>    `log_status`    INT(11)      NOT NULL COMMENT &#x27;0:normal status,1:defense status&#x27;,<br>    `log_created`   DATETIME(6)  NOT NULL COMMENT &#x27;create datetime&#x27;,<br>    `log_modified`  DATETIME(6)  NOT NULL COMMENT &#x27;modify datetime&#x27;,<br>    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;AT transaction mode undo table&#x27;;<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66f11d77f21886ccc0917f52.png" alt=""></li><li>在Seata的yaml文件中指定XA模式（可以在nacos中添加）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  data-source-proxy-mode: AT<br></code></pre></td></tr></table></figure><h1 id="RequiredArgsConstructor注解"><a href="#RequiredArgsConstructor注解" class="headerlink" title="@RequiredArgsConstructor注解"></a>@RequiredArgsConstructor注解</h1>该注解可以是Lombok所提供的，其主要的作用是简化@Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</li></ol><p>其底层原理是为final的字段生成构造参数</p>]]></content>
    
    
    <summary type="html">与微服务的初相遇</summary>
    
    
    
    <category term="springcloud" scheme="http://example.com/categories/springcloud/"/>
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="http://example.com/2024/09/07/vue3/"/>
    <id>http://example.com/2024/09/07/vue3/</id>
    <published>2024-09-07T09:53:12.890Z</published>
    <updated>2024-11-13T10:50:48.410Z</updated>
    
    <content type="html"><![CDATA[<p>什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧</p><h1 id="vue3概要"><a href="#vue3概要" class="headerlink" title="vue3概要"></a>vue3概要</h1><p>Vue是一套前端框架，用于简化JavaScript中的DOM操作，简化书写。</p><p>在之前我们也学习过后端的框架MyBatis，MyBatis是用来简化JDBC代码编写的；而Vue是前端框架，简化JavaScript代码编写的</p><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><ol><li>vue3的使用前提需要下载安装好node.js版本要在15.0以上</li><li>在命令窗中输入 npm init vue@laste 即可创建一个初始的vue文件夹</li><li>hello vue<br>值得一提的是每个绑定仅支持单一的js表达式，如{ {n+1} },页面会显示11，{ {ok?yes:no} }，页面会显示ok<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;p&gt;&#123; &#123;meg&#125; &#125;&lt;/p&gt;<br>  &lt;p&gt;&#123; &#123;n+1&#125; &#125;&lt;/p&gt;<br>  &lt;p&gt;&#123; &#123;ok?yes:no &#125; &#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;hello jsp&quot;,<br>          n:10,<br>          ok:true<br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2>v-bind可以简写为 ：<br>v-bind的作用的：可以为元素绑定vue属性<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p v-bind:class=&quot;meg&quot;&gt;测试&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;active&quot;<br><br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66e3a4dad9c307b7e92ffdef.png" alt=""><br>可以在控制台看到 测试的class属性已经绑定成了active</li></ol><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>用于条件判断是否展示元素</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>当meg为true时显示，为false不显示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p v-if=&quot;meg&quot;&gt;这是meg为true&lt;/p&gt;<br>    &lt;p v-else&gt;为false &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;true&quot;<br><br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66e3a631d9c307b7e9316d28.png" alt=""></p><p>多条件语句<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p v-if=&quot;meg === &#x27;A&#x27;&quot;&gt;A&lt;/p&gt;<br>    &lt;p v-else-if=&quot;meg === &#x27;B&#x27;&quot;&gt;B&lt;/p&gt;<br>    &lt;p v-else&gt;D&lt;/p&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>               meg:&quot;B&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br>&lt;style&gt;<br>html&#123;<br>font-size:16px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><br>页面显示B</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>事件处理，用来监听DOM事件，并在事件触发时执行对应的JS语句 ，v-on可简写为@</p><h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><p>每点击一次Add就会触发add()方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>        &lt;button @click=&quot;add&quot;&gt;Add&lt;/button&gt;<br>        &lt;p&gt;&#123; &#123; count &#125; &#125;&lt;/p&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            count:0,<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>       add()&#123;<br>        console.log(this.count)<br>        this.count++<br>       &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><h3 id="方法传参"><a href="#方法传参" class="headerlink" title="方法传参"></a>方法传参</h3><p>点击谁，会在控制台输出谁<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>        &lt;p  @click=&quot;name(item,$event)&quot; v-for=&quot;(item,index) in names&quot;:key=&quot;index&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/p&gt;<br>       <br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            names:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>      name(meg,e)&#123;<br>        console.log(meg)<br>        <br>       &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66ea83f4f21886ccc07e1937.png" alt=""></p><h2 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h2><h3 id="变更数据-可以直接使页面更新"><a href="#变更数据-可以直接使页面更新" class="headerlink" title="变更数据 可以直接使页面更新"></a>变更数据 可以直接使页面更新</h3><p><img src="https://pic.imgdb.cn/item/66ea8741f21886ccc081247d.jpg" alt=""><br>代码案例：点击添加数据，会给meg数组增加一个数据sakura<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>    &lt;button v-on:click=&quot;ADD&quot;&gt;添加数据&lt;/button&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(item,index) in meg&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ADD()&#123;<br>            this.meg.push(&quot;sakura&quot;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击前<br><img src="https://pic.imgdb.cn/item/66ea88fbf21886ccc083ae62.png" alt=""><br>点击后<br><img src="https://pic.imgdb.cn/item/66ea896ef21886ccc0851e99.png" alt=""> </p><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>这个方法不会使前端直接展示<br><img src="https://pic.imgdb.cn/item/66ea89bdf21886ccc0860f13.jpg" alt=""><br>代码案例：点击添加数据，会给meg数组增加一个数据sakura<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>    &lt;button v-on:click=&quot;ADD&quot;&gt;添加数据&lt;/button&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(item,index) in meg&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ADD()&#123;<br>           this.meg.concat([&quot;sakura&quot;])<br>            console.log(this.meg.concat([&quot;sakura&quot;]))<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击后 可以看到页面并没有展示出新添加的数据，但是在控制台可以输出可以看到<br><img src="https://pic.imgdb.cn/item/66ea8ac6f21886ccc089b6fd.png" alt=""></p><p>原因：因为这个方法是新建了一个数组，在原本的数组数据基础上添加新数据，所以将新数据赋值给原本的数组即可<br>将  this.meg.concat([“sakura”]) 改成 this.meg= this.meg.concat([“sakura”]) 即可</p><p>点击后<br><img src="https://pic.imgdb.cn/item/66ea896ef21886ccc0851e99.png" alt=""> </p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>用来监听响应式数据变化，当监听数据变化时可执行一个函数<br>代码示例：meg默认值为hello,当点击按钮时meg的值改为world,watch监听到数据变化时会执行将新数据和老数据打印到控制台的函数<br>注意！！ watch里的函数名称必须与响应式数据名称一样<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>    &lt;button @click=&quot;ischange&quot;&gt;改变数据&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:&quot;hello&quot;<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ischange()&#123;<br>            this.meg=&quot;world&quot;<br>        &#125;<br>    &#125;,<br>    watch:&#123;<br>        meg(newValue,oldValue)&#123;<br>            console.log(newValue,oldValue)<br>        &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66eb99b7f21886ccc07c7b02.png" alt=""></p><div class="note green icon-padding flat"><i class="note-icon fas fa-fan"></i><p>watch 是一个浅度监听，例如watch监听的是一个响应式对象，那么这个对象的属性变化，watch是监听不到的，解决方法有两种，</p><ol><li>在watch的监听方法中指定监听对象的具体属性（下面例子中注释的部分）</li><li>在watch监听方法的末尾添加deep:true,immediate:true；<ul><li>deep:true 是开启深度监听，这样就可以监听到对象的所有属性</li><li>immediate:true 原本watch只有在数据变化时才会监听，开启这个则会立即监听</li></ul></li></ol></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">econst person = ref(&#123;name:&quot;张三”<br>                        age:23<br>&#125;);<br>/*<br> watch(()=&gt;person.value.name,(newValue)=&gt;&#123;<br>console.log(newValue);<br> &#125;)<br> */<br>watch(person,(newValue)=&gt;&#123;<br>console.log(newValue); &#125;,&#123;deep:true,immediate:true&#125;)<br></code></pre></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>进行表单数据双向绑定<br>代码实例：输入框中输入的数据会实时显示在下方<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>   &lt;input type=&quot;text&quot; v-model=&quot;meg&quot;&gt;<br>   &lt;p&gt;实时输入的是&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>                meg:&quot;&quot;,<br>                a: &quot;&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66ebc6bef21886ccc0a5b3b8.png" alt=""></p><h3 id="v-model-lazy"><a href="#v-model-lazy" class="headerlink" title="v-model.lazy"></a>v-model.lazy</h3><p>不加lazy 每输入一个数据都会实时绑定<br>加上lazy 全部输入完数据才会进行绑定</p><h3 id="v-model-number"><a href="#v-model-number" class="headerlink" title="v-model.number"></a>v-model.number</h3><p>只有输入的数字才会进行绑定</p><h3 id="v-moder-trim"><a href="#v-moder-trim" class="headerlink" title="v-moder.trim"></a>v-moder.trim</h3><p>删除数据的前后空格在绑定</p><h1 id="引用组件"><a href="#引用组件" class="headerlink" title="引用组件"></a>引用组件</h1><h2 id="局部引用组件"><a href="#局部引用组件" class="headerlink" title="局部引用组件"></a>局部引用组件</h2><p><img src="https://pic.imgdb.cn/item/66ecd47ef21886ccc088d3e9.jpg" alt=""></p><h2 id="全局引入组件"><a href="#全局引入组件" class="headerlink" title="全局引入组件"></a>全局引入组件</h2><p><img src="https://pic.imgdb.cn/item/66ecd4c1f21886ccc08902a4.jpg" alt=""></p><h1 id="组件传递数据"><a href="#组件传递数据" class="headerlink" title="组件传递数据"></a>组件传递数据</h1><h2 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h2><h3 id="vue2-父传子-Props"><a href="#vue2-父传子-Props" class="headerlink" title="vue2 父传子 Props"></a>vue2 父传子 Props</h3><p>父组件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;p&gt;父传子&lt;/p&gt;<br>&lt;Props1 :meg=&quot;meg&quot;  :num=&quot;num&quot; :zu=&quot;zu&quot;/&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Props1 from &#x27;./Props1.vue&#x27;;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:&quot;这是Props传的字符串数据&quot;,<br>            num: 20,<br>            zu:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]<br>        &#125;<br>    &#125;,<br>    components:&#123;<br>        Props1<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>子组件接收<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;Props1打印传递的数据&lt;/p&gt;<br>   &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>   &lt;p&gt;&#123; &#123; num &#125; &#125;&lt;/p&gt;<br>   &lt;p v-for=&quot;item in zu&quot;&gt; &#123; &#123; item &#125; &#125;&lt;/p&gt;<br>    &lt;/template&gt;<br>    <br>    &lt;script&gt;<br>    import Props1 from &#x27;./Props1.vue&#x27;;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>            &#125;<br>        &#125;,<br>        props:[&quot;meg&quot;,&quot;num&quot;,&quot;zu&quot;]<br>    &#125;<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><br>结果<br><img src="https://pic.imgdb.cn/item/66ee2ce1f21886ccc0c94ab2.png" alt=""><br>这是局部引用组件，被引用的组件是子组件，子组件接收数据要用props；<br>props可以接收任何形式的数据</p><h3 id="vue3-父传子传递数据"><a href="#vue3-父传子传递数据" class="headerlink" title="vue3 父传子传递数据"></a>vue3 父传子传递数据</h3><p>defineProps 是 Vue 3 中新引入的函数，用于定义子组件的 props。</p><ol><li>在子组件中定义props<br>这是一个子组件(department-index)中定义的props<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">const props = defineProps(&#123;<br>  id: &#123;<br>    type: String,<br>    required: true<br>  &#125;,<br>  isdetail:&#123;<br>    type:Boolean,<br>    required: false<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li>父组件中给子组件props传值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;el-tab-pane label=&quot;项目完成单位&quot; name=&quot;department&quot;&gt;<br>  &lt;department-index  :isdetail=&quot;true&quot; :id=&quot;props.id&quot; /&gt;<br>&lt;/el-tab-pane&gt;<br></code></pre></td></tr></table></figure>总结<br>defineProps 是 Vue 3 中一个非常强大的特性，它提供了一种更加明确和类型安全的方式来定义子组件的 props。通过使用 defineProps，我们可以让子父组件之间的数据传递更加清晰和可维护，同时也提高了代码的健壮性<h2 id="子接收数据校验"><a href="#子接收数据校验" class="headerlink" title="子接收数据校验"></a>子接收数据校验</h2>子组件可以规定接收数据的类型，如果父组件传递的类型不是子组件规定的，会报警告<br>利用props中的type<br><img src="https://pic.imgdb.cn/item/66ee2e4ff21886ccc0ca8d10.jpg" alt=""><h2 id="子传父（传的是函数）"><a href="#子传父（传的是函数）" class="headerlink" title="子传父（传的是函数）"></a>子传父（传的是函数）</h2><h3 id="vue2子传父-this-emit"><a href="#vue2子传父-this-emit" class="headerlink" title="vue2子传父 this.$emit"></a>vue2子传父 this.$emit</h3>子传父利用this.$emit，其实原理是回调父组件的函数<br>先看子组件,子组件利用this.$emit，向父组件传递了一个函数名，和一个新数据<br><img src="https://pic.imgdb.cn/item/66ef879ef21886ccc01c203f.jpg" alt=""><br>父组件用v-on绑定了子组件传过来的函数名和数据，并再methods中实现了。<br><img src="https://pic.imgdb.cn/item/66ef8838f21886ccc01cbc31.jpg" alt=""><br>最后效果<br><img src="https://pic.imgdb.cn/item/66ef88c3f21886ccc01d7994.jpg" alt=""><h3 id="vue3-defineEmits"><a href="#vue3-defineEmits" class="headerlink" title="vue3 defineEmits"></a>vue3 defineEmits</h3><div class="note primary flat"><p>defineEmits 函数返回的是一个函数，而不是一个对象或数组。因此，不能直接修改它返回的事件列表<br>你可以使用 defineEmits 来定义多个事件，只需将它们作为字符串数组传递给 defineEmits 即可。例如：defineEmits([‘event1’, ‘event2’])。<br>在子组件中触发事件时，你可以传递任意数量的参数给事件监听器。这些参数将在父组件的事件处理函数中作为参数接收。<br>如果你不使用 defineEmits 来定义事件，Vue 仍然会正常工作，但使用 defineEmits 可以提供更好的类型检查和代码提示</p></div></li></ol><p>看一个案例 分别有三个文件 base.vue  edit.vue  index.vue</p><ol><li>子组件 base.vue<br>其中定义了两个个自定义事件refreshData，closeEdit ，然后在执行 submitHandle函数的时候会 触发emit(‘refreshData’)这个事件<div class="note primary flat"><p>这里的自定义事件可以只是一个名字<br>emit(‘refreshData’)可以携带参数例如 emit(‘refreshData’, ‘1’)</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs []">//自定义事件<br>const emit = defineEmits([&#x27;refreshData&#x27;, &#x27;closeEdit&#x27;])<br>// 表单提交<br>const submitHandle = () =&gt; &#123;<br>  dataFormRef.value!.validate((valid: boolean) =&gt; &#123;<br>    if (!valid) &#123;<br>      return<br>    &#125;<br><br>    let data = Object.assign(&#123;&#125;, dataForm)<br>    useProjectUpdateApi(data).then(() =&gt; &#123;<br>      ElMessage.success(&#123;<br>        message: &#x27;操作成功&#x27;,<br>        duration: 500,<br>        onClose: () =&gt; &#123;<br>          //visible.value = false<br>          emit(&#x27;refreshData&#x27;)<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>base.vue的父组件 edit.vue<br>在edit.vue中 使用了base.vue组件 并用v-on监听了refreshData事件（@refresh-data=”handleRefresh”），所以当refreshData事件被触发时<br>edit.vue组件会监听到，然后执行handleRefresh函数，可以看到edit组件自己也自定义了两个事件，并在handleRefresh函数中触发了自己的refreshData事件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs []"> &lt;base-edit v-if=&quot;activeName === &#x27;base&#x27;&quot; :id=&quot;props.id&quot; @refresh-data=&quot;handleRefresh&quot; /&gt;<br><br><br>  const emit = defineEmits([&#x27;refreshData&#x27;, &#x27;closeEdit&#x27;])<br> const handleRefresh = () =&gt; &#123;<br>  emit(&#x27;refreshData&#x27;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>edit.vue的父组件index.vue<br>当edit中的refreshData事件被触发时，index.vue会监听到并执行getDataList函数，<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;edit ref=&quot;editRef&quot; :id=&quot;editId&quot; @refresh-data=&quot;getDataList&quot;&gt;&lt;/edit&gt;<br></code></pre></td></tr></table></figure><h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1>多个组件之间来回切换,需要用到 <component :is=""></component><br>简单实例：创建3个组件A,B,C;默认在C组件中展示A，当点击按钮后切换成B<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;组件A&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;组件B&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;component :is=&quot;change&quot;&gt;&lt;/component&gt;<br>    &lt;button @click=&quot;changeHandle&quot;&gt;切换组件&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import A from &#x27;@/components/A.vue&#x27;<br>import B from &#x27;@/components/B.vue&#x27;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            change: &quot;A&quot;<br>        &#125;<br>    &#125;,<br>    components:&#123;<br>        A,<br>        B<br>    &#125;,<br>    methods:&#123;<br>        changeHandle()&#123;<br>            this.change=this.change== &quot;A&quot;?&quot;B&quot;:&quot;A&quot;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>点击前<br><img src="https://pic.imgdb.cn/item/66f22aeaf21886ccc06a4931.png" alt=""><br>点击后<br><img src="https://pic.imgdb.cn/item/66f22b0bf21886ccc06a5fd9.png" alt=""></li></ol><h2 id="组件存活"><a href="#组件存活" class="headerlink" title="组件存活"></a>组件存活</h2><p>使用 <component :is=""></component> 后，切换组件，原来的组件就会被销毁，如果再次切换到原来的组件，只是重新加载了这个组件的生命周期<br>例如 将A更改一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;组件A&lt;/p&gt;<br>    &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>    &lt;button @click=&quot;change&quot;&gt;更新数据&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg: &quot;老数据&quot;<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        change()&#123;<br>            this.meg=this.meg==&quot;老数据&quot;?&quot;新数据&quot;:&quot;老数据&quot;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>再来看点击前<br><img src="https://pic.imgdb.cn/item/66f22c61f21886ccc06b667e.png" alt=""><br>先点击更新数据,会展示新数据<br><img src="https://pic.imgdb.cn/item/66f22ccbf21886ccc06bb228.png" alt=""><br>然后在点击两次切换组件 让他切换到A<br><img src="https://pic.imgdb.cn/item/66f22d07f21886ccc06be4c6.png" alt=""><br>会发现组件A的数据变成了老数据，说明组件A在被切换后被销毁了，再次切换回来只是重新加载了一边生命周期<br>如果需要组件存活 需要用到<keep-alive><br><img src="https://pic.imgdb.cn/item/66f22dbbf21886ccc06c71c4.png" alt=""><br>这样就可以了</p><h1 id="axios发起请求"><a href="#axios发起请求" class="headerlink" title="axios发起请求"></a>axios发起请求</h1><p>axios用于前端发送请求到后端</p><ul><li>安装 axios的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">import axios from &#x27;axios&#x27;;<br></code></pre></td></tr></table></figure>baseURL用来记录转发的目的地路径，可以是具体路径192.168.217.168等，这里写的是api因为会发生跨域<br>instance = axios.create({baseURL})是创造一个axios的实例，实例会有很多功能如图<br><img src="https://pic.imgdb.cn/item/66f3c86bf21886ccc0c266af.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f3c829f21886ccc0c20e4c.png" alt=""><br>简单使用：我这里使用的request是因为 axios的导入和URL，instance都是在request中的，所以方便一些<br><img src="https://pic.imgdb.cn/item/66f3c930f21886ccc0c35c53.png" alt=""></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域指挥发生在浏览器中，浏览器不能将前端5173端口的请求转发到另一个端口上，但是可以又5173前端端口转发到后端<br>所以axios的URL不建议直接写后端的端口地址，会发生跨域问题<br><img src="https://pic.imgdb.cn/item/66f3c9f8f21886ccc0c42164.jpg" alt=""><br>解决：</p><ul><li>使用代理模式<br>指定URL 例如api,这样前端会把请求发送到前端 5173/api的接口中，然后利用代理，会将地址改变<br>target ：改变的api前面的路径端口等<br>changeOrigin : 是否开启代理<br>rewrite : 可以将api替换成空格<br>最后结果 http：//local host：5173/api 会代理成 http：//local host：8080/<br><img src="https://pic.imgdb.cn/item/66f3caaaf21886ccc0c4d5ea.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/66f3cbccf21886ccc0c5ca6b.jpg" alt=""></li></ul><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由帮助我们跳转页面 例如点击登录后跳转到主页面</p><ol><li>安装<br>执行命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">npm install vue-router@latest<br></code></pre></td></tr></table></figure></li><li>创造路由并导入<br>可以看到我们新建了router文件夹下面的index.js<br><img src="https://pic.imgdb.cn/item/66f3d105f21886ccc0ca45bb.png" alt=""></li></ol><ul><li>首先导入vue-router,和导入组件</li><li>需要定义路由关系</li><li>创建路由，并把路由关系指定给路由</li><li>导出路由<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">//导入vue-router<br>import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;<br>//导入组件<br>import LoginVue from &#x27;@/views/Login.vue&#x27;<br>import LayoutVue from &#x27;@/views/Layout.vue&#x27;<br><br>//定义路由关系<br>const routes = [<br>    &#123; path: &#x27;/login&#x27;, component: LoginVue &#125;,<br>    &#123; path: &#x27;/&#x27;, component: LayoutVue &#125;<br>]<br><br>//创建路由器<br>const router = createRouter(&#123;<br>    history: createWebHistory(),<br>    routes: routes<br>&#125;);<br><br>export default router<br></code></pre></td></tr></table></figure></li></ul><ol><li>将路由配置全局<br>在main.js文件中导入路由并挂载<br><img src="https://pic.imgdb.cn/item/66f3d1cbf21886ccc0cb30f0.png" alt=""></li><li>在根组件中使用路由标签挂载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;router-view&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure></li><li>在需要跳转的函数或按钮中添加路由<br><img src="https://pic.imgdb.cn/item/66f3d250f21886ccc0cbade0.png" alt=""></li></ol><h2 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h2><p>子路由可以控制主页面都一部分的内容改变<br>例如：点击左侧，中间内容会改变<br><img src="https://pic.imgdb.cn/item/66f3d63df21886ccc0cee10d.png" alt=""></p><p>实现：</p><ol><li>配置路由关系<br>在原来的路由关系中，导入组件，并定义子路由关系<br><img src="https://pic.imgdb.cn/item/66f3d69af21886ccc0cf2726.png" alt=""></li><li>在分类菜单中加入对应的路由<br>index是因为路由关系在我的index.js文件夹中<br><img src="https://pic.imgdb.cn/item/66f3d6f8f21886ccc0cf780f.png" alt=""></li><li>在需要展示的页面中的中间部份用路由标签挂载</li></ol><h1 id="pinia-携带请求头"><a href="#pinia-携带请求头" class="headerlink" title="pinia 携带请求头"></a>pinia 携带请求头</h1><p>一般登录成功后后端会传来一个token,用来确定身份，登陆后其他请求也都需要token验证</p><ol><li>安装<br>执行命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">npm install pinia<br></code></pre></td></tr></table></figure></li><li>pinia导入全局<br><img src="https://pic.imgdb.cn/item/66f3dcd2f21886ccc0d61a2a.png" alt=""></li><li>定义store<br><img src="https://pic.imgdb.cn/item/66f3dd06f21886ccc0d648f6.png" alt=""></li><li>组件中使用store<br><img src="https://pic.imgdb.cn/item/66f3dd33f21886ccc0d69189.png" alt=""></li></ol><h1 id="基础知识补充"><a href="#基础知识补充" class="headerlink" title="基础知识补充"></a>基础知识补充</h1><h2 id="和"><a href="#和" class="headerlink" title="==和==="></a>==和===</h2><ol><li>== 号用于比较两边的值是否相等</li><li>=== 号不仅判断两边的值是否相同还需要判断两边的类型的是否相同<h2 id="default-”scope”-插槽"><a href="#default-”scope”-插槽" class="headerlink" title="#default=”scope” 插槽"></a>#default=”scope” 插槽</h2>实现功能：表格做判断<br>使用template中的作用域插槽，它的作用是在外部获取组件内的数据 ,这里是为了获取这一行的数据，我们让slot-scope值为scope，那么由scope.row就可以得到数据了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;el-table-column label=&quot;操作&quot; fixed=&quot;right&quot; header-align=&quot;center&quot; align=&quot;center&quot; width=&quot;160&quot;&gt;<br>         &lt;template #default=&quot;scope&quot;&gt;<br>           &lt;el-button v-if=&quot;scope.row.PId == 0&quot; v-auth=&quot;&#x27;projectscorekind:add&#x27;&quot; type=&quot;primary&quot; link @click=&quot;addOrUpdateHandle(false, state.dataList, scope.row)&quot;&gt;新增&lt;/el-button&gt;<br>           &lt;el-button v-auth=&quot;&#x27;projectscorekind:edit&#x27;&quot; type=&quot;primary&quot; link @click=&quot;addOrUpdateHandle(true, state.dataList, scope.row)&quot;&gt;修改&lt;/el-button&gt;<br>           &lt;el-button v-auth=&quot;&#x27;projectscorekind:delete&#x27;&quot; type=&quot;primary&quot; link @click=&quot;deleteHandle(scope.row.Id)&quot;&gt;删除&lt;/el-button&gt;<br>         &lt;/template&gt;<br>       &lt;/el-table-column&gt;<br></code></pre></td></tr></table></figure>利用了  v-if=”scope.row.PId == 0” 判断层数，第一层的Pid为0时显示增加按钮<br><img src="https://pic.imgdb.cn/item/672dbdbfd29ded1a8c149106.png" alt=""></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧&lt;/p&gt;
&lt;h1 id=&quot;vue3概要&quot;&gt;&lt;a href=&quot;#vue3概要&quot; class=&quot;headerlink&quot; title=&quot;vue3概要&quot;&gt;&lt;/a&gt;vue3概要&lt;/h1&gt;&lt;p&gt;Vue是一套前</summary>
      
    
    
    
    
    <category term="VUE3" scheme="http://example.com/tags/VUE3/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/"/>
    <id>http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/</id>
    <published>2024-09-07T07:10:34.612Z</published>
    <updated>2024-11-11T09:37:43.770Z</updated>
    
    <content type="html"><![CDATA[<p>每次学新东西，就想到当初选JAVA后端，我就想扇自己<br>一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了<br>虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦<br>为什么不能docker一键安装docker呢</p><h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>Docker是一款应用容器引擎，可以帮助我们快速部署和搭建<br>Docker需要在Linux环境下运行，所以需要虚拟机搭建环境</p><p>使用Docker的前提当然是搭建虚拟机了<br>具体安装虚拟机和Docker可看<a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d</a></p><h2 id="基于Docker安装mysql"><a href="#基于Docker安装mysql" class="headerlink" title="基于Docker安装mysql"></a>基于Docker安装mysql</h2><p>只需要一条命令即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []"> docker run -d \<br>&gt;   --name mysql \<br>&gt;    -p 3306:3306 \<br>&gt;    -e TZ=Asia/Shanghai \<br>&gt;    -e MYSQL_ROOT_PASSWORD=123456 \<br>&gt;    mysql<br></code></pre></td></tr></table></figure><br><img src="https://t.tutu.to/img/0mlwr" alt=""><br>以上就是Docker安装mysql，真是太简单了，我大一安装mysql可是一直出错，安装了一整天了<br>Docker安装部署这么容易是因为Docker下载的是已经部署好的mysql镜像，而且Docker运行这些镜像的时候<br>会创建一个隔离环境，称为容器。所以同时运行多个镜像也是可以的<br>正是因为如此Docker可以解决依赖兼容问题<br><img src="https://pic.imgdb.cn/item/639872ecb1fccdcd3695de9e.jpg" alt=""></p><h2 id="Docker的常见命令"><a href="#Docker的常见命令" class="headerlink" title="Docker的常见命令"></a>Docker的常见命令</h2><ol><li>docker run 创建并运行镜像</li><li>-d 让镜像在后台运行<br>如果不加 -d 镜像会在控制台执行，不能进行其他操作直到停止</li><li>-p 端口映射<br>因为我们的Docker是在Linux虚拟机上部署的，假设虚拟机的IP是192.168.150.101.<br>Docker运行镜像会创建单独的容器，其实这个容器也是有IP地址的，但是我们直接访问容器的IP会失败<br>所以会进行映射，通过访问虚拟机的IP端口映射到容器的IP端口<br><img src="https://t.tutu.to/img/0mtW6" alt=""></li><li>-e 设置环境变量 格式为 KEY=VALUE<br>具体的环境变量需要查看Docker的镜像官网</li><li>—name 设置镜像的名称</li><li>docker pull 从镜像仓库拉取镜像到本地仓库</li><li>docker images 查看本地镜像</li><li>docker rmi 删除本地镜像</li><li>docker push 将本地镜像推送到镜像仓库</li><li>docker stop 停止容器</li><li>docker start 启动容器</li><li>docker ps 查看容器运行状态</li><li>docker rm 删除容器</li><li>docker exec -it 容器名 bash 通过命令行操作容器</li></ol><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><ol><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录的之间映射的桥梁；<br>数据卷解决的问题：docker为我们下载的镜像文件只包含了该文件运行所需要的依赖环境，<br>所以如果我们通过docker exec -it 容器名 bash命令进入该容器去操作容器内文件时，<br>会发现容器内并没有 vi 等操作文件的命令，所以我们不能在容器里操作容器里的文件<br>因此数据卷可以为我们解决这个问题<br>解决的原理     ：数据卷可以进行双向映射，创建数据卷目录，然后分别对应容器中的目录和<br>虚拟机docker中的目录，映射成功后，通过操作虚拟机中的目录就可以达到操作容器目录的效果<br>数据卷对应的虚拟机目录一般都在volume目录下<br><img src="https://pic.imgdb.cn/item/66dd5deed9c307b7e9d22582.png" alt=""> <h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><img src="https://pic.imgdb.cn/item/66dd5f38d9c307b7e9d538f6.png" alt=""><h2 id="数据卷映射目录"><a href="#数据卷映射目录" class="headerlink" title="数据卷映射目录"></a>数据卷映射目录</h2>docker run -v 数据卷名（自定义）：容器目录</li><li>docker run 是创造并执行容器，所以如果一个容器已经被创造，但是没有挂载数据卷，即就不能挂载数据卷或者会自动挂载一个匿名卷</li><li>如果执行该命令的时候数据卷不存在，会自动创建，数据卷会和虚拟机volums目录下和数据卷同名的文件目录自动挂载，<h2 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h2>使用命令：docker run -v 本地目录（自定义）：容器目录</li><li>本地目录必须以 / 或者 ./开头</li><li>和数据卷挂载的区别：直接将本地目录 和容器目录挂载，本地目录不需要是在volume目录下<h3 id="本地挂载mysql"><a href="#本地挂载mysql" class="headerlink" title="本地挂载mysql"></a>本地挂载mysql</h3></li><li>创建对应的文件夹<br><img src="https://pic.imgdb.cn/item/66deb3c1d9c307b7e9dd1fc9.png" alt=""></li><li>将提前准备好的sql语句脚本和dockerfile文件导入mysql文件夹</li><li>运行命令<br>记得前提把上面示例创造的mysql容器删除，不然会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []">docker run -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=123 \<br>  -v ./mysql/data:/var/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  mysql<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66deb4b5d9c307b7e9de2474.png" alt=""><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3>镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。</li></ol><h3 id="docker镜像的结构"><a href="#docker镜像的结构" class="headerlink" title="docker镜像的结构"></a>docker镜像的结构</h3><ol><li>基础镜像是通用的，因为是分层结构，所以其他镜像也可以使用<br><img src="https://pic.imgdb.cn/item/66dd7842d9c307b7e9ff4976.png" alt=""></li><li>设置镜像结构 Dockerfile<br><img src="https://pic.imgdb.cn/item/66dd7934d9c307b7e901e387.png" alt=""><h3 id="尝试自定义镜像"><a href="#尝试自定义镜像" class="headerlink" title="尝试自定义镜像"></a>尝试自定义镜像</h3></li><li>编写Dockerfile<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []"># 基础镜像<br>FROM openjdk:11.0-jre-buster<br># 设定时区<br>ENV TZ=Asia/Shanghai<br>RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone<br># 拷贝jar包<br>COPY docker-demo.jar /app.jar<br># 入口<br>ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]<br></code></pre></td></tr></table></figure></li><li>将准备好的demo.jar和Dockerfile上传到虚拟机中</li><li>执行 docker build -t docker-demo .<br>-t :给镜像命名<br>. :表示当前路径，如果不在上传的demo文件下，需要指定demo的位置</li><li>执行 docker run -d —name dd -p 8080:8080 docker-dome<br><img src="https://pic.imgdb.cn/item/66dd7b60d9c307b7e90673d4.png" alt=""><br>如图成功，访问8080端口<br><img src="https://pic.imgdb.cn/item/66dd7bc7d9c307b7e906e7ab.png" alt=""></li></ol><h2 id="容器网络互联"><a href="#容器网络互联" class="headerlink" title="容器网络互联"></a>容器网络互联</h2><p>如果在创建容器的时候没有指定网段IP，docker会通过网桥自动分配给容器一个IP，但是容器关闭后，这个IP会被分配给其他容器<br><img src="https://pic.imgdb.cn/item/66deb600d9c307b7e9df983f.png" alt=""></p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>加入自定义网络的容器可以通过容器名互相访问<br><img src="https://pic.imgdb.cn/item/66deb669d9c307b7e9e00690.png" alt=""><br>创建自定义网络 hmall<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">docker network create hmall<br></code></pre></td></tr></table></figure><br>使mysql处于自定义网络中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">docker network connect hmall mysql<br></code></pre></td></tr></table></figure></p><h2 id="部署JAVA应用"><a href="#部署JAVA应用" class="headerlink" title="部署JAVA应用"></a>部署JAVA应用</h2><ol><li>对JAVA应用打包，将写好的dockerfile和jar导入虚拟机root目录下<br><img src="https://pic.imgdb.cn/item/66deba94d9c307b7e9e842f0.png" alt=""></li><li>构建镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">docker build -t hmall .<br></code></pre></td></tr></table></figure></li><li>创造运行容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">docker run -d --name hmall --network hmall -p 8080:8080 hmall<br></code></pre></td></tr></table></figure>本地浏览器访问<br><img src="https://pic.imgdb.cn/item/66debb41d9c307b7e9ea3f41.png" alt=""><h2 id="部署前端应用"><a href="#部署前端应用" class="headerlink" title="部署前端应用"></a>部署前端应用</h2>emmm~,这个最后一步一直报错 404，花了一下无，给我气红温了，就先跳过了<h2 id="一键部署DockerCompose"><a href="#一键部署DockerCompose" class="headerlink" title="一键部署DockerCompose"></a>一键部署DockerCompose</h2>DockerCompose是通过一个单独的YAML格式的文件来定义一组相关联的应用容器，帮<br>助我们实现多个相互关联的Docker容器的快速部署。<br>右边即是YAML格式的容器等同于左边<br><img src="https://pic.imgdb.cn/item/66def3b0d9c307b7e94885ac.png" alt=""><br><img src="https://pic.imgdb.cn/item/66def40ad9c307b7e949b63a.png" alt=""><br>将准备好的YAML文件传入虚拟机中，再执行 docker compose up 即可一键部署</li></ol><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>Docker并不作为JAVA后端的一个重点，再加上最近有些浮躁，很难静下心来，所以学的有点粗糙，<br>也想早点开启下一章微服务的学习<br>Docker就作为了解吧！</p>]]></content>
    
    
    <summary type="html">浅学docker</summary>
    
    
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MybatisPlus</title>
    <link href="http://example.com/2024/09/06/MybatisPlus/"/>
    <id>http://example.com/2024/09/06/MybatisPlus/</id>
    <published>2024-09-06T05:46:45.235Z</published>
    <updated>2024-11-11T09:36:35.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识MybatisPlus"><a href="#初识MybatisPlus" class="headerlink" title="初识MybatisPlus"></a>初识MybatisPlus</h1><p>MybatisPlus的特点</p><ol><li>可以对现有工程只做增强不做改变，引入MybatisPlus后Mybatis的代码依旧可以使用</li><li>方便快捷实现对单表的增删改查</li><li>功能丰富 例如 代码生成，自动分页，自动填充<h2 id="使用MybatisPlus"><a href="#使用MybatisPlus" class="headerlink" title="使用MybatisPlus"></a>使用MybatisPlus</h2></li><li>引入MybatisPlus<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;dependency&gt;<br>    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;<br>    &lt;version&gt;3.5.7&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>自定义的Mapper 继承MybatisPlus提供的BaseMapper<br> 注意：BaseMapper需要指定实体类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MybatisPlus的常用注解"><a href="#MybatisPlus的常用注解" class="headerlink" title="MybatisPlus的常用注解"></a>MybatisPlus的常用注解</h2></li><li>@TableName : 用于指定表名<br>当实体类名和数据库表名不一致的时候使用</li><li>@TableId :用于指定表中的主键字段信息<br>可以指定主键的憎长类型，共有三种，（AUTO）数据库自增长，(INPUT)get方式输入,（ASSIGN_ID）自带的雪花算法<br>若不指定则默认为yaml配置的方式</li><li>@TableFieId :用于指定表中的普通字段信息<br>直接上图<br><img src="https://www.helloimg.com/i/2024/09/04/66d81e5d52204.png" alt=""></li></ol><h2 id="MybatisPlus的配置"><a href="#MybatisPlus的配置" class="headerlink" title="MybatisPlus的配置"></a>MybatisPlus的配置</h2><p><img src="https://www.helloimg.com/i/2024/09/04/66d820a887981.png" alt=""></p><h1 id="MybatisPlus的条件构造器"><a href="#MybatisPlus的条件构造器" class="headerlink" title="MybatisPlus的条件构造器"></a>MybatisPlus的条件构造器</h1><p>MybatisPlus提供了三种条件构造器</p><ol><li>QueryWrapper<br>提供了很多关于查询的条件方法,方法很多就不一一展示了，通过一个示例简单说明一下<br><img src="https://www.helloimg.com/i/2024/09/04/66d826f608f60.png" alt=""><br>将图中sql可简化为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">QueryWrapper queryWrapper = new QueryWrapper&lt;User&gt;()<br>             .select(&quot;id&quot;,&quot;username&quot;,&quot;info&quot;,&quot;balance&quot;).like(&quot;username&quot;,&quot;o&quot;)<br>             .gt(&quot;blance&quot;,1000);<br><br>      List&lt;User&gt; list = userMapper.selectList(queryWrapper);<br></code></pre></td></tr></table></figure></li><li>UpdateWrapper<br>提供了更新的条件方法<br><img src="https://www.helloimg.com/i/2024/09/04/66d82981d5053.png" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs []">UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;()<br>             .setSql(&quot;balance =balance - 200&quot;).in(&quot;id&quot;,&quot;1,2,4&quot;);<br><br>     userMapper.update(null,updateWrapper);<br></code></pre></td></tr></table></figure><img src="https://www.helloimg.com/i/2024/09/04/66d8262a6963d.png" alt=""></li></ol><h1 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h1><p><img src="https://www.helloimg.com/i/2024/09/05/66d966d0eb1d4.png" alt=""><br>MybatisPuls提供了IService接口更帮助我们实现对单表的增删改查<br>使用IService接口需要两步</p><ol><li>自定义的XXXService接口去继承Iservice接口</li><li>XXXService的实现类XXXServiceImpl实现Service的同时也要继承IService的实现类<br>注意！！ XXXServiceImpl继承IService的实现类的时候需要给IService的实现类两个参数</li><li>第一个参数所对应的Mapper接口，因为在IService的实现类里面是需要引入对应的mapper<br> 即IService里面很多方法底层还是通过MybatisPuls提供的Mapper的方法实现</li><li>第二个参数为对应的实体对象<br>例如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">public interface UserService extends IService&lt;User&gt;&#123;<br><br>&#125;<br><br>@Service<br>public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IService的应用"><a href="#IService的应用" class="headerlink" title="IService的应用"></a>IService的应用</h2>IService提供更多的方法供我们使用，同样这么多方法也就不一一介绍了<br>值得一提的是IService提供的批量插入方法saveBeach方法<br>假设我们需要像数据库中插入10000条数据</li><li>单条数据插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs []">public void test1() &#123;<br>        long a =System.currentTimeMillis();<br>        for (int i = 0; i &lt;10000 ; i++) &#123;<br>            Test1 test =new Test1();<br>            test.setUser(i);<br>            test.setName(&quot;test&quot;+i);<br>            tsetService.save(test);<br>        &#125;<br>        long b =System.currentTimeMillis();<br>        System.out.println(b-a);<br>    &#125;<br></code></pre></td></tr></table></figure>最后耗时10180毫秒</li><li>批量插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">public void test2() &#123;<br>        long a =System.currentTimeMillis();<br>        List&lt;Test1&gt; list =new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt;10000 ; i++) &#123;<br>            Test1 test =new Test1();<br>            test.setUser(i);<br>            test.setName(&quot;test&quot;+i);<br>            list.add(test);<br>            if (list.size()==100) &#123;<br>                tsetService.saveBatch(list);<br>            &#125;<br>        &#125;<br>        long b =System.currentTimeMillis();<br>        System.out.println(b-a);<br>    &#125;<br></code></pre></td></tr></table></figure>最后耗时264毫秒，显著提升了50倍速度！！！<br>当然啦这还不是最快的</li><li>MYSQL的rewriteBatchedStatements=true<br>在配置数据库的url后面添加rewriteBatchedStatements=true 即可<br>代码与上面代码相同不变<br>最后耗时202毫秒，由于我直插入了10000条数据所以性能不明显，数据越多明显越大</li></ol><p>最后再来说一下rewriteBatchedStatements=true的作用</p><ol><li>如果不加，我们操作会是将一千条数据封装到list中，由list传入数据库，然后每一条数据执行一次insert语句<br>所以提升速度的原因是减少了连接数据库的次数</li><li>加上rewriteBatchedStatements=true后，list传入后数据库只需要执行一次insert语句，因为者一千条数据会进行拼接</li></ol><h2 id="DB静态工具"><a href="#DB静态工具" class="headerlink" title="DB静态工具"></a>DB静态工具</h2><p>介绍之前先看几个需求,前置条件，用户和地址是两个表，用外键链接<br><img src="https://www.helloimg.com/i/2024/09/06/66db1b101f551.png" alt=""><br>根据已经学习到的知识，如果我们想解决第一个问题就需要</p><ol><li>在UserService中不仅仅调用自己的IService提供的方法，也需要调用AddressService<br>(当然啦也可以调用AddressMapper)</li><li>解决第三个问题呢就需要在AddressService中调用UserService,这样互相调用的话，业务复杂<br>很多个Service层或者Mapper互相调用很大可能会造成循环依赖<br>为了解决循环依赖问题，MybatisPlus提供了DB静态工具(注意：需要3.5.0版本以上)</li><li>DB提供了和IService几乎一摸一样的方法 不过在调用DB的时候需要将所对应的实体类传入<br>利用DB解决问题1<br><img src="https://www.helloimg.com/i/2024/09/06/66db2070aef10.png" alt=""></li></ol><h2 id="JOSN处理器"><a href="#JOSN处理器" class="headerlink" title="JOSN处理器"></a>JOSN处理器</h2><p>作用：如果数据库表中有字段类型为JOSN时，可以使用Mybatis提供的JOSN处理器，简化开发<br>普通方法我会用一个String类型的变量去接收 表中JOSN类型的字段，但是这样后续业务处理比较麻烦<br>使用JSON处理器可以解决这个问题，需要三步</p><ol><li>定义一个表中JOSN类型字段锁对应的实体类，用这个实体类类型的变量去接收</li><li>同时需要使用@TableFiled中添加JOSN处理器 即typeHandler=JacksonTypeHandler.class</li><li>在@TableName中加上 autoResultMap =true 返回映射<br><img src="https://www.helloimg.com/i/2024/09/07/66dbc04951e2e.png" alt=""></li></ol><h2 id="MybatisPlus的分页功能"><a href="#MybatisPlus的分页功能" class="headerlink" title="MybatisPlus的分页功能"></a>MybatisPlus的分页功能</h2><p>MybatisPlus提供了很多拓展功能其中较为常用的就是分页功能</p><ol><li><p>分页功能的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs []">@Configuration<br>public class MybatisConfig &#123;<br>@Bean<br>public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;<br>    // 1.初始化核心插件<br>    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();<br>    // 2.添加分更插件 和指定数据库类型<br>    PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MysOL)<br>    pageInterceptor.setMaxLimit(1000L);//设置分页上限<br>    interceptor.addInnerInterceptor(pagenterceptor);<br>    return interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>个人理解：先new一个MybatisPlus的拦截器对象，在new一个分页对象并设置初始值添加到拦截器中</p></li><li><p>分页功能的基本使用</p><ol><li>这是简单封装了一个PageVO,用于处理分页查询后的数据，方便返回前端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">pubilc class PageVO&lt;T&gt;&#123;<br>    public Ingter pages;<br>    public Ingter total;<br>    public List&lt;T&gt; list<br>&#125;<br></code></pre></td></tr></table></figure></li><li>简单使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs []">public PageVO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;<br>    String name = query.getName();<br>    Integer status = query.getstatus();<br>    //1.构建分页条件<br>    // 1.1.分页条件 Page.of()需要两个参数 一个当前的页数，一个每页查询的数据量<br>    Page&lt;User&gt;page = Page.of(query.getPageNo(),query.getPagesize());<br>    // 1.2.排序条件<br>    page.addorder(new orderItem(query.getSortBy(), query.getIsAsc()));<br>    //1 2.分页查询<br>    Page&lt;User&gt; p=lambdaQuery()<br>    .like( condition: name != null, User::getUsername, name)<br>    .eq( condition: status != null, User::getstatus, status)<br>    .page(page);<br>    // 处理数据<br>    PageVO(UserVO)  pagevo =new PageVO()<br>    pagevo.setPages(p.getPages);<br>    pagevo.setTotal(p.getTotal);<br>    List&lt;User&gt; list = p.getRecords();<br>    List&lt;UserVO&gt; vo= BeanUtil.copyToList(list,UserVo.class)<br>    pagevo.setlist(vo);<br>    return pagevo;<br>&#125;<br></code></pre></td></tr></table></figure>以上就是一个分页查询用户的简单例子<br>在实际功能中 构建分页条件 排序条件 处理数据 这三个步骤在多次分页中代码基本相同<br>所以其实可以将这几部分代码抽取成三个工具类，使用到这几个步骤的时候直接调用对应的工具类</li></ol></li></ol>]]></content>
    
    
    <summary type="html">mybatisplus的引入</summary>
    
    
    
    <category term="Mybatis" scheme="http://example.com/categories/Mybatis/"/>
    
    
    <category term="MybatisPlus" scheme="http://example.com/tags/MybatisPlus/"/>
    
  </entry>
  
  <entry>
    <title>redis学习</title>
    <link href="http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-03T02:34:21.000Z</published>
    <updated>2024-11-20T11:44:18.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis雪崩"><a href="#redis雪崩" class="headerlink" title="redis雪崩"></a>redis雪崩</h1><p>  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>  对key的过期时间进行调整，防止大量key同时失效，最简单的方法对key的过期时间统一成 固定时间+random</p><h1 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h1><p>   缓存击穿是指一个非常 “热” 的 key（通常是被频繁访问的数据）在某个时间点过期，此时若有大量并发请求过来，这些请求发现缓存中没有数据，就会同时去数据库查询该数据，对数据库造成巨大的压力。</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><pre><code>在高并发下，只有获取锁成功的线程才会去查询数据库，并更新缓存，其他线程则等待一段时间。</code></pre><h4 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h4><p>   利用redis中的nx命令自定义实现锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">trylock</span><span class="hljs-params">(String key)</span>&#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">falg</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(falg);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span>&#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><pre><code>当一个线程执行到这里时，会先从缓存中查询，则会先进入StrUtil.isNotBlank(s)判断，StrUtil.isNotBlank()的作用为判断是否字符串是否不为空且不为仅包含空白字符的方法；如果为true,则说明缓存中存在且不为空，直接返回。如果为false，则说明缓存中不存在或者值为空，即进入下一个判断，如果是s！=null为true，说明缓存中存在s,但是s的值为空所以返回null,当s！=null为false后尝试获取锁，获取锁失败则等待重试，获取锁成功则查询数据库，如果数据库中存在则写入缓存中，如果不存在则向缓存中写入空值，这样可以保证在高并发的情况下只有获取锁成功的线程会访问数据库</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConstants.CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">//从redis中查询</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(s)) &#123;<br>        <span class="hljs-keyword">return</span> JSONUtil.toBean(s, Shop.class);<br>    &#125;<br>    <span class="hljs-comment">//判断是否为空值</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//不存在尝试获取锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockkey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">islock</span> <span class="hljs-operator">=</span> trylock(lockkey);<br>    Shop shop=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取锁不成功则等待反复尝试</span><br>        <span class="hljs-keyword">if</span> (!islock) &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-keyword">return</span> queryWithMutex(id);<br>        &#125;<br>        <span class="hljs-comment">//如果不存在查询数据库</span><br>        shop = getById(id);<br>        <span class="hljs-comment">//模拟实际</span><br>        Thread.sleep(<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">if</span> (shop != <span class="hljs-literal">null</span>) &#123;<br>            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL);<br>        &#125;<br>        <span class="hljs-comment">//如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, RedisConstants.CACHE_NULL_TTL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock(lockkey);<br>    &#125;<br>    <span class="hljs-keyword">return</span> shop;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><pre><code>设置逻辑过期时间，这样可以保证key永远存在，只需要判断是否逻辑过期进行更形即可</code></pre><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>  查询一个一定不存在的数据，由于缓存中没有该数据，所有的请求都会落到数据库上，导致数据库压力瞬间增大。如果有人利用这个漏洞不断发起这种查询，就可能使数据库因承受不住大量请求而崩溃。</p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-添加NULL值"><a href="#1-添加NULL值" class="headerlink" title="1 添加NULL值"></a>1 添加NULL值</h3><p><img src="https://www.helloimg.com/i/2024/09/03/66d6b0ae1fcda.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">redisPassThrought</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span>RedisConstants.CACHE_SHOP_KEY+id;<br>        <span class="hljs-comment">//从redis中查询</span><br>        String s= stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(s)) &#123;<br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(s,Shop.class);<br>        &#125;<br>        <span class="hljs-comment">//判断是否为空值</span><br>        <span class="hljs-keyword">if</span> (s!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果不存在查询数据库</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span>getById(id);<br>        <span class="hljs-keyword">if</span> (shop != <span class="hljs-literal">null</span>)&#123;<br>            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL);<br>        &#125;<br>        <span class="hljs-comment">//如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库</span><br>        <span class="hljs-keyword">else</span> &#123; stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,RedisConstants.CACHE_NULL_TTL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="Redis分布式锁-："><a href="#Redis分布式锁-：" class="headerlink" title="Redis分布式锁 ："></a>Redis分布式锁 ：</h1><h2 id="1-自定义分布式锁："><a href="#1-自定义分布式锁：" class="headerlink" title="1 自定义分布式锁："></a>1 自定义分布式锁：</h2><pre><code>  调用该方法的时候需要new一个RedisLock的对象，并传入两个需要的参数key</code></pre><h3 id="原理-："><a href="#原理-：" class="headerlink" title="原理 ："></a>原理 ：</h3><pre><code> 利用Redis中的NX命令判断是否存在，不存在则创建，存在创建会失败  注意 ： 返回值是Boolean类型时,不建议直接返回对象success，自动拆箱可能会空指针</code></pre><p>自定义分布式锁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-comment">//锁的前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-comment">//具体业务名称，将前缀和业务名拼接之后当做Key</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">//获取线程标识</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">//获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//自动拆箱可能会出现null，这样写更稳妥</span><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//通过DEL来删除锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>业务逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    <span class="hljs-comment">//1. 查询优惠券</span><br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getOne(queryWrapper);<br>    <span class="hljs-comment">//2. 判断秒杀时间是否开始</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀还未开始，请耐心等待&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3. 判断秒杀时间是否结束</span><br>    <span class="hljs-keyword">if</span> (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//4. 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (seckillVoucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;优惠券已被抢光了哦，下次记得手速快点&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 创建锁对象</span><br>    <span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br>    <span class="hljs-comment">// 获取锁对象</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock(<span class="hljs-number">120</span>);<br>    <span class="hljs-comment">// 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br>    <span class="hljs-keyword">if</span> (!isLock) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许抢多张优惠券&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取代理对象</span><br>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>        <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        redisLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h4><ol><li><p>逻辑说明<br>持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放<br>此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到<br>但是现在线程1阻塞完了，继续往下执行，要开始释放锁了<br>那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</p></li><li><p>解决方案<br>解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。<br>假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁<br><img src="https://www.helloimg.com/i/2024/09/04/66d87a2c99d06.png" alt=""></p><h4 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">      <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;-&quot;</span>;<br>    <span class="hljs-keyword">private</span> String key;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLock</span><span class="hljs-params">(String key, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(Long timeout)</span> &#123;<br>        <span class="hljs-comment">//获取锁的时候将该线程标识（UUID+线程Id）存入缓存中，释放锁是判断，防止误删</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> KEY_PREFIX +Thread.currentThread().getId();<br>       Boolean success= redisTemplate.opsForValue().setIfAbsent(key, threadId , timeout, TimeUnit.SECONDS);<br>       <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> KEY_PREFIX +Thread.currentThread().getId();<br>         <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(key);<br>         <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>             redisTemplate.delete(key);<br>         &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Redisson-可重入锁"><a href="#Redisson-可重入锁" class="headerlink" title="Redisson 可重入锁"></a>Redisson 可重入锁</h2><p>基于SETNX实现的分布式锁存在以下问题</p><ol><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li><li>重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的</li><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患</li><li>主从一致性<br>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题<h2 id="那么什么是Redisson呢"><a href="#那么什么是Redisson呢" class="headerlink" title="那么什么是Redisson呢"></a>那么什么是Redisson呢</h2>Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现<br>Redis提供了分布式锁的多种多样功能</li></ol></li><li>可重入锁(Reentrant Lock)</li><li>公平锁(Fair Lock)</li><li>联锁(MultiLock)</li><li>红锁(RedLock)</li><li>读写锁(ReadWriteLock)</li><li>信号量(Semaphore)</li><li>可过期性信号量(PermitExpirableSemaphore)</li><li>闭锁(CountDownLatch)</li></ol><h3 id="需要提前导入依赖坐标"><a href="#需要提前导入依赖坐标" class="headerlink" title="需要提前导入依赖坐标"></a>需要提前导入依赖坐标</h3><h3 id="对其进行配置"><a href="#对其进行配置" class="headerlink" title="对其进行配置"></a>对其进行配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//配置Redisson，用于分布式锁</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">RedissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>);<br>        <span class="hljs-comment">//创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">//获取可重入锁</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，三个参数分别是：获取锁的最大等待时间(期间会重试)，锁的自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理的话要读源码，读不懂一点好吧，太难读了。等我回头学会了再来补充。<br>目前只知道一点Redisson可重入的原理大概是 采用了hash结构存储锁，外层key代表锁存在，<br>内层key代表是线程的标识 即一个方法会先获取外层key，如果锁存在，则该方法继续获取<br>内层key,如果内层key和自己的线程标识相同，则获取锁成功，此时value +1,方法执行完后<br>也不是直接释放锁，而是value -1，直到value =0时才释放锁</p><h1 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>  字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<br>  消息队列：存储和管理消息，也被称为消息代理（Message Broker）<br>  生产者：发送消息到消息队列<br>  消费者：从消息队列获取消息并处理消息</p><h2 id="使用队列的好处在于解耦："><a href="#使用队列的好处在于解耦：" class="headerlink" title="使用队列的好处在于解耦："></a>使用队列的好处在于解耦：</h2><p>  举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br>  那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br>  这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</p><h2 id="redis基于List的消息队列"><a href="#redis基于List的消息队列" class="headerlink" title="redis基于List的消息队列"></a>redis基于List的消息队列</h2><p> 消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果<br>  队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。<br> 不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或 者BLPOP来实现阻塞效果</p><h3 id="基于List的消息队列有哪些优缺点？"><a href="#基于List的消息队列有哪些优缺点？" class="headerlink" title="基于List的消息队列有哪些优缺点？"></a>基于List的消息队列有哪些优缺点？</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)<h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息<br>SUBSCRIBE channel [channel]：订阅一个或多个频道<br>PUBLISH channel msg：向一个频道发送消息<br>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li></ol><h3 id="基于PubSub的消息队列有哪些优缺点"><a href="#基于PubSub的消息队列有哪些优缺点" class="headerlink" title="基于PubSub的消息队列有哪些优缺点"></a>基于PubSub的消息队列有哪些优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>采用发布订阅模型，支持多生产，多消费</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不支持数据持久化<br>2 .无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）<br>3 .消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）<h2 id="Stream的单消费模式"><a href="#Stream的单消费模式" class="headerlink" title="Stream的单消费模式"></a>Stream的单消费模式</h2><img src="https://www.helloimg.com/i/2024/09/03/66d6ef96a5d79.jpg" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]"><br>## 创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID<br>XADD users * name jack age 21<br></code></pre></td></tr></table></figure></li></ol><p>读取队列方法之一 ：XREAD<br><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs re"><span class="hljs-type">XREAD</span> [<span class="hljs-type">COUNT</span> count] [<span class="hljs-type">BLOCK</span> milliseconds] <span class="hljs-type">STREAMS</span> key [key ...] <span class="hljs-type">ID</span> [<span class="hljs-type">ID</span> ...]<br></code></pre></td></tr></table></figure></p><ol><li>[COUNT count]<br>每次读取消息的最大数量</li><li>[BLOCK milliseconds]<br>当没有消息时，是否阻塞，阻塞时长</li><li>STREAMS key [key …]<br>要从哪个队列读取消息，key就是队列名</li><li>ID [ID …]<br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始</li></ol><p>注意：<br> 当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题</p><h3 id="STREAM类型消息队列的XREAD命令特点"><a href="#STREAM类型消息队列的XREAD命令特点" class="headerlink" title="STREAM类型消息队列的XREAD命令特点"></a>STREAM类型消息队列的XREAD命令特点</h3><ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol><h2 id="Sream的组消费模式"><a href="#Sream的组消费模式" class="headerlink" title="Sream的组消费模式"></a>Sream的组消费模式</h2><pre><code>将多个消费者划分为一组，监听一个队列</code></pre><h3 id="1-消息分流"><a href="#1-消息分流" class="headerlink" title="1.消息分流"></a>1.消息分流</h3><p>队列中消息分给组内不同的消费者，而不是重复消费者（也可以消费者重复去执行）提高效率</p><h3 id="2-消息标识"><a href="#2-消息标识" class="headerlink" title="2. 消息标识"></a>2. 消息标识</h3><p>消费者在读取一个消息后，会给该消息添加一个标识，从而可以记录到最后被处理的消息，即使消费者宕机。重启后可以<br>继续从标识的地方继续读取，直到消费者执行完毕该消息，进行确认后，该消息才会被消息队列移除，确保了每个消息最少执行一遍</p><h3 id="3。消息确认"><a href="#3。消息确认" class="headerlink" title="3。消息确认"></a>3。消息确认</h3><p>消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</p><h2 id="基于Stream实现异步秒杀"><a href="#基于Stream实现异步秒杀" class="headerlink" title="基于Stream实现异步秒杀"></a>基于Stream实现异步秒杀</h2><pre><code>异步秒杀所以需要子线程中消费队列思路：在子线程中一直循环，循环中该线程指定g1组的消费者c1读取Stream中的消息，然后判断读取的消息是否为空，为空则进行下一次循环，不为空则解析消息中的数据，得到需要的对象，然后创建订单，订单完成后进行消息确认消息队列会移除该消息，如果执行过程中出现异常，就会先捕捉异常，然后执行pending-list中的消息，因为出现异常消息被读取加上标识，但是并未确定，所以会在pending-list中。读取消息，判断是否为空，不为空则创建订单，确认消息，如果为空说明pending-list中没有消息，直接break。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queuename</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;stream.order&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">VoucherOrderHander</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">//1.2 stream</span><br>                  <span class="hljs-comment">//获取消息队列中的信息</span><br>                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                          <span class="hljs-comment">//.count(1) 表示只读取一个元素， .block(Duration.ofSeconds(2))表示如果没有消息则等待两秒,</span><br>                          StreamReadOptions.empty().count(<span class="hljs-number">1</span>).block(Duration.ofSeconds(<span class="hljs-number">2</span>)),<br>                          <span class="hljs-comment">// ReadOffset.lastConsumed()表示从最新元素开始读取</span><br>                          StreamOffset.create(queuename, ReadOffset.lastConsumed()));<br>                  <span class="hljs-comment">//判断是否获取成功</span><br>                  <span class="hljs-keyword">if</span> (list ==<span class="hljs-literal">null</span> || list.isEmpty())&#123;<br>                      <span class="hljs-keyword">continue</span>;<br>                  &#125;<br>                  <span class="hljs-comment">//解析信息</span><br>                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(<span class="hljs-number">0</span>);<br>                  Map&lt;Object,Object&gt; value = mapRecord.getValue();<br>                 VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(),<span class="hljs-literal">true</span>);<br>                  <span class="hljs-comment">//创建订单</span><br>                  porxy.CreateVoucher1(voucherOrder);<br>                  <span class="hljs-comment">//xack确认</span><br>                  stringRedisTemplate.opsForStream().acknowledge(queuename,<span class="hljs-string">&quot;g1&quot;</span>,mapRecord.getId());<br>              &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                  log.info(<span class="hljs-string">&quot;异步订单&quot;</span>,e);<br>                  <span class="hljs-comment">//获取消息队列中的信息</span><br>                  <span class="hljs-comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span><br>                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                          StreamReadOptions.empty().count(<span class="hljs-number">1</span>),<br>                          StreamOffset.create(queuename,ReadOffset.from(<span class="hljs-string">&quot;0&quot;</span>)));<br>                  <span class="hljs-comment">//判断是否获取成功</span><br>                  <span class="hljs-keyword">if</span> (list ==<span class="hljs-literal">null</span> || list.isEmpty())&#123;<br>                     <span class="hljs-keyword">break</span>;<br>                  &#125;<br>                  <span class="hljs-comment">//解析信息</span><br>                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(<span class="hljs-number">0</span>);<br>                  Map&lt;Object,Object&gt; value = mapRecord.getValue();<br>                  VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(),<span class="hljs-literal">true</span>);<br>                  <span class="hljs-comment">//创建订单</span><br>                  porxy.CreateVoucher1(voucherOrder);<br>                  <span class="hljs-comment">//xack确认</span><br>                  stringRedisTemplate.opsForStream().acknowledge(queuename,<span class="hljs-string">&quot;g1&quot;</span>,mapRecord.getId());<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p> 主线程中的异步秒杀的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>      <span class="hljs-type">long</span> orderId= redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>      <span class="hljs-comment">//执行lua脚本</span><br>      <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>              SECKILL_SCRIPT, Collections.emptyList(),<br>              voucherId.toString(), userId.toString(),String.valueOf(orderId)<br>      );<br>      <span class="hljs-comment">//判断是否为0</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>      <span class="hljs-keyword">if</span> (r!=<span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-keyword">return</span> Result.fail(r==<span class="hljs-number">1</span>? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>) ;<br>      &#125;<br>      porxy = (IVoucherOrderService) AopContext.currentProxy();<br>      <span class="hljs-keyword">return</span> Result.ok(orderId); <br></code></pre></td></tr></table></figure><br>Lua脚本的代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 订单id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的</span><br><span class="hljs-keyword">local</span> id = ARGV[<span class="hljs-number">3</span>]<br><span class="hljs-comment">-- 优惠券key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 判断库存是否充足</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 判断用户是否下单</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 扣减库存</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 将userId存入当前优惠券的set集合</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 将下单数据保存到消息队列中</span><br>redis.call(<span class="hljs-string">&quot;sadd&quot;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, id)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><br>redis的学习就先到这里吧，时间紧任务重就要先去学微服务啦</p>]]></content>
    
    
    <summary type="html">这是一个我与redis的故事</summary>
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
</feed>

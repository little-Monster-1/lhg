<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Little Monste&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-14T09:43:21.983Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小怪兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>uniapp</title>
    <link href="http://example.com/2024/09/28/uniapp/"/>
    <id>http://example.com/2024/09/28/uniapp/</id>
    <published>2024-09-28T01:56:30.933Z</published>
    <updated>2024-10-14T09:43:21.983Z</updated>
    
    <content type="html"><![CDATA[<p>学习uniapp主要干活要用，但主要还是继续学JAVA，所以来简单了解一下</p><h1 id="了解uniapp"><a href="#了解uniapp" class="headerlink" title="了解uniapp"></a>了解uniapp</h1><p>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台</p><h1 id="uniapp的常用组件"><a href="#uniapp的常用组件" class="headerlink" title="uniapp的常用组件"></a>uniapp的常用组件</h1><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><p>view 视图容器 类似与传统的div标签<br>添加hover-stop-propagation属性可以防止事件冒泡</p><p>  属性名    类型    默认值    说明</p><ul><li>hover-class    String    none    指定按下去的样式类。当 hover-class=”none” 时，没有点击态效果</li><li>hover-stop-propagation    Boolean    false    指定是否阻止本节点的祖先节点出现点击态，App、H5、支付宝小程序、百度小程序不支持（支付宝小程序、百度小程序文档中都有此属性，实测未支持）</li><li>hover-start-time    Number    50    按住后多久出现点击态，单位毫秒</li><li>hover-stay-time    Number    400    手指松开后点击态保留时间，单位毫秒<h2 id="text"><a href="#text" class="headerlink" title="text"></a>text</h2>文本组件。用于包裹文本内容。文本只能写在text中，而不能写在view的text区域<br><img src="https://pic.imgdb.cn/item/66f7678bf21886ccc0e2258c.png" alt=""></li></ul><h2 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h2><p>可滚动视图区域。用于区域滚动。</p><p>需注意在webview渲染的页面中，区域滚动的性能不及页面滚动</p><ul><li><p>scroll-y    Boolean    false    允许纵向滚动<br><img src="https://pic.imgdb.cn/item/66f76ebff21886ccc0ec217e.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f76ea8f21886ccc0ec023c.png" alt=""></p></li><li><p>scroll-x    Boolean    false    允许横向滚动</p></li><li>子元素默认纵向排，在子元素的css样式中加 display: inline-block;</li><li>父元素css中设置不允许自动换行 white-space: nowrap;<br><img src="https://pic.imgdb.cn/item/66f76fa0f21886ccc0ed4e6e.png" alt=""></li></ul><h2 id="滑块视图容器"><a href="#滑块视图容器" class="headerlink" title="滑块视图容器"></a>滑块视图容器</h2><p>一般用于左右滑动或上下滑动，比如banner轮播图。</p><ul><li>indicator-dots    Boolean    false    是否显示面板指示点    </li><li>indicator-color    Color    rgba(0, 0, 0, .3)    指示点颜色    </li><li>indicator-active-color    Color    #000000    当前选中的指示点颜色    </li><li>active-class    String        swiper-item 可见时的 class    支付宝小程序</li><li>changing-class    String        acceleration 设置为 true 时且处于滑动过程中，中间若干屏处于可见时的class    支付宝小程序</li><li>autoplay    Boolean    false    是否自动切换<br><img src="https://pic.imgdb.cn/item/66f7749af21886ccc0f2ef09.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f7747bf21886ccc0f2d64c.png" alt=""></li></ul><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>这个是VUE的一个API，学习uniapp的时候碰到了就记录到这吧<br>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护</p><ul><li>在图中 两个view 标签展示出来的内容是一样的，第二个view采用了计算属性，第一个view是模板表达式<br><img src="https://pic.imgdb.cn/item/6704f20ad29ded1a8c6c86f1.jpg" alt=""><div class="note info no-icon flat"><p>计算属性的作用和模板表达式是一样的，但是如果计算较多建议使用计算属性</p></div></li><li>这是一个方法代替计算属性，最终展示效果也是一样的<br><img src="https://pic.imgdb.cn/item/6704f2ffd29ded1a8c6da383.jpg" alt=""></li></ul><div class="note red icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>计算属性和方法最终结果是一样的，不同之处在于计算属性会进行一个缓存，只要计算属性中响应式变量不变化就不会重新执行，而方法只要被调用几次就会执行几次。 方法需要加括号!</p></div><h1 id="页面传值"><a href="#页面传值" class="headerlink" title="页面传值"></a>页面传值</h1><p>今天已经开始进入项目帮忙开发功能了 第一个功能 部门功能<br>记录一下学到的东西<br>由于我目前只写了前端所以在添加部门这一块的时候会将数据传给index主页面，这时候用到了页面传参数的功能。所以我去了解了一下<br><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>页面传参也分为了三种</p></div></p><h2 id="上级页面传下级页面"><a href="#上级页面传下级页面" class="headerlink" title="上级页面传下级页面"></a>上级页面传下级页面</h2><p>上级页面传参数的时候可以用uni.navigateTo的url拼接参数即可<br><div class="note warning simple"><p>这种方式是单向的，只能上级传下级！！！</p></div><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">//在起始页面跳转到test.vue页面并传递参数<br>let uniapp = &#123;<br>    uniappItem: 0,<br>&#125;;<br>//当传递的参数是对象时，必须先转化为JSON格式<br>uni.navigateTo(&#123;<br>url: &#x27;test?id=1&amp;name=&#x27; + JSON.stringify(uniapp),<br>&#125;);<br></code></pre></td></tr></table></figure><br>下级页面接收参数可以在周期函数中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs []">onLoad: function (option) &#123; //option为object类型，会序列化上个页面传递的参数<br>console.log(option.id); //打印出上个页面传递的参数。<br>console.log(option.name); //打印出上个页面传递的参数。<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="下级传上级"><a href="#下级传上级" class="headerlink" title="下级传上级"></a>下级传上级</h2><p>用uni.setStorageSync设置缓存<br>下级页面在触发submit这个函数的时候会将formData存入缓存中，并跳转页面<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs []">export default &#123;<br>data() &#123;<br>return &#123;<br>formData:&#123;<br>departName: &quot;&quot;,<br>departType: &quot;&quot;,<br>isOpen: &quot;&quot;,<br>remark: &quot;&quot;,&#125;<br>&#125;<br>&#125;,<br>methods:&#123;<br>submit(ref)&#123;<br>//写死数据这里是将添加的数据传到主页面中<br>//后期应修改成发送请求到后端<br>uni.setStorageSync(&#x27;formData&#x27;, this.formData);<br>uni.navigateTo(&#123;<br>url:&#x27;/pages/flow/department/departmentindex&#x27;,<br>&#125;)<br>&#125;<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/670ce751d29ded1a8cf618ec.png" alt="">点击保存就会触发submit函数</p><p>上级页面通过onShow查找缓存uni.getStorageSync得到数据<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">onShow() &#123;<br>       const param = uni.getStorageSync(&#x27;formData&#x27;);<br>       if (param) &#123;<br>           // 处理从下级页面传来的参数<br>         this.formData.departmentName = param.departName<br>         this.formData.departmentTpye = param.departType<br>         this.dataList.push(this.formData)<br>         uni.removeStorageSync(&#x27;formData&#x27;);<br>       &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/670ce78ed29ded1a8cf65ec5.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习uniapp主要干活要用，但主要还是继续学JAVA，所以来简单了解一下&lt;/p&gt;
&lt;h1 id=&quot;了解uniapp&quot;&gt;&lt;a href=&quot;#了解uniapp&quot; class=&quot;headerlink&quot; title=&quot;了解uniapp&quot;&gt;&lt;/a&gt;了解uniapp&lt;/h1&gt;&lt;p&gt;u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息队列</title>
    <link href="http://example.com/2024/09/23/RabbitMQ/"/>
    <id>http://example.com/2024/09/23/RabbitMQ/</id>
    <published>2024-09-23T12:00:03.403Z</published>
    <updated>2024-09-29T07:21:19.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p><img src="https://pic.imgdb.cn/item/66f159bdf21886ccc0cc0a9a.png" alt=""><br>解读：</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><ol><li>同步常用于两个业务之间有联系，例如执行业务B 需要执行业务A后的结果 这种的都需要使用同步</li><li>异步用于 几个业务之间并没有直接联系，这时候异步更好的提供性能<br>例如这个服务，更新交易流水肯定需要在扣减余额成功后执行，所以交易流水和扣减余额肯定要同步执行<br>交易服务，通知服务，积分服务等之间并没有必要的联系，这些服务都可以异步执行<br><img src="https://pic.imgdb.cn/item/66f15b7af21886ccc0cda7cc.png" alt=""></li></ol><h1 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h1><ul><li>使用docker快速安装<br>在docker中执行这段命令，可能会出容器启动失败的情况，那就下载最新版即可解决<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs []">docker run \<br> -e RABBITMQ_DEFAULT_USER=itheima \<br> -e RABBITMQ_DEFAULT_PASS=123321 \<br> -v mq-plugins:/plugins \<br> --name mq \<br> --hostname mq \<br> -p 15672:15672 \<br> -p 5672:5672 \<br> --network hm-net\<br> -d \<br> rabbitmq:3.8-management<br></code></pre></td></tr></table></figure></li><li>访问15672端口</li></ul><ol><li>可能会出现访问不了情况，这是因为没有开启插件<br>执行这两行代码即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs []">docker exec -it 容器名 bash<br>rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure></li><li>可能会出现身份验证的情况<br><img src="https://pic.imgdb.cn/item/66f2ae74f21886ccc0e56c8b.png" alt=""><br>这是因为在创建容器的时候，添加用户的命令没有成功，需要重新添加用户<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs []">rabbitmqctl add_user 用户名 密码<br>rabbitmqctl  set_user_tags 用户名 administrator<br></code></pre></td></tr></table></figure></li></ol><p>安装成功<br><img src="https://pic.imgdb.cn/item/66f2b073f21886ccc0e76f69.png" alt=""></p><h1 id="MQ的简单了解"><a href="#MQ的简单了解" class="headerlink" title="MQ的简单了解"></a>MQ的简单了解</h1><p>MQ消息队列的架构<br>其中包含几个概念：</p><ul><li>publisher：生产者，也就是发送消息的一方</li><li>consumer：消费者，也就是消费消息的一方</li><li>queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue<br><img src="https://pic.imgdb.cn/item/66f6937cf21886ccc0227025.png" alt=""></li></ul><h1 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h1><p>SpringAMQP 提供了java编程的方式操作RabbitMQ</p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2></li></ul><ol><li>导入 AMQP的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--AMQP依赖，包含RabbitMQ--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li><p>添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  rabbitmq:<br>    host: 192.168.217.128 # 你的虚拟机IP<br>    port: 5672 # 端口<br>    virtual-host: / # 虚拟主机<br>    username: lhg # 用户名<br>    password: 123456 # 密码<br></code></pre></td></tr></table></figure></li><li><p>简单演示<br>演示过程中为了方便会省略转发器的部分，由纤细发送者直接发送到队列中<br><img src="https://pic.imgdb.cn/item/66f694cbf21886ccc023c9ad.png" alt=""></p></li></ol><ul><li>客服端创建一个队列<br><img src="https://pic.imgdb.cn/item/66f6956ff21886ccc0248be6.png" alt=""></li><li>消息发送<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.itheima.publisher.amqp;<br><br>import org.junit.jupiter.api.Test;<br>import org.springframework.amqp.rabbit.core.RabbitTemplate;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.boot.test.context.SpringBootTest;<br><br>@SpringBootTest<br>public class SpringAmqpTest &#123;<br><br>    @Autowired<br>    private RabbitTemplate rabbitTemplate;<br><br>    @Test<br>    public void testSimpleQueue() &#123;<br>        // 队列名称<br>        String queueName = &quot;simple.queue&quot;;<br>        // 消息<br>        String message = &quot;hello, spring amqp!&quot;;<br>        // 发送消息<br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>消息接收<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.itheima.consumer.listener;<br><br>import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>import org.springframework.stereotype.Component;<br><br>@Component<br>public class SpringRabbitListener &#123;<br>        // 利用RabbitListener来声明要监听的队列信息<br>    // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。<br>    // 可以看到方法体中接收的就是消息体的内容<br>    @RabbitListener(queues = &quot;simple.queue&quot;)<br>    public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123;<br>        System.out.println(&quot;spring 消费者接收到消息：【&quot; + msg + &quot;】&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>测试<br><img src="https://pic.imgdb.cn/item/66f79918f21886ccc0165b86.png" alt=""></li></ul><h1 id="Work-Queues-模型"><a href="#Work-Queues-模型" class="headerlink" title="Work Queues 模型"></a>Work Queues 模型</h1><p>Work queues，任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。<br><img src="https://pic.imgdb.cn/item/66f79cc3f21886ccc01a2cfa.png" alt=""><br>Work Queues 经常用于消息很多，消息可能堆积的形况使用，因为多个消费者可以更快的处理消息<br><div class="note warning simple"><p>Work Queues 消息队列中默认消息是平均分配的</p></div><br>例如由两个消费者A,B 消息队列中有50条消息，那么消费者A接收的消息可能是第1，3，5等消息，B接收到的是第2，4，6消息，这50条消息会轮询平均分配给消费者。<br>但是在实际开发中会有多实例的消费者，每个消费者的电脑性能不一样，所以处理消息的速度不一样，如果仍使用平均分配会不太合理</p><h2 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h2><p>RabbitMQ默认情况会轮询平均分配，简单来说也就是所有消费者排好队，到队列中领取消息，每个消费者每次只能领一条消息，每次领完之后就到消费者队伍的末尾继续排队。<br>RabbitMQ也为我们提供了对应的 prefetch配置, prefetch配置表示每个消费者最多领取到的消息，设置为1就表示消费者领取一个消息后必须处理完这个消息才能再去排队，这就实现了能者多劳<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  rabbitmq:<br>    listener:<br>      simple:<br>        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息<br></code></pre></td></tr></table></figure></p><h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>交换机可以接收消息发送者发过来的消息，然后交换机可以进行一些处理，再转发到消息队列中<br><img src="https://pic.imgdb.cn/item/66f7a90cf21886ccc028fc99.png" alt=""><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，不再发送消息到队列中，而是发给交换机</li><li>Exchange：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li>Consumer：消费者，与以前一样，订阅队列，没有变化<div class="note warning simple"><p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p></div>交换机的类型有四种：</li><li>Fanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li>Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li>Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li>Headers：头匹配，基于MQ的消息头匹配，用的较少。<h2 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h2>Fanout模式的交换机可以实现一个消息多次处理,这是Fanout交换机的特点，Fanout交换机将接收到的消息发送个所有的队列，不同的队列有相同的消息，这样就可以实现消息的多次处理了<div class="note warning simple"><p>一个消息队列中的消息只能被消费者处理一次</p></div><img src="https://pic.imgdb.cn/item/66f7a8a4f21886ccc028852c.png" alt=""></li></ul><ol><li>创建交换机<div class="note warning simple"><p>遇见的问题，点击交换机会报错状态码500<br><img src="https://pic.imgdb.cn/item/66f7b104f21886ccc031a8fd.png" alt=""><br>解决：</p><ol><li>进入容器 docker exec -it rabbit（容器ID 或者 名称） bash</li><li>进入配置目录 cd /etc/rabbitmq/conf.d/ 执行命令<br>echo management_agent.disable_metrics_collector = false &gt; management_agent.disable_metrics_collector.conf</li><li>退出容器 exit</li><li>重启服务 docker restart rabbit（容器ID 或者 名称）</li></ol></div></li></ol><p><img src="https://pic.imgdb.cn/item/66f8eaf4f21886ccc04b2022.png" alt=""></p><ol><li>交换机绑定消息队列<br><img src="https://pic.imgdb.cn/item/66f8eb30f21886ccc04b6fa3.png" alt=""></li><li>消息发送<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">@Test<br>public void testFanoutExchange() &#123;<br>    // 交换机名称<br>    String exchangeName = &quot;hmall.fanout&quot;;<br>    // 消息<br>    String message = &quot;hello, everyone!&quot;;<br>    rabbitTemplate.convertAndSend(exchangeName, &quot;&quot;, message);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>消息接收<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []">@RabbitListener(queues = &quot;fanout.queue1&quot;)<br>public void listenFanoutQueue1(String msg) &#123;<br>    System.out.println(&quot;消费者1接收到Fanout消息：【&quot; + msg + &quot;】&quot;);<br>&#125;<br><br>@RabbitListener(queues = &quot;fanout.queue2&quot;)<br>public void listenFanoutQueue2(String msg) &#123;<br>    System.out.println(&quot;消费者2接收到Fanout消息：【&quot; + msg + &quot;】&quot;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange<br><div class="note warning simple"><p>Direct 交换机再绑定消息队列时候需要多指定一个Key,消息发送者发送消息到交换机的时候也需要多一个Key的参数，Direct交换机会比较这两个Key，将消息转发Key相同的消息队列中</p></div></p><p><img src="https://pic.imgdb.cn/item/66f8eeacf21886ccc0503662.png" alt=""><br>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息<br>总结：<br>描述下Direct交换机与Fanout交换机的差异？</li><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="Topic-交换机"><a href="#Topic-交换机" class="headerlink" title="Topic 交换机"></a>Topic 交换机</h2><p>Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。<br>只不过Topic类型Exchange可以让队列在绑定BindingKey 的时候使用通配符！</p><p>BindingKey 一般都是有一个或多个单词组成，多个单词之间以.分割，例如： item.insert</p><p>通配符规则：</p><ul><li><h1 id="：匹配一个或多个词"><a href="#：匹配一个或多个词" class="headerlink" title="：匹配一个或多个词"></a>：匹配一个或多个词</h1></li><li>*：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li>item.#：能够匹配item.spu.insert 或者 item.spu</li><li>item.*：只能匹配item.spu<br><img src="https://pic.imgdb.cn/item/66f8f1baf21886ccc0542e48.png" alt=""><br>假如此时publisher发送的消息使用的RoutingKey共有四种：</li><li>china.news 代表有中国的新闻消息；</li><li>china.weather 代表中国的天气消息；</li><li>japan.news 则代表日本新闻</li><li>japan.weather 代表日本的天气消息；</li></ul><p>解释：</p><ul><li>topic.queue1：绑定的是china.# ，凡是以 china.开头的routing key 都会被匹配到，包括：<ul><li>china.news</li><li>china.weather</li></ul></li><li>topic.queue2：绑定的是#.news ，凡是以 .news结尾的 routing key 都会被匹配。包括:<ul><li>china.news</li><li>japan.news<br>总结</li></ul></li></ul><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 . 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><h1 id="：代表0个或多个词"><a href="#：代表0个或多个词" class="headerlink" title="：代表0个或多个词"></a>：代表0个或多个词</h1></li><li>*：代表1个词</li></ul><h1 id="java声明交换机和队列"><a href="#java声明交换机和队列" class="headerlink" title="java声明交换机和队列"></a>java声明交换机和队列</h1><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。<br>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建</p><h2 id="bean声明"><a href="#bean声明" class="headerlink" title="bean声明"></a>bean声明</h2><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<br><img src="https://pic.imgdb.cn/item/66f8ff06f21886ccc066b979.png" alt=""><br>我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：<br><img src="https://pic.imgdb.cn/item/66f8ff3ef21886ccc0670164.png" alt=""><br>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：<br><img src="https://pic.imgdb.cn/item/66f8ff68f21886ccc0673725.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f8ff9ef21886ccc0676fd6.jpg" alt=""></p><h2 id="注解声明"><a href="#注解声明" class="headerlink" title="注解声明"></a>注解声明</h2><p>实例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">@RabbitListener(bindings = @QueueBinding(<br>    value = @Queue(name = &quot;direct.queue1&quot;),<br>    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),<br>    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;<br>))<br>public void listenDirectQueue1(String msg)&#123;<br>    System.out.println(&quot;消费者1接收到direct.queue1的消息：【&quot; + msg + &quot;】&quot;);<br>&#125;<br><br>@RabbitListener(bindings = @QueueBinding(<br>    value = @Queue(name = &quot;direct.queue2&quot;),<br>    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),<br>    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;<br>))<br>public void listenDirectQueue2(String msg)&#123;<br>    System.out.println(&quot;消费者2接收到direct.queue2的消息：【&quot; + msg + &quot;】&quot;);<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic.imgdb.cn/item/66f159bdf21886ccc0cc0a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>springcloud</title>
    <link href="http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-09-10T08:20:20.287Z</published>
    <updated>2024-09-23T07:50:48.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>将业务的所有功能集中在一个项目中开发，打成一个包部署</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>架构简单</li><li>部署成本低<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>团队协作成本高</li><li>系统发布效率低</li><li>系统可用性差<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2>把单体架构的功能模块拆分成多个独立的项目<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3></li><li>粒度小： 拆分的项目可以可以只是一个单独的功能</li><li>团队自治</li><li>服务自治<h1 id="拆分黑马商城"><a href="#拆分黑马商城" class="headerlink" title="拆分黑马商城"></a>拆分黑马商城</h1>原单体架构的目录结构<br><img src="https://pic.imgdb.cn/item/66e2a722d9c307b7e9bb1bfa.png" alt=""><h2 id="拆分商品功能为一个微服务"><a href="#拆分商品功能为一个微服务" class="headerlink" title="拆分商品功能为一个微服务"></a>拆分商品功能为一个微服务</h2>本项目利用maven模块拆分，亦可以创建多个项目实例<h3 id="创建maven模块（item-service）"><a href="#创建maven模块（item-service）" class="headerlink" title="创建maven模块（item-service）"></a>创建maven模块（item-service）</h3>将item商品的有关代码复制粘贴到item-service中<br>需要创建启动类和修改yaml文件(端口号，和swagger的扫描路径)和添加pom的依赖<br><img src="https://pic.imgdb.cn/item/66e2a801d9c307b7e9bc13cf.png" alt=""><h3 id="创建item数据库"><a href="#创建item数据库" class="headerlink" title="创建item数据库"></a>创建item数据库</h3>因为是微服务和原本的项目已经隔离开了，所以每一个微服务都要需要对应的mysql表<br><img src="https://pic.imgdb.cn/item/66e2a957d9c307b7e9bda7b1.png" alt=""><h2 id="同理拆分购物车"><a href="#同理拆分购物车" class="headerlink" title="同理拆分购物车"></a>同理拆分购物车</h2></li></ol><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>微服务之间是互相隔离的，相当于独立的小项目，所以微服务之间不能直接相互调用<br>但在实际业务中，经常会需要商品业务的业务逻辑中需要调用购物车的api，同理购物车也要商品的api等<br>注册中心就可以解决微服务之间互相调用的问题</p><h2 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h2><p><img src="https://pic.imgdb.cn/item/66e2aac9d9c307b7e9bf65e9.png" alt=""><br>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>简介 Nacos 有阿里开发<br>实际上 Nacos也需要一台独立的计算机来部署，为了方便学习，我们在虚拟机上利用Docker部署Nacos</p><h3 id="创建Nacos数据库"><a href="#创建Nacos数据库" class="headerlink" title="创建Nacos数据库"></a>创建Nacos数据库</h3><p>数据库sql可在官方文档中查找<br><img src="https://pic.imgdb.cn/item/66e2ac6fd9c307b7e9c1afa9.png" alt=""></p><h3 id="Docker部署Nacos"><a href="#Docker部署Nacos" class="headerlink" title="Docker部署Nacos"></a>Docker部署Nacos</h3><p>nacos的数据库配置传入虚拟机<br><img src="https://pic.imgdb.cn/item/66e2ace0d9c307b7e9c24390.png" alt=""><br>创造容器并执行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">docker run -d \<br>--name nacos \<br>--env-file ./nacos/custom.env \<br>-p 8848:8848 \<br>-p 9848:9848 \<br>-p 9849:9849 \<br>--restart=always \<br>nacos/nacos-server:v2.1.0-slim<br></code></pre></td></tr></table></figure><br>部署成功页面<br><img src="https://pic.imgdb.cn/item/66e2ad7bd9c307b7e9c310a5.png" alt=""></p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><ol><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66e2b98ad9c307b7e9d11c3f.png" alt=""></li></ol><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><ol><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3></li><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure></li><li>利用DiscoveryClient工具<br>以下代码可以获取到nacos中的一个item-service的实例，然后获取该实例url发送请求即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs []">//获取实例<br>      List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;item-service&quot;);<br>      if (CollUtils.isEmpty(instances)) &#123;<br>          return;<br>      &#125;<br>      //负载均衡 选择一个实例<br>      ServiceInstance serviceInstance = instances.get(RandomUtil.randomInt(instances.size()));<br></code></pre></td></tr></table></figure><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1>OpenFeign 用于简化服务调用的过程<h2 id="OpenFeign快速入门"><a href="#OpenFeign快速入门" class="headerlink" title="OpenFeign快速入门"></a>OpenFeign快速入门</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3>在cart-service服务的pom.xml中引入OpenFeign的依赖和loadBalancer依赖<br>loadBalancer依赖是用与负载均衡的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--openFeign--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--负载均衡器--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="2-启动OpenFeign功能"><a href="#2-启动OpenFeign功能" class="headerlink" title="2.启动OpenFeign功能"></a>2.启动OpenFeign功能</h3>接下来，我们在cart-service的CartApplication启动类上添加注解，启动OpenFeign功能<br><img src="https://pic.imgdb.cn/item/66e2dd53d9c307b7e911453a.png" alt=""></li></ol><h3 id="3-编写FeignClient"><a href="#3-编写FeignClient" class="headerlink" title="3.编写FeignClient"></a>3.编写FeignClient</h3><ol><li><p>@GetMapping(“/items”)<br>List<ItemDTO> queryItemByIds(@RequestParam(“ids”) Collection<Long> ids);<br>这个方法使需要从item-service模块的controller找到对应的方法<br>例如这是未拆分前的购物车中调用item的方法这是一个通过id查询商品的功能，<br>如果需要拆分调用，我们就需要在item模块的controller中找到通过id查询商品的接口，将这个接口抽取出来<br><img src="https://pic.imgdb.cn/item/66e434e0d9c307b7e9f3889b.png" alt=""><br>如果需要拆分调用，我们就需要在item模块的controller中找到通过id查询商品的接口，将这个接口抽取出来<br><img src="https://pic.imgdb.cn/item/66e4359cd9c307b7e9f434a5.png" alt=""><br>抽取到一个公共模块中<br><img src="https://pic.imgdb.cn/item/66e435e7d9c307b7e9f47292.png" alt=""></p></li><li><p>@FeignClient(“item-service”)的作用是获取nacos中item-service的实例</p></li><li>@GetMapping(“/items”)的作用：声明请求路径，会在获得实例的http路径后加上/items <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.hmall.cart.client;<br><br>import com.hmall.cart.domain.dto.ItemDTO;<br>import org.springframework.cloud.openfeign.FeignClient;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br><br>import java.util.List;<br><br>@FeignClient(&quot;item-service&quot;)<br>public interface ItemClient &#123;<br><br>    @GetMapping(&quot;/items&quot;)<br>    List&lt;ItemDTO&gt; queryItemByIds(@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-调用-ItemClient"><a href="#4-调用-ItemClient" class="headerlink" title="4.调用 ItemClient"></a>4.调用 ItemClient</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">List&lt;ItemDTO&gt; items = itemClient.queryItembyidList(itemIds);<br></code></pre></td></tr></table></figure>相比于之前代码比较<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">/获取实例<br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;item-service&quot;);<br>        if (CollUtils.isEmpty(instances)) &#123;<br>            return;<br>        &#125;<br>        //负载均衡 选择一个实例<br>        ServiceInstance serviceInstance = instances.get(RandomUtil.randomInt(instances.size()));<br>        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(<br>                serviceInstance.getUri() + &quot;/items?ids=&#123;ids&#125;&quot;,<br>                HttpMethod.GET,<br>                null,<br>                new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<br>                Map.of(&quot;ids&quot;, CollUtils.join(itemIds, &quot;,&quot;))<br>        );<br>        List&lt;ItemDTO&gt; items =null;<br>        if (response.getStatusCode().is2xxSuccessful()) &#123;<br>           items = response.getBody();<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="OpenFeign-的连接池"><a href="#OpenFeign-的连接池" class="headerlink" title="OpenFeign 的连接池"></a>OpenFeign 的连接池</h3>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</li></ol><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--OK http 的依赖 --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;<br>  &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h4 id="开启连接池-在yaml文件中"><a href="#开启连接池-在yaml文件中" class="headerlink" title="开启连接池 在yaml文件中"></a>开启连接池 在yaml文件中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">feign:<br>  okhttp:<br>    enabled: true # 开启OKHttp功能<br></code></pre></td></tr></table></figure><h3 id="抽取OpenFeign为公共模块"><a href="#抽取OpenFeign为公共模块" class="headerlink" title="抽取OpenFeign为公共模块"></a>抽取OpenFeign为公共模块</h3><p>因为很多功能模块都需要用到OpenFeign，抽取成公共模块可以使代码更优雅<br>抽取成如下，同时需要添加nacos，OpenFeign等需要的依赖<br><img src="https://pic.imgdb.cn/item/66e3f3dfd9c307b7e9aa5fa9.png" alt=""><br>当其他功能模块需要使用远程调用的时候导入hm-api的坐标即可<br>这个错误表示查找不到对应的Bean，说明扫描包并没有扫描到hm-api<br><img src="https://pic.imgdb.cn/item/66e3f469d9c307b7e9aaf1ec.png" alt=""><br>在启动类添加注解 @EnableFeignClients(basePackages = “com.heima.api.client”) 即可</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关 就是网络的关口，负责请求的路由，转发，身份校验。<br>网关一般用于微服务中，微服务中每个微服务都有各自的ip地址请求路径等，</p><ol><li>不使用网关的情况下 前端每次发送请求都需要发送到微服务的IP地址上，并且都需要身份验证，这样会很麻烦。</li><li>使用网关的情况下，前端的所有请求都可以发送到网关上，由网关分析，身份验证，处理然后转发到对应的微服务上<br>网关的作用我觉得和单体架构的拦截器有点像，都可以拦截请求路径，然后处理判断，再发送到具体的请求方法上，<br>不过网关更加强大，可以拦截不同IP地址的请求，再转发<br>网关也更像小区保安 ： 一个前端请求过来，网关就会判断请求转发的IP地址，在身份确认后转发该请求<br><img src="https://pic.imgdb.cn/item/66e55a68d9c307b7e9ee8ddd.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/66e55aced9c307b7e9eefe28.jpg" alt=""><h2 id="网关快速入门"><a href="#网关快速入门" class="headerlink" title="网关快速入门"></a>网关快速入门</h2>网关本身也是一个微服务，所以需要先创建网关微服务</li></ol><ul><li>创建网关<br><img src="https://pic.imgdb.cn/item/66e55b5ad9c307b7e9ef8904.png" alt=""></li><li>引入网关和负载均衡的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--网关--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--nacos discovery--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--负载均衡--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>创建启动类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.hmall.gateway;<br><br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;<br><br>@SpringBootApplication<br>public class GatewayApplication &#123;<br>    public static void main(String[] args) &#123;<br>        SpringApplication.run(GatewayApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>配置yaml文件<br><img src="https://pic.imgdb.cn/item/66e55c2ad9c307b7e9f04495.jpg" alt=""></li></ul><h2 id="网关登录验证"><a href="#网关登录验证" class="headerlink" title="网关登录验证"></a>网关登录验证</h2><p>使用网关进行登录校验，首先我们需要先了解网关的执行流程</p><h3 id="网关的执行流程"><a href="#网关的执行流程" class="headerlink" title="网关的执行流程"></a>网关的执行流程</h3><p>当前端发来请求到网关，网关会先执行断言（HandlerMapper），断言的作用是根据前端传来的请求，来判断目的地微服务，断言结束后，会执行过滤器处理器，里面会有很多的过滤器，会依次执行这些过滤器，NettyRoutingFilter是最后一个过滤器，它负责将处理后的请求转发到微服务上<br>所以网关登录校验即是自定义一个过滤器用来判断身份<br><img src="https://pic.imgdb.cn/item/66e6c8b2d9c307b7e9b2d7fa.jpg" alt=""></p><h3 id="自定义网关过滤器"><a href="#自定义网关过滤器" class="headerlink" title="自定义网关过滤器"></a>自定义网关过滤器</h3><p> GlobalFilter : 全局过滤器，作用范围i是所有路由，声明后自动生效<br> 以下是一个自定义的网关过滤器：</p><ol><li>该过滤器实现了 GlobalFilter接口，其中ServerWebExchange exchange变量是存储过滤器中的数据的，所以每一个过滤器调用数据都需要从exchange中调取，经过过滤器处理后需要得到一个新的ServerWebExchange类型的变量例如exchange1，然后 利用GatewayFilterChain chain的chain.filter(exchange1)方法将处理后的数据传入下一个过滤器</li><li>该过滤器实现了  Ordered接口 ，是用来规定过滤器的执行顺序的，Ordered的方法返回值越小，则越先执行</li><li>该过滤器的作用：先获取请求头，从请求头中的路径判断是否需要拦截（因为有些功能不需要拦截，例如注册登录），需要拦截则获取请求头Authorization中的token，如果token为空则返会401，token不为空则解析token，获得token中的userId，然后将userId封装到user-info请求头中，并放入新的exchange1 中，传入下一个过滤器，最终转发到微服务上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs []">@RequiredArgsConstructor<br>@Component<br>public class AuthGlobalFilter implements GlobalFilter, Ordered &#123;<br>    private final AuthProperties authProperties;<br>    private final JwtTool jwtTool;<br>    private final AntPathMatcher antPathMatcher = new AntPathMatcher();<br>    @Override<br>    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;<br>        // 1,获取请求头<br>       ServerHttpRequest request = exchange.getRequest();<br>       // 判断是否需要拦截<br>        if(isExclude(request.getPath().toString()))<br>        &#123;<br>            return chain.filter(exchange);<br>        &#125;<br>        // 获取token<br>        String token =null;<br>         List&lt;String&gt; authorization = request.getHeaders().get(&quot;Authorization&quot;);<br>         if (authorization != null &amp;&amp; authorization.size() &gt; 0) &#123;<br>             token = authorization.get(0);<br>         &#125;<br>         // 解析校验token<br>        Long userId = null;<br>         try &#123;<br>             userId= jwtTool.parseToken(token);<br>         &#125;catch (UnauthorizedException e)<br>         &#123;<br>              ServerHttpResponse response = exchange.getResponse();<br>              response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>              return response.setComplete();<br>         &#125;<br>         //传递用户信息<br>       String userInfo = userId.toString();<br>         ServerWebExchange exchange1 = exchange.mutate()<br>                .request(builder -&gt; builder.header(&quot;user-info&quot;, userInfo))<br>                .build();<br>        return chain.filter(exchange1);<br>    &#125;<br><br>    private boolean isExclude(String path) &#123;<br>        for(String pathPattern : authProperties.getExcludePaths())&#123;<br>            if (antPathMatcher.match(pathPattern, path)) &#123;<br>                return true;<br>            &#125;<br>        &#125;<br>        return false;<br>    &#125;<br><br><br>    @Override<br>    public int getOrder() &#123;<br>        return 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网关传递用户信息"><a href="#网关传递用户信息" class="headerlink" title="网关传递用户信息"></a>网关传递用户信息</h3><ol><li>在自定义网关过滤器中，已经将用户Id传入请求头中，所以在微服务中需要拦截器获取用户Id<br><img src="https://pic.imgdb.cn/item/66e6c8d5d9c307b7e9b2f1e1.jpg" alt=""></li><li>在公共类中创建拦截器,因为在网关中已经做过获取和解析token了，所以这个请求头里并没有加密，只有用户id<br><img src="https://pic.imgdb.cn/item/66e6c9f1d9c307b7e9b3db6a.png" alt=""></li><li>注册拦截器，拦截器需要一个配置类注册才能生效<br>需要多加一个注解@ConditionalOnClass(DispatcherServlet.class)，该注解的意思是这个配置类生效的范围是拥有DispatcherServlet.class的模块，因为网关的依赖的中并没有springmvc，其他模块微服务都是基于springmvc的，而DispatcherServlet.class正是springmvc的核心之一，所以这个配置类将不会再网关中生效<br><img src="https://pic.imgdb.cn/item/66e6ca4fd9c307b7e9b4243a.png" alt=""><h1 id="OpenFeign的补充"><a href="#OpenFeign的补充" class="headerlink" title="OpenFeign的补充"></a>OpenFeign的补充</h1></li><li>前面已经实现了用OpenFeign进行微服务之间的调用，还有一个问题微服务之间调用的同时传入用户信息需要OpenFeign解决</li><li>我们利用网关将用户登录的信息转发到了微服务上，但是微服务和微服务之间相互调用的时候并不能传入用户的登录信息，</li><li>我们又知道微服务之间的远程调用时利用OpenFeign做到的，所以OpenFeign提供了拦截器为我们解决这个问题<br><img src="https://pic.imgdb.cn/item/66e7dd28d9c307b7e908b110.jpg" alt=""><h2 id="OpenFeign的拦截器"><a href="#OpenFeign的拦截器" class="headerlink" title="OpenFeign的拦截器"></a>OpenFeign的拦截器</h2><img src="https://pic.imgdb.cn/item/66e7deadd9c307b7e90b2a17.jpg" alt=""><br>这个拦截器很简单就写在了同一个配置类下，当然可以新建一个配置类然后实现RequestInterceptor接口<br><img src="https://pic.imgdb.cn/item/66e7de5fd9c307b7e90ab226.png" alt=""></li></ol></li></ol><h1 id="Nacos的扩展-配置共享"><a href="#Nacos的扩展-配置共享" class="headerlink" title="Nacos的扩展 配置共享"></a>Nacos的扩展 配置共享</h1><p>在我们的微服务中很多配置（例如mybatispuls,日志，数据库连接池）都是微服务共有的，这需要我们在每个微服务里都写一遍，这是很麻烦的<br>所以Nacos为我们解决了这个问题</p><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><h3 id="在Nacos上添加配置"><a href="#在Nacos上添加配置" class="headerlink" title="在Nacos上添加配置"></a>在Nacos上添加配置</h3><p>注意 ：dataID不能乱写，因为是yaml格式的文件，所以 dataid的结尾必须是 .yaml<br><img src="https://pic.imgdb.cn/item/66eac48df21886ccc0d074fc.png" alt=""></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos配置管理--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--读取bootstrap文件--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="编写bootstrap-yaml"><a href="#编写bootstrap-yaml" class="headerlink" title="编写bootstrap.yaml"></a>编写bootstrap.yaml</h3><p>在此之前我们需要先了解sringboot的启动顺序，springboot启动会先加载application.yml，然后初始化ApplicationContext；<br>在微服务Springcloud中启动，sringclound会先在bootstrap.yaml中拉取nacos的共享配置，然后初始化ApplicationContext，接着加载springboard的application.yml，进行配置整合，最后初始化<br><img src="https://pic.imgdb.cn/item/66eac6b4f21886ccc0d26cf3.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: cart-service # 服务名称<br>  profiles:<br>    active: dev<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128 # nacos地址<br>      config:<br>        file-extension: yaml # 文件后缀名<br>        shared-configs: # 共享配置<br>          - dataId: shared-jdbc.yaml # 共享mybatis配置<br>          - dataId: shared-swagger.yaml # 共享日志配置<br></code></pre></td></tr></table></figure></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>当我们在idea中修改了项目的配置的时候，一般都需要重启项目才能生效，但利用nacos可以做到热更新<br> 添加配置<br> <img src="https://pic.imgdb.cn/item/66ebf2a7f21886ccc0d3b104.png" alt=""><br>然后需要创建一个类用于接收配置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.hmall.cart.config;<br><br>import lombok.Data;<br>import org.springframework.boot.context.properties.ConfigurationProperties;<br>import org.springframework.stereotype.Component;<br><br>@Data<br>@Component<br>@ConfigurationProperties(prefix = &quot;hm.cart&quot;)<br>public class CartProperties &#123;<br>    private Integer maxAmount;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样maxAmount 就可以实时等于配置中的数据了</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由也一样，防止路由变化然后需要项目重启</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--统一配置管理--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--加载bootstrap--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="然后在网关gateway的resources目录创建bootstrap-yaml文件"><a href="#然后在网关gateway的resources目录创建bootstrap-yaml文件" class="headerlink" title="然后在网关gateway的resources目录创建bootstrap.yaml文件"></a>然后在网关gateway的resources目录创建bootstrap.yaml文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: gateway<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.150.101<br>      config:<br>        file-extension: yaml<br>        shared-configs:<br>          - dataId: shared-log.yaml # 共享日志配置<br>          - dataId: gateway-routes.json #这个需要根据自己定义的dataId<br></code></pre></td></tr></table></figure><h3 id="配置路由监听器"><a href="#配置路由监听器" class="headerlink" title="配置路由监听器"></a>配置路由监听器</h3><p>因为我们需要先监听路由是否变化，如果路由没有变化，就不用去更新路由;<br> RouteDefinitionWriter接口是由nacos提供的Bean，导入nacos的依赖就可以注入，作用是更新和删除路由。但不能批量<br>NacosConfigManager也是由nacos提供的Bean,作用是与nacos建立联系，可以实时获取nacos里的配置，并监听是否发生变化<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs []">@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class RouterLoader &#123;<br><br>    private final RouteDefinitionWriter writer;<br>    private final NacosConfigManager nacosConfigManager;<br><br>    // 路由配置文件的id和分组<br>    private final String dataId = &quot;gateway-routes.json&quot;;<br>    private final String group = &quot;DEFAULT_GROUP&quot;;<br>    // 保存更新过的路由id<br>    private final Set&lt;String&gt; routeIds = new HashSet&lt;&gt;();<br><br>    @PostConstruct<br>    public void initRouteConfigListener() throws NacosException &#123;<br>        // 1.注册监听器并首次拉取配置<br>        String configInfo = nacosConfigManager.getConfigService()<br>                .getConfigAndSignListener(dataId, group, 5000, new Listener() &#123;<br>                    @Override<br>                    public Executor getExecutor() &#123;<br>                        return null;<br>                    &#125;<br>                    <br>                    @Override  //路由变化则触发<br>                    public void receiveConfigInfo(String configInfo) &#123;<br>                        updateConfigInfo(configInfo);<br>                    &#125;<br>                &#125;);<br>        // 2.首次启动时，更新一次配置<br>        updateConfigInfo(configInfo);<br>    &#125;<br><br>    private void updateConfigInfo(String configInfo) &#123;<br>        log.debug(&quot;监听到路由配置变更，&#123;&#125;&quot;, configInfo);<br>        // 1.反序列化<br>        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);<br>        // 2.更新前先清空旧路由<br>        // 2.1.清除旧路由<br>        for (String routeId : routeIds) &#123;<br>            writer.delete(Mono.just(routeId)).subscribe();<br>        &#125;<br>        routeIds.clear();<br>        // 2.2.判断是否有新的路由要更新<br>        if (CollUtils.isEmpty(routeDefinitions)) &#123;<br>            // 无新路由配置，直接结束<br>            return;<br>        &#125;<br>        // 3.更新路由<br>        routeDefinitions.forEach(routeDefinition -&gt; &#123;<br>            // 3.1.更新路由<br>            writer.save(Mono.just(routeDefinition)).subscribe();<br>            // 3.2.记录路由id，方便将来删除<br>            routeIds.add(routeDefinition.getId());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="nacos添加路由"><a href="#nacos添加路由" class="headerlink" title="nacos添加路由"></a>nacos添加路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs []">[<br>    &#123;<br>        &quot;id&quot;: &quot;item&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/items/**&quot;, &quot;_genkey_1&quot;:&quot;/search/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://item-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;cart&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/carts/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://cart-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;user&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/users/**&quot;, &quot;_genkey_1&quot;:&quot;/addresses/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://user-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;trade&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/orders/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://trade-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;pay&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/pay-orders/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://pay-service&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h1 id="微服务的雪崩问题"><a href="#微服务的雪崩问题" class="headerlink" title="微服务的雪崩问题"></a>微服务的雪崩问题</h1><p>微服务调用链路中的某个服务故障，引起整个链路中的所有的微服务都不可用。<br>简单来说就是蝴蝶效应，因为微服务之间是错用复杂的，如果一个微服务A故障，那么由于微服务B调用A，导致B也故障，微服务C调用B，结果导致C也故障了。以此类推就会可能发生微服务大面积雪崩</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel 是一款开源的微服务限流器，可以帮助我们解决微服务的雪崩问题</p><ul><li>初识Sentinel</li></ul><ol><li>官网下载Jar，并运行<br>端口号冲突，更改了一下端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br></code></pre></td></tr></table></figure>运行成功即可访问</li><li>添加依赖和配置<br>这些配置可以共享到nacos中以后更加方便<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--sentinel--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; <br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br><br><br>spring:<br>  cloud: <br>    sentinel:<br>      transport:<br>        dashboard: localhost:8090<br></code></pre></td></tr></table></figure></li><li>访问8090端口<br><img src="https://pic.imgdb.cn/item/66ed294af21886ccc0e9941d.png" alt=""><h2 id="sentinel-之线程隔离"><a href="#sentinel-之线程隔离" class="headerlink" title="sentinel 之线程隔离"></a>sentinel 之线程隔离</h2>一个微服务A中可能会调用多个微服务 B,C,D等，但是如果B微服务宕机等，会导致A调用B的线程也出问题，会占用微服务A的资源。当异常线程组都多，会影响到微服务A调用其他微服务。<br>所以sentinel会我们提供了线程隔离，例如给一个请求规定5个线程，当这个请求的线程达到5个，就不允许这个请求的线程再增加。这样就不会影响到其他线程<br><img src="https://pic.imgdb.cn/item/66eeb555f21886ccc056f5c5.jpg" alt=""><br>sentinel设置线程隔离很简单，再请求的流控中设置并发线程数即可<br><img src="https://pic.imgdb.cn/item/66eeb694f21886ccc058690d.png" alt=""><h2 id="sentinel-之线程熔断"><a href="#sentinel-之线程熔断" class="headerlink" title="sentinel 之线程熔断"></a>sentinel 之线程熔断</h2>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。<br>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口熔断。当商品服务接口恢复正常后，再允许调用。这其实就是断路器的工作模式了。</li></ol><p>Sentinel中的断路器不仅可以统计某个接口的慢请求比例，还可以统计异常请求比例。当这些比例超出阈值时，就会熔断该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。<br>断路器的工作状态切换有一个状态机来控制：<br><img src="https://pic.imgdb.cn/item/66efc8e5f21886ccc05c0878.png" alt=""><br>状态机包括三个状态：</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li>open：打开状态，服务调用被熔断，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态<br><img src="https://pic.imgdb.cn/item/66efc946f21886ccc05c6653.png" alt=""><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1>首先我们以前在单体架构中实现事务的同成功同失败是需要在方法上添加@Transactional注解实现的；<br>但是这个方法已经对微服务不适用了，我们先来看一个业务流程<br><img src="https://pic.imgdb.cn/item/66efd045f21886ccc0639203.png" alt=""><br>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</li></ul></li><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务<br>这些分开的交易，购物车，库存 被称为分支事务，组合在一起被称为全局事务，分布式事务需要保证全局事务同成功同失败<h2 id="认识Seata"><a href="#认识Seata" class="headerlink" title="认识Seata"></a>认识Seata</h2>解决分布式事务的思路：分布式事务的主要问题是分支事务都可以保证自己事务的同成功同失败，但是分支事务之间不知道对方是否成功或失败，<br>所以就需要找到一个事务协调者，帮忙记录下每个分支事务的结果</li></ul><ol><li>Seata的架构图<br>在Seata的事务管理中有三个重要的角色：</li></ol><ul><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。 </li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li><li>RM (Resource Manager) - 资源管理器：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<br><img src="https://pic.imgdb.cn/item/66efd20cf21886ccc0656212.png" alt=""><br>个人理解呢：TC既是事务协调者记录每个分支事务结果，当一个业务中所有分支事务结束后判断是否需要回滚。<pre><code>    但是TC并不知道这个业务的最后一个分支事务是哪个，中间也由可能有其他业务的分支事务，所以TM出现了，    TM定义了一个业务的开始和结束，当TM开始的时候，TC会接收信号然后记录分支事务的结果，当TM结束后，TC也会结束这个业务的事务    RM即是每个分支事务结束后会通过RM向TC传入自己分支事务的状态和结果。    个人觉得RM中还会带有TM的标识，TC根据标识可以分辨出这个事务是否属于TM，这样可以多个全局事务一起执行</code></pre><h3 id="部署Seata"><a href="#部署Seata" class="headerlink" title="部署Seata"></a>部署Seata</h3></li></ul><ol><li>准备Seata的数据库<br>具体sql语句可以查询Seata的官方文档有给出<br><img src="https://pic.imgdb.cn/item/66efd4dbf21886ccc0682856.png" alt=""></li><li>在Docker上部署Seata<ul><li>准备好seata的配置文件application.yml上传到虚拟机中<br>配置文件官网中也有，也可以之下在seata的镜像文件，然后修改</li><li>启动容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []"> docker run --name seata \<br>-p 8099:8099 \<br>-p 7099:7099 \<br>-e SEATA_IP=192.168.150.101 \<br>-v ./seata:/seata-server/resources \<br>--privileged=true \<br>--network hm-net \<br>-d \<br>seataio/seata-server:1.5.2<br></code></pre></td></tr></table></figure>这里我出现了报错，docker ps -a 查看后发现状态码为139，<br>查看日志发现报错是<br><img src="https://pic.imgdb.cn/item/66efe7f0f21886ccc07a89a4.png" alt=""><br>查询了半天后需要添加一项命令在run命令后<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []">  docker run --name seata \<br>-p 8099:8099 \<br>-p 7099:7099 \<br>-e SEATA_IP=192.168.150.101 \<br>-v ./seata:/seata-server/resources \<br>--privileged=true \<br>--network hm-net \<br>-d --ulimit nofile=1024:1024 \<br>seataio/seata-server:1.5.2<br></code></pre></td></tr></table></figure></li></ul></li><li>启动成功<br><img src="https://pic.imgdb.cn/item/66efe861f21886ccc07aebce.png" alt=""><h3 id="微服务整合seata"><a href="#微服务整合seata" class="headerlink" title="微服务整合seata"></a>微服务整合seata</h3></li><li>添加相关依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--统一配置管理--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br>  &lt;!--读取bootstrap文件--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br>  &lt;!--seata--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>seata的配置添加到nacos上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址<br>    type: nacos # 注册中心类型 nacos<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br>      namespace: &quot;&quot; # namespace，默认为空<br>      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP<br>      application: seata-server # seata服务名称<br>      username: nacos<br>      password: nacos<br>  tx-service-group: hmall # 事务组名称<br>  service:<br>    vgroup-mapping: # 事务组与tc集群的映射关系<br>      hmall: &quot;default&quot;<br></code></pre></td></tr></table></figure></li><li>在bootstrap.yaml文件中添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: trade-service # 服务名称<br>  profiles:<br>    active: dev<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128 # nacos地址<br>      config:<br>        file-extension: yaml # 文件后缀名<br>        shared-configs: # 共享配置<br>          - dataId: shared-jdbc.yaml # 共享mybatis配置<br>          - dataId: shared-log.yaml # 共享日志配置<br>          - dataId: shared-swagger.yaml # 共享日志配置<br>          - dataId: shared-seata.yaml # 共享seata配置<br></code></pre></td></tr></table></figure>之后就可以启动服务啦，不过这里记录一下JDK21我启动遇见的问题<br><img src="https://pic.imgdb.cn/item/66efff7cf21886ccc0937a79.png" alt=""><br>解决方法JVM启动添加—add-opens=java.base/java.lang=ALL-UNNAMED<br><img src="https://pic.imgdb.cn/item/66efffcaf21886ccc093e689.png" alt=""><br>百度了一下：—add-opens选项是Java 9引入的一个命令行选项，用于打开模块之间的包，以便其他模块可以访问这些包中的类和成员。通过使用—add-opens选项，我们可以解决由于模块的隔离性而导致的访问限制问题</li></ol><h2 id="Seata之XA模式"><a href="#Seata之XA模式" class="headerlink" title="Seata之XA模式"></a>Seata之XA模式</h2><p>XA模式比较依赖关系型数据库，XA模式和上面提到的Seata架构的执行顺序基本相同，不过XA模式的特点是当分支事务执行完后并不会提交事务，而是当所有分支事务都执行完后，TC端如果记录的执行状态全部成功，则所有分支事务一起提交事务，如有有一个执行失败，则TC通知所有分支事务全部回滚。以这样的方式保证了数据的强一致性。但是也消耗性能。因为分支事务再执行完后并不会提交事务，所以分支事务会占着数据库该表的锁，mysql数据库的锁又是排他锁，所以如果这个分支事务不提交事务，就无法释放锁，其他业务也就没办法操作数据库<br><img src="https://pic.imgdb.cn/item/66f11769f21886ccc08bd838.png" alt=""><br>RM一阶段的工作：</p><ol><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ol><p>TC二阶段的工作：</p><ol><li>TC检测各分支事务执行状态<ol><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务 </li></ol></li></ol><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p>XA模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务<h3 id="XA的实现"><a href="#XA的实现" class="headerlink" title="XA的实现"></a>XA的实现</h3></li></ul><ol><li>在Seata的yaml文件中指定XA模式（可以在nacos中添加）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  data-source-proxy-mode: XA<br></code></pre></td></tr></table></figure></li><li>添加全局事务注解<br>在需要的方法上添加@GlobalTransactional(rollbackFor = Exception.class)即可</li></ol><h2 id="Seata之AT模式"><a href="#Seata之AT模式" class="headerlink" title="Seata之AT模式"></a>Seata之AT模式</h2><p>AT模式相比与XA模式提升了性能,在AT模式的架构图中可以看出，AT模式提升性能的主要原因是分支事务在执行完后会直接提交事务，而不是等待其他分支执行完。所以AT模式明显提升了性能。但是由于分支事务执行完后就会直接提交事务，如果当另一个分支事务执行失败时，已经提交完事务的分支事务就无法进行回滚，AT模式显然也考虑到这点，所以使用了快照的方法（其实就是备份）快照会记录分支事务执行前的数据，如果有分支事务失败了，那么就会通过快照进行数据还原，如果所有事务都成功了，则会清楚快照<br><img src="https://pic.imgdb.cn/item/66f11aeaf21886ccc08f391f.png" alt=""><br>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态<br>阶段二提交时RM的工作：</li><li>删除undo-log即可<br>阶段二回滚时RM的工作：</li><li>根据undo-log恢复数据到更新前<br>流程图：<br><img src="https://pic.imgdb.cn/item/66f11c46f21886ccc0905373.png" alt=""><br>注意！！AT模式会有短暂的数据不一致的情况</li></ul><h3 id="AT的实现"><a href="#AT的实现" class="headerlink" title="AT的实现"></a>AT的实现</h3><ol><li>由于需要快照，所以每一个微服务都需要一张单独的表存储快照<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs []">CREATE TABLE IF NOT EXISTS `undo_log`<br>(<br>    `branch_id`     BIGINT       NOT NULL COMMENT &#x27;branch transaction id&#x27;,<br>    `xid`           VARCHAR(128) NOT NULL COMMENT &#x27;global transaction id&#x27;,<br>    `context`       VARCHAR(128) NOT NULL COMMENT &#x27;undo_log context,such as serialization&#x27;,<br>    `rollback_info` LONGBLOB     NOT NULL COMMENT &#x27;rollback info&#x27;,<br>    `log_status`    INT(11)      NOT NULL COMMENT &#x27;0:normal status,1:defense status&#x27;,<br>    `log_created`   DATETIME(6)  NOT NULL COMMENT &#x27;create datetime&#x27;,<br>    `log_modified`  DATETIME(6)  NOT NULL COMMENT &#x27;modify datetime&#x27;,<br>    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)<br>) ENGINE = InnoDB<br>  AUTO_INCREMENT = 1<br>  DEFAULT CHARSET = utf8mb4 COMMENT =&#x27;AT transaction mode undo table&#x27;;<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66f11d77f21886ccc0917f52.png" alt=""></li><li>在Seata的yaml文件中指定XA模式（可以在nacos中添加）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  data-source-proxy-mode: AT<br></code></pre></td></tr></table></figure><h1 id="RequiredArgsConstructor注解"><a href="#RequiredArgsConstructor注解" class="headerlink" title="@RequiredArgsConstructor注解"></a>@RequiredArgsConstructor注解</h1>该注解可以是Lombok所提供的，其主要的作用是简化@Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</li></ol><p>其底层原理是为final的字段生成构造参数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;h2 id=&quot;单体架构&quot;&gt;&lt;a href=&quot;#单体架构&quot; class=&quot;headerlink&quot; title=&quot;单体架构&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="http://example.com/2024/09/07/vue3/"/>
    <id>http://example.com/2024/09/07/vue3/</id>
    <published>2024-09-07T09:53:12.890Z</published>
    <updated>2024-10-09T12:10:36.588Z</updated>
    
    <content type="html"><![CDATA[<p>什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧</p><h1 id="vue3概要"><a href="#vue3概要" class="headerlink" title="vue3概要"></a>vue3概要</h1><p>Vue是一套前端框架，用于简化JavaScript中的DOM操作，简化书写。</p><p>在之前我们也学习过后端的框架MyBatis，MyBatis是用来简化JDBC代码编写的；而Vue是前端框架，简化JavaScript代码编写的</p><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><ol><li>vue3的使用前提需要下载安装好node.js版本要在15.0以上</li><li>在命令窗中输入 npm init vue@laste 即可创建一个初始的vue文件夹</li><li>hello vue<br>值得一提的是每个绑定仅支持单一的js表达式，如{ {n+1} },页面会显示11，{ {ok?yes:no} }，页面会显示ok<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;p&gt;&#123; &#123;meg&#125; &#125;&lt;/p&gt;<br>  &lt;p&gt;&#123; &#123;n+1&#125; &#125;&lt;/p&gt;<br>  &lt;p&gt;&#123; &#123;ok?yes:no &#125; &#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;hello jsp&quot;,<br>          n:10,<br>          ok:true<br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2>v-bind可以简写为 ：<br>v-bind的作用的：可以为元素绑定vue属性<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p v-bind:class=&quot;meg&quot;&gt;测试&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;active&quot;<br><br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66e3a4dad9c307b7e92ffdef.png" alt=""><br>可以在控制台看到 测试的class属性已经绑定成了active</li></ol><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>用于条件判断是否展示元素</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>当meg为true时显示，为false不显示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p v-if=&quot;meg&quot;&gt;这是meg为true&lt;/p&gt;<br>    &lt;p v-else&gt;为false &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;true&quot;<br><br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66e3a631d9c307b7e9316d28.png" alt=""></p><p>多条件语句<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p v-if=&quot;meg === &#x27;A&#x27;&quot;&gt;A&lt;/p&gt;<br>    &lt;p v-else-if=&quot;meg === &#x27;B&#x27;&quot;&gt;B&lt;/p&gt;<br>    &lt;p v-else&gt;D&lt;/p&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>               meg:&quot;B&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br>&lt;style&gt;<br>html&#123;<br>font-size:16px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><br>页面显示B</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>事件处理，用来监听DOM事件，并在事件触发时执行对应的JS语句 ，v-on可简写为@</p><h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><p>每点击一次Add就会触发add()方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>        &lt;button @click=&quot;add&quot;&gt;Add&lt;/button&gt;<br>        &lt;p&gt;&#123; &#123; count &#125; &#125;&lt;/p&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            count:0,<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>       add()&#123;<br>        console.log(this.count)<br>        this.count++<br>       &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><h3 id="方法传参"><a href="#方法传参" class="headerlink" title="方法传参"></a>方法传参</h3><p>点击谁，会在控制台输出谁<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>        &lt;p  @click=&quot;name(item,$event)&quot; v-for=&quot;(item,index) in names&quot;:key=&quot;index&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/p&gt;<br>       <br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            names:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>      name(meg,e)&#123;<br>        console.log(meg)<br>        <br>       &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66ea83f4f21886ccc07e1937.png" alt=""></p><h2 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h2><h3 id="变更数据-可以直接使页面更新"><a href="#变更数据-可以直接使页面更新" class="headerlink" title="变更数据 可以直接使页面更新"></a>变更数据 可以直接使页面更新</h3><p><img src="https://pic.imgdb.cn/item/66ea8741f21886ccc081247d.jpg" alt=""><br>代码案例：点击添加数据，会给meg数组增加一个数据sakura<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>    &lt;button v-on:click=&quot;ADD&quot;&gt;添加数据&lt;/button&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(item,index) in meg&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ADD()&#123;<br>            this.meg.push(&quot;sakura&quot;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击前<br><img src="https://pic.imgdb.cn/item/66ea88fbf21886ccc083ae62.png" alt=""><br>点击后<br><img src="https://pic.imgdb.cn/item/66ea896ef21886ccc0851e99.png" alt=""> </p><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>这个方法不会使前端直接展示<br><img src="https://pic.imgdb.cn/item/66ea89bdf21886ccc0860f13.jpg" alt=""><br>代码案例：点击添加数据，会给meg数组增加一个数据sakura<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>    &lt;button v-on:click=&quot;ADD&quot;&gt;添加数据&lt;/button&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(item,index) in meg&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ADD()&#123;<br>           this.meg.concat([&quot;sakura&quot;])<br>            console.log(this.meg.concat([&quot;sakura&quot;]))<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击后 可以看到页面并没有展示出新添加的数据，但是在控制台可以输出可以看到<br><img src="https://pic.imgdb.cn/item/66ea8ac6f21886ccc089b6fd.png" alt=""></p><p>原因：因为这个方法是新建了一个数组，在原本的数组数据基础上添加新数据，所以将新数据赋值给原本的数组即可<br>将  this.meg.concat([“sakura”]) 改成 this.meg= this.meg.concat([“sakura”]) 即可</p><p>点击后<br><img src="https://pic.imgdb.cn/item/66ea896ef21886ccc0851e99.png" alt=""> </p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>用来监听响应式数据变化，当监听数据变化时可执行一个函数<br>代码示例：meg默认值为hello,当点击按钮时meg的值改为world,watch监听到数据变化时会执行将新数据和老数据打印到控制台的函数<br>注意！！ watch里的函数名称必须与响应式数据名称一样<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>    &lt;button @click=&quot;ischange&quot;&gt;改变数据&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:&quot;hello&quot;<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ischange()&#123;<br>            this.meg=&quot;world&quot;<br>        &#125;<br>    &#125;,<br>    watch:&#123;<br>        meg(newValue,oldValue)&#123;<br>            console.log(newValue,oldValue)<br>        &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66eb99b7f21886ccc07c7b02.png" alt=""></p><div class="note green icon-padding flat"><i class="note-icon fas fa-fan"></i><p>watch 是一个浅度监听，例如watch监听的是一个响应式对象，那么这个对象的属性变化，watch是监听不到的，解决方法有两种，</p><ol><li>在watch的监听方法中指定监听对象的具体属性（下面例子中注释的部分）</li><li>在watch监听方法的末尾添加deep:true,immediate:true；<ul><li>deep:true 是开启深度监听，这样就可以监听到对象的所有属性</li><li>immediate:true 原本watch只有在数据变化时才会监听，开启这个则会立即监听</li></ul></li></ol></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">econst person = ref(&#123;name:&quot;张三”<br>                        age:23<br>&#125;);<br>/*<br> watch(()=&gt;person.value.name,(newValue)=&gt;&#123;<br>console.log(newValue);<br> &#125;)<br> */<br>watch(person,(newValue)=&gt;&#123;<br>console.log(newValue); &#125;,&#123;deep:true,immediate:true&#125;)<br></code></pre></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>进行表单数据双向绑定<br>代码实例：输入框中输入的数据会实时显示在下方<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>   &lt;input type=&quot;text&quot; v-model=&quot;meg&quot;&gt;<br>   &lt;p&gt;实时输入的是&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>                meg:&quot;&quot;,<br>                a: &quot;&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66ebc6bef21886ccc0a5b3b8.png" alt=""></p><h3 id="v-model-lazy"><a href="#v-model-lazy" class="headerlink" title="v-model.lazy"></a>v-model.lazy</h3><p>不加lazy 每输入一个数据都会实时绑定<br>加上lazy 全部输入完数据才会进行绑定</p><h3 id="v-model-number"><a href="#v-model-number" class="headerlink" title="v-model.number"></a>v-model.number</h3><p>只有输入的数字才会进行绑定</p><h3 id="v-moder-trim"><a href="#v-moder-trim" class="headerlink" title="v-moder.trim"></a>v-moder.trim</h3><p>删除数据的前后空格在绑定</p><h1 id="局部引用组件"><a href="#局部引用组件" class="headerlink" title="局部引用组件"></a>局部引用组件</h1><p><img src="https://pic.imgdb.cn/item/66ecd47ef21886ccc088d3e9.jpg" alt=""></p><h1 id="全局引入组件"><a href="#全局引入组件" class="headerlink" title="全局引入组件"></a>全局引入组件</h1><p><img src="https://pic.imgdb.cn/item/66ecd4c1f21886ccc08902a4.jpg" alt=""></p><h1 id="组件传递数据"><a href="#组件传递数据" class="headerlink" title="组件传递数据"></a>组件传递数据</h1><h2 id="父传子-Props"><a href="#父传子-Props" class="headerlink" title="父传子 Props"></a>父传子 Props</h2><p>父组件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;p&gt;父传子&lt;/p&gt;<br>&lt;Props1 :meg=&quot;meg&quot;  :num=&quot;num&quot; :zu=&quot;zu&quot;/&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Props1 from &#x27;./Props1.vue&#x27;;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:&quot;这是Props传的字符串数据&quot;,<br>            num: 20,<br>            zu:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]<br>        &#125;<br>    &#125;,<br>    components:&#123;<br>        Props1<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>子组件接收<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;Props1打印传递的数据&lt;/p&gt;<br>   &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>   &lt;p&gt;&#123; &#123; num &#125; &#125;&lt;/p&gt;<br>   &lt;p v-for=&quot;item in zu&quot;&gt; &#123; &#123; item &#125; &#125;&lt;/p&gt;<br>    &lt;/template&gt;<br>    <br>    &lt;script&gt;<br>    import Props1 from &#x27;./Props1.vue&#x27;;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>            &#125;<br>        &#125;,<br>        props:[&quot;meg&quot;,&quot;num&quot;,&quot;zu&quot;]<br>    &#125;<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><br>结果<br><img src="https://pic.imgdb.cn/item/66ee2ce1f21886ccc0c94ab2.png" alt=""><br>这是局部引用组件，被引用的组件是子组件，子组件接收数据要用props；<br>props可以接收任何形式的数据</p><h2 id="子接收数据校验"><a href="#子接收数据校验" class="headerlink" title="子接收数据校验"></a>子接收数据校验</h2><p>子组件可以规定接收数据的类型，如果父组件传递的类型不是子组件规定的，会报警告<br>利用props中的type<br><img src="https://pic.imgdb.cn/item/66ee2e4ff21886ccc0ca8d10.jpg" alt=""></p><h2 id="子传父-this-emit"><a href="#子传父-this-emit" class="headerlink" title="子传父 this.$emit"></a>子传父 this.$emit</h2><p>子传父利用this.$emit，其实原理是回调父组件的函数<br>先看子组件,子组件利用this.$emit，向父组件传递了一个函数名，和一个新数据<br><img src="https://pic.imgdb.cn/item/66ef879ef21886ccc01c203f.jpg" alt=""><br>父组件用v-on绑定了子组件传过来的函数名和数据，并再methods中实现了。<br><img src="https://pic.imgdb.cn/item/66ef8838f21886ccc01cbc31.jpg" alt=""><br>最后效果<br><img src="https://pic.imgdb.cn/item/66ef88c3f21886ccc01d7994.jpg" alt=""></p><h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><p>多个组件之间来回切换,需要用到 <component :is=""></component><br>简单实例：创建3个组件A,B,C;默认在C组件中展示A，当点击按钮后切换成B<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;组件A&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;组件B&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;component :is=&quot;change&quot;&gt;&lt;/component&gt;<br>    &lt;button @click=&quot;changeHandle&quot;&gt;切换组件&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import A from &#x27;@/components/A.vue&#x27;<br>import B from &#x27;@/components/B.vue&#x27;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            change: &quot;A&quot;<br>        &#125;<br>    &#125;,<br>    components:&#123;<br>        A,<br>        B<br>    &#125;,<br>    methods:&#123;<br>        changeHandle()&#123;<br>            this.change=this.change== &quot;A&quot;?&quot;B&quot;:&quot;A&quot;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击前<br><img src="https://pic.imgdb.cn/item/66f22aeaf21886ccc06a4931.png" alt=""><br>点击后<br><img src="https://pic.imgdb.cn/item/66f22b0bf21886ccc06a5fd9.png" alt=""></p><h2 id="组件存活"><a href="#组件存活" class="headerlink" title="组件存活"></a>组件存活</h2><p>使用 <component :is=""></component> 后，切换组件，原来的组件就会被销毁，如果再次切换到原来的组件，只是重新加载了这个组件的生命周期<br>例如 将A更改一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;组件A&lt;/p&gt;<br>    &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>    &lt;button @click=&quot;change&quot;&gt;更新数据&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg: &quot;老数据&quot;<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        change()&#123;<br>            this.meg=this.meg==&quot;老数据&quot;?&quot;新数据&quot;:&quot;老数据&quot;<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>再来看点击前<br><img src="https://pic.imgdb.cn/item/66f22c61f21886ccc06b667e.png" alt=""><br>先点击更新数据,会展示新数据<br><img src="https://pic.imgdb.cn/item/66f22ccbf21886ccc06bb228.png" alt=""><br>然后在点击两次切换组件 让他切换到A<br><img src="https://pic.imgdb.cn/item/66f22d07f21886ccc06be4c6.png" alt=""><br>会发现组件A的数据变成了老数据，说明组件A在被切换后被销毁了，再次切换回来只是重新加载了一边生命周期<br>如果需要组件存活 需要用到<keep-alive><br><img src="https://pic.imgdb.cn/item/66f22dbbf21886ccc06c71c4.png" alt=""><br>这样就可以了</p><h1 id="axios发起请求"><a href="#axios发起请求" class="headerlink" title="axios发起请求"></a>axios发起请求</h1><p>axios用于前端发送请求到后端</p><ul><li>安装 axios的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">import axios from &#x27;axios&#x27;;<br></code></pre></td></tr></table></figure>baseURL用来记录转发的目的地路径，可以是具体路径192.168.217.168等，这里写的是api因为会发生跨域<br>instance = axios.create({baseURL})是创造一个axios的实例，实例会有很多功能如图<br><img src="https://pic.imgdb.cn/item/66f3c86bf21886ccc0c266af.png" alt=""><br><img src="https://pic.imgdb.cn/item/66f3c829f21886ccc0c20e4c.png" alt=""><br>简单使用：我这里使用的request是因为 axios的导入和URL，instance都是在request中的，所以方便一些<br><img src="https://pic.imgdb.cn/item/66f3c930f21886ccc0c35c53.png" alt=""></li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域指挥发生在浏览器中，浏览器不能将前端5173端口的请求转发到另一个端口上，但是可以又5173前端端口转发到后端<br>所以axios的URL不建议直接写后端的端口地址，会发生跨域问题<br><img src="https://pic.imgdb.cn/item/66f3c9f8f21886ccc0c42164.jpg" alt=""><br>解决：</p><ul><li>使用代理模式<br>指定URL 例如api,这样前端会把请求发送到前端 5173/api的接口中，然后利用代理，会将地址改变<br>target ：改变的api前面的路径端口等<br>changeOrigin : 是否开启代理<br>rewrite : 可以将api替换成空格<br>最后结果 http：//local host：5173/api 会代理成 http：//local host：8080/<br><img src="https://pic.imgdb.cn/item/66f3caaaf21886ccc0c4d5ea.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/66f3cbccf21886ccc0c5ca6b.jpg" alt=""></li></ul><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由帮助我们跳转页面 例如点击登录后跳转到主页面</p><ol><li>安装<br>执行命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">npm install vue-router@latest<br></code></pre></td></tr></table></figure></li><li>创造路由并导入<br>可以看到我们新建了router文件夹下面的index.js<br><img src="https://pic.imgdb.cn/item/66f3d105f21886ccc0ca45bb.png" alt=""></li></ol><ul><li>首先导入vue-router,和导入组件</li><li>需要定义路由关系</li><li>创建路由，并把路由关系指定给路由</li><li>导出路由<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">//导入vue-router<br>import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;<br>//导入组件<br>import LoginVue from &#x27;@/views/Login.vue&#x27;<br>import LayoutVue from &#x27;@/views/Layout.vue&#x27;<br><br>//定义路由关系<br>const routes = [<br>    &#123; path: &#x27;/login&#x27;, component: LoginVue &#125;,<br>    &#123; path: &#x27;/&#x27;, component: LayoutVue &#125;<br>]<br><br>//创建路由器<br>const router = createRouter(&#123;<br>    history: createWebHistory(),<br>    routes: routes<br>&#125;);<br><br>export default router<br></code></pre></td></tr></table></figure></li></ul><ol><li>将路由配置全局<br>在main.js文件中导入路由并挂载<br><img src="https://pic.imgdb.cn/item/66f3d1cbf21886ccc0cb30f0.png" alt=""></li><li>在根组件中使用路由标签挂载<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;router-view&gt;&lt;/router-view&gt;<br></code></pre></td></tr></table></figure></li><li>在需要跳转的函数或按钮中添加路由<br><img src="https://pic.imgdb.cn/item/66f3d250f21886ccc0cbade0.png" alt=""></li></ol><h2 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h2><p>子路由可以控制主页面都一部分的内容改变<br>例如：点击左侧，中间内容会改变<br><img src="https://pic.imgdb.cn/item/66f3d63df21886ccc0cee10d.png" alt=""></p><p>实现：</p><ol><li>配置路由关系<br>在原来的路由关系中，导入组件，并定义子路由关系<br><img src="https://pic.imgdb.cn/item/66f3d69af21886ccc0cf2726.png" alt=""></li><li>在分类菜单中加入对应的路由<br>index是因为路由关系在我的index.js文件夹中<br><img src="https://pic.imgdb.cn/item/66f3d6f8f21886ccc0cf780f.png" alt=""></li><li>在需要展示的页面中的中间部份用路由标签挂载</li></ol><h1 id="pinia-携带请求头"><a href="#pinia-携带请求头" class="headerlink" title="pinia 携带请求头"></a>pinia 携带请求头</h1><p>一般登录成功后后端会传来一个token,用来确定身份，登陆后其他请求也都需要token验证</p><ol><li>安装<br>执行命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">npm install pinia<br></code></pre></td></tr></table></figure></li><li>pinia导入全局<br><img src="https://pic.imgdb.cn/item/66f3dcd2f21886ccc0d61a2a.png" alt=""></li><li>定义store<br><img src="https://pic.imgdb.cn/item/66f3dd06f21886ccc0d648f6.png" alt=""></li><li>组件中使用store<br><img src="https://pic.imgdb.cn/item/66f3dd33f21886ccc0d69189.png" alt=""></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧&lt;/p&gt;
&lt;h1 id=&quot;vue3概要&quot;&gt;&lt;a href=&quot;#vue3概要&quot; class=&quot;headerlink&quot; title=&quot;vue3概要&quot;&gt;&lt;/a&gt;vue3概要&lt;/h1&gt;&lt;p&gt;Vue是一套前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/"/>
    <id>http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/</id>
    <published>2024-09-07T07:10:34.612Z</published>
    <updated>2024-09-09T13:14:35.219Z</updated>
    
    <content type="html"><![CDATA[<p>每次学新东西，就想到当初选JAVA后端，我就想扇自己<br>一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了<br>虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦<br>为什么不能docker一键安装docker呢</p><h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>Docker是一款应用容器引擎，可以帮助我们快速部署和搭建<br>Docker需要在Linux环境下运行，所以需要虚拟机搭建环境</p><p>使用Docker的前提当然是搭建虚拟机了<br>具体安装虚拟机和Docker可看<a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d</a></p><h2 id="基于Docker安装mysql"><a href="#基于Docker安装mysql" class="headerlink" title="基于Docker安装mysql"></a>基于Docker安装mysql</h2><p>只需要一条命令即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d \</span><br><span class="line">&gt;   --name mysql \</span><br><span class="line">&gt;    -p 3306:3306 \</span><br><span class="line">&gt;    -e TZ=Asia/Shanghai \</span><br><span class="line">&gt;    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">&gt;    mysql</span><br></pre></td></tr></table></figure><br><img src="https://t.tutu.to/img/0mlwr" alt=""><br>以上就是Docker安装mysql，真是太简单了，我大一安装mysql可是一直出错，安装了一整天了<br>Docker安装部署这么容易是因为Docker下载的是已经部署好的mysql镜像，而且Docker运行这些镜像的时候<br>会创建一个隔离环境，称为容器。所以同时运行多个镜像也是可以的<br>正是因为如此Docker可以解决依赖兼容问题<br><img src="https://pic.imgdb.cn/item/639872ecb1fccdcd3695de9e.jpg" alt=""></p><h2 id="Docker的常见命令"><a href="#Docker的常见命令" class="headerlink" title="Docker的常见命令"></a>Docker的常见命令</h2><ol><li>docker run 创建并运行镜像</li><li>-d 让镜像在后台运行<br>如果不加 -d 镜像会在控制台执行，不能进行其他操作直到停止</li><li>-p 端口映射<br>因为我们的Docker是在Linux虚拟机上部署的，假设虚拟机的IP是192.168.150.101.<br>Docker运行镜像会创建单独的容器，其实这个容器也是有IP地址的，但是我们直接访问容器的IP会失败<br>所以会进行映射，通过访问虚拟机的IP端口映射到容器的IP端口<br><img src="https://t.tutu.to/img/0mtW6" alt=""></li><li>-e 设置环境变量 格式为 KEY=VALUE<br>具体的环境变量需要查看Docker的镜像官网</li><li>—name 设置镜像的名称</li><li>docker pull 从镜像仓库拉取镜像到本地仓库</li><li>docker images 查看本地镜像</li><li>docker rmi 删除本地镜像</li><li>docker push 将本地镜像推送到镜像仓库</li><li>docker stop 停止容器</li><li>docker start 启动容器</li><li>docker ps 查看容器运行状态</li><li>docker rm 删除容器</li><li>docker exec -it 容器名 bash 通过命令行操作容器</li></ol><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><ol><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录的之间映射的桥梁；<br>数据卷解决的问题：docker为我们下载的镜像文件只包含了该文件运行所需要的依赖环境，<br>所以如果我们通过docker exec -it 容器名 bash命令进入该容器去操作容器内文件时，<br>会发现容器内并没有 vi 等操作文件的命令，所以我们不能在容器里操作容器里的文件<br>因此数据卷可以为我们解决这个问题<br>解决的原理     ：数据卷可以进行双向映射，创建数据卷目录，然后分别对应容器中的目录和<br>虚拟机docker中的目录，映射成功后，通过操作虚拟机中的目录就可以达到操作容器目录的效果<br>数据卷对应的虚拟机目录一般都在volume目录下<br><img src="https://pic.imgdb.cn/item/66dd5deed9c307b7e9d22582.png" alt=""> <h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><img src="https://pic.imgdb.cn/item/66dd5f38d9c307b7e9d538f6.png" alt=""><h2 id="数据卷映射目录"><a href="#数据卷映射目录" class="headerlink" title="数据卷映射目录"></a>数据卷映射目录</h2>docker run -v 数据卷名（自定义）：容器目录</li><li>docker run 是创造并执行容器，所以如果一个容器已经被创造，但是没有挂载数据卷，即就不能挂载数据卷或者会自动挂载一个匿名卷</li><li>如果执行该命令的时候数据卷不存在，会自动创建，数据卷会和虚拟机volums目录下和数据卷同名的文件目录自动挂载，<h2 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h2>使用命令：docker run -v 本地目录（自定义）：容器目录</li><li>本地目录必须以 / 或者 ./开头</li><li>和数据卷挂载的区别：直接将本地目录 和容器目录挂载，本地目录不需要是在volume目录下<h3 id="本地挂载mysql"><a href="#本地挂载mysql" class="headerlink" title="本地挂载mysql"></a>本地挂载mysql</h3></li><li>创建对应的文件夹<br><img src="https://pic.imgdb.cn/item/66deb3c1d9c307b7e9dd1fc9.png" alt=""></li><li>将提前准备好的sql语句脚本和dockerfile文件导入mysql文件夹</li><li>运行命令<br>记得前提把上面示例创造的mysql容器删除，不然会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66deb4b5d9c307b7e9de2474.png" alt=""><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3>镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。</li></ol><h3 id="docker镜像的结构"><a href="#docker镜像的结构" class="headerlink" title="docker镜像的结构"></a>docker镜像的结构</h3><ol><li>基础镜像是通用的，因为是分层结构，所以其他镜像也可以使用<br><img src="https://pic.imgdb.cn/item/66dd7842d9c307b7e9ff4976.png" alt=""></li><li>设置镜像结构 Dockerfile<br><img src="https://pic.imgdb.cn/item/66dd7934d9c307b7e901e387.png" alt=""><h3 id="尝试自定义镜像"><a href="#尝试自定义镜像" class="headerlink" title="尝试自定义镜像"></a>尝试自定义镜像</h3></li><li>编写Dockerfile<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像</span><br><span class="line">FROM openjdk:11.0-jre-buster</span><br><span class="line"># 设定时区</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"># 拷贝jar包</span><br><span class="line">COPY docker-demo.jar /app.jar</span><br><span class="line"># 入口</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure></li><li>将准备好的demo.jar和Dockerfile上传到虚拟机中</li><li>执行 docker build -t docker-demo .<br>-t :给镜像命名<br>. :表示当前路径，如果不在上传的demo文件下，需要指定demo的位置</li><li>执行 docker run -d —name dd -p 8080:8080 docker-dome<br><img src="https://pic.imgdb.cn/item/66dd7b60d9c307b7e90673d4.png" alt=""><br>如图成功，访问8080端口<br><img src="https://pic.imgdb.cn/item/66dd7bc7d9c307b7e906e7ab.png" alt=""></li></ol><h2 id="容器网络互联"><a href="#容器网络互联" class="headerlink" title="容器网络互联"></a>容器网络互联</h2><p>如果在创建容器的时候没有指定网段IP，docker会通过网桥自动分配给容器一个IP，但是容器关闭后，这个IP会被分配给其他容器<br><img src="https://pic.imgdb.cn/item/66deb600d9c307b7e9df983f.png" alt=""></p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>加入自定义网络的容器可以通过容器名互相访问<br><img src="https://pic.imgdb.cn/item/66deb669d9c307b7e9e00690.png" alt=""><br>创建自定义网络 hmall<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create hmall</span><br></pre></td></tr></table></figure><br>使mysql处于自定义网络中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect hmall mysql</span><br></pre></td></tr></table></figure></p><h2 id="部署JAVA应用"><a href="#部署JAVA应用" class="headerlink" title="部署JAVA应用"></a>部署JAVA应用</h2><ol><li>对JAVA应用打包，将写好的dockerfile和jar导入虚拟机root目录下<br><img src="https://pic.imgdb.cn/item/66deba94d9c307b7e9e842f0.png" alt=""></li><li>构建镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hmall .</span><br></pre></td></tr></table></figure></li><li>创造运行容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hmall --network hmall -p 8080:8080 hmall</span><br></pre></td></tr></table></figure>本地浏览器访问<br><img src="https://pic.imgdb.cn/item/66debb41d9c307b7e9ea3f41.png" alt=""><h2 id="部署前端应用"><a href="#部署前端应用" class="headerlink" title="部署前端应用"></a>部署前端应用</h2>emmm~,这个最后一步一直报错 404，花了一下无，给我气红温了，就先跳过了<h2 id="一键部署DockerCompose"><a href="#一键部署DockerCompose" class="headerlink" title="一键部署DockerCompose"></a>一键部署DockerCompose</h2>DockerCompose是通过一个单独的YAML格式的文件来定义一组相关联的应用容器，帮<br>助我们实现多个相互关联的Docker容器的快速部署。<br>右边即是YAML格式的容器等同于左边<br><img src="https://pic.imgdb.cn/item/66def3b0d9c307b7e94885ac.png" alt=""><br><img src="https://pic.imgdb.cn/item/66def40ad9c307b7e949b63a.png" alt=""><br>将准备好的YAML文件传入虚拟机中，再执行 docker compose up 即可一键部署</li></ol><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>Docker并不作为JAVA后端的一个重点，再加上最近有些浮躁，很难静下心来，所以学的有点粗糙，<br>也想早点开启下一章微服务的学习<br>Docker就作为了解吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每次学新东西，就想到当初选JAVA后端，我就想扇自己&lt;br&gt;一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了&lt;br&gt;虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦&lt;br&gt;为什么不能docker一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MybatisPlus</title>
    <link href="http://example.com/2024/09/06/MybatisPlus/"/>
    <id>http://example.com/2024/09/06/MybatisPlus/</id>
    <published>2024-09-06T05:46:45.235Z</published>
    <updated>2024-09-07T10:28:42.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识MybatisPlus"><a href="#初识MybatisPlus" class="headerlink" title="初识MybatisPlus"></a>初识MybatisPlus</h1><p>MybatisPlus的特点</p><ol><li>可以对现有工程只做增强不做改变，引入MybatisPlus后Mybatis的代码依旧可以使用</li><li>方便快捷实现对单表的增删改查</li><li>功能丰富 例如 代码生成，自动分页，自动填充<h2 id="使用MybatisPlus"><a href="#使用MybatisPlus" class="headerlink" title="使用MybatisPlus"></a>使用MybatisPlus</h2></li><li>引入MybatisPlus<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>自定义的Mapper 继承MybatisPlus提供的BaseMapper<br> 注意：BaseMapper需要指定实体类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MybatisPlus的常用注解"><a href="#MybatisPlus的常用注解" class="headerlink" title="MybatisPlus的常用注解"></a>MybatisPlus的常用注解</h2></li><li>@TableName : 用于指定表名<br>当实体类名和数据库表名不一致的时候使用</li><li>@TableId :用于指定表中的主键字段信息<br>可以指定主键的憎长类型，共有三种，（AUTO）数据库自增长，(INPUT)get方式输入,（ASSIGN_ID）自带的雪花算法<br>若不指定则默认为yaml配置的方式</li><li>@TableFieId :用于指定表中的普通字段信息<br>直接上图<br><img src="https://www.helloimg.com/i/2024/09/04/66d81e5d52204.png" alt=""></li></ol><h2 id="MybatisPlus的配置"><a href="#MybatisPlus的配置" class="headerlink" title="MybatisPlus的配置"></a>MybatisPlus的配置</h2><p><img src="https://www.helloimg.com/i/2024/09/04/66d820a887981.png" alt=""></p><h1 id="MybatisPlus的条件构造器"><a href="#MybatisPlus的条件构造器" class="headerlink" title="MybatisPlus的条件构造器"></a>MybatisPlus的条件构造器</h1><p>MybatisPlus提供了三种条件构造器</p><ol><li>QueryWrapper<br>提供了很多关于查询的条件方法,方法很多就不一一展示了，通过一个示例简单说明一下<br><img src="https://www.helloimg.com/i/2024/09/04/66d826f608f60.png" alt=""><br>将图中sql可简化为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper queryWrapper = new QueryWrapper&lt;User&gt;()</span><br><span class="line">             .select(&quot;id&quot;,&quot;username&quot;,&quot;info&quot;,&quot;balance&quot;).like(&quot;username&quot;,&quot;o&quot;)</span><br><span class="line">             .gt(&quot;blance&quot;,1000);</span><br><span class="line"></span><br><span class="line">      List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure></li><li>UpdateWrapper<br>提供了更新的条件方法<br><img src="https://www.helloimg.com/i/2024/09/04/66d82981d5053.png" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;()</span><br><span class="line">             .setSql(&quot;balance =balance - 200&quot;).in(&quot;id&quot;,&quot;1,2,4&quot;);</span><br><span class="line"></span><br><span class="line">     userMapper.update(null,updateWrapper);</span><br></pre></td></tr></table></figure><img src="https://www.helloimg.com/i/2024/09/04/66d8262a6963d.png" alt=""></li></ol><h1 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h1><p><img src="https://www.helloimg.com/i/2024/09/05/66d966d0eb1d4.png" alt=""><br>MybatisPuls提供了IService接口更帮助我们实现对单表的增删改查<br>使用IService接口需要两步</p><ol><li>自定义的XXXService接口去继承Iservice接口</li><li>XXXService的实现类XXXServiceImpl实现Service的同时也要继承IService的实现类<br>注意！！ XXXServiceImpl继承IService的实现类的时候需要给IService的实现类两个参数</li><li>第一个参数所对应的Mapper接口，因为在IService的实现类里面是需要引入对应的mapper<br> 即IService里面很多方法底层还是通过MybatisPuls提供的Mapper的方法实现</li><li>第二个参数为对应的实体对象<br>例如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService extends IService&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IService的应用"><a href="#IService的应用" class="headerlink" title="IService的应用"></a>IService的应用</h2>IService提供更多的方法供我们使用，同样这么多方法也就不一一介绍了<br>值得一提的是IService提供的批量插入方法saveBeach方法<br>假设我们需要像数据库中插入10000条数据</li><li>单条数据插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void test1() &#123;</span><br><span class="line">        long a =System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt;10000 ; i++) &#123;</span><br><span class="line">            Test1 test =new Test1();</span><br><span class="line">            test.setUser(i);</span><br><span class="line">            test.setName(&quot;test&quot;+i);</span><br><span class="line">            tsetService.save(test);</span><br><span class="line">        &#125;</span><br><span class="line">        long b =System.currentTimeMillis();</span><br><span class="line">        System.out.println(b-a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>最后耗时10180毫秒</li><li>批量插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void test2() &#123;</span><br><span class="line">        long a =System.currentTimeMillis();</span><br><span class="line">        List&lt;Test1&gt; list =new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;10000 ; i++) &#123;</span><br><span class="line">            Test1 test =new Test1();</span><br><span class="line">            test.setUser(i);</span><br><span class="line">            test.setName(&quot;test&quot;+i);</span><br><span class="line">            list.add(test);</span><br><span class="line">            if (list.size()==100) &#123;</span><br><span class="line">                tsetService.saveBatch(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long b =System.currentTimeMillis();</span><br><span class="line">        System.out.println(b-a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>最后耗时264毫秒，显著提升了50倍速度！！！<br>当然啦这还不是最快的</li><li>MYSQL的rewriteBatchedStatements=true<br>在配置数据库的url后面添加rewriteBatchedStatements=true 即可<br>代码与上面代码相同不变<br>最后耗时202毫秒，由于我直插入了10000条数据所以性能不明显，数据越多明显越大</li></ol><p>最后再来说一下rewriteBatchedStatements=true的作用</p><ol><li>如果不加，我们操作会是将一千条数据封装到list中，由list传入数据库，然后每一条数据执行一次insert语句<br>所以提升速度的原因是减少了连接数据库的次数</li><li>加上rewriteBatchedStatements=true后，list传入后数据库只需要执行一次insert语句，因为者一千条数据会进行拼接</li></ol><h2 id="DB静态工具"><a href="#DB静态工具" class="headerlink" title="DB静态工具"></a>DB静态工具</h2><p>介绍之前先看几个需求,前置条件，用户和地址是两个表，用外键链接<br><img src="https://www.helloimg.com/i/2024/09/06/66db1b101f551.png" alt=""><br>根据已经学习到的知识，如果我们想解决第一个问题就需要</p><ol><li>在UserService中不仅仅调用自己的IService提供的方法，也需要调用AddressService<br>(当然啦也可以调用AddressMapper)</li><li>解决第三个问题呢就需要在AddressService中调用UserService,这样互相调用的话，业务复杂<br>很多个Service层或者Mapper互相调用很大可能会造成循环依赖<br>为了解决循环依赖问题，MybatisPlus提供了DB静态工具(注意：需要3.5.0版本以上)</li><li>DB提供了和IService几乎一摸一样的方法 不过在调用DB的时候需要将所对应的实体类传入<br>利用DB解决问题1<br><img src="https://www.helloimg.com/i/2024/09/06/66db2070aef10.png" alt=""></li></ol><h2 id="JOSN处理器"><a href="#JOSN处理器" class="headerlink" title="JOSN处理器"></a>JOSN处理器</h2><p>作用：如果数据库表中有字段类型为JOSN时，可以使用Mybatis提供的JOSN处理器，简化开发<br>普通方法我会用一个String类型的变量去接收 表中JOSN类型的字段，但是这样后续业务处理比较麻烦<br>使用JSON处理器可以解决这个问题，需要三步</p><ol><li>定义一个表中JOSN类型字段锁对应的实体类，用这个实体类类型的变量去接收</li><li>同时需要使用@TableFiled中添加JOSN处理器 即typeHandler=JacksonTypeHandler.class</li><li>在@TableName中加上 autoResultMap =true 返回映射<br><img src="https://www.helloimg.com/i/2024/09/07/66dbc04951e2e.png" alt=""></li></ol><h2 id="MybatisPlus的分页功能"><a href="#MybatisPlus的分页功能" class="headerlink" title="MybatisPlus的分页功能"></a>MybatisPlus的分页功能</h2><p>MybatisPlus提供了很多拓展功能其中较为常用的就是分页功能</p><ol><li><p>分页功能的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisConfig &#123;</span><br><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">    // 1.初始化核心插件</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    // 2.添加分更插件 和指定数据库类型</span><br><span class="line">    PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MysOL)</span><br><span class="line">    pageInterceptor.setMaxLimit(1000L);//设置分页上限</span><br><span class="line">    interceptor.addInnerInterceptor(pagenterceptor);</span><br><span class="line">    return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解：先new一个MybatisPlus的拦截器对象，在new一个分页对象并设置初始值添加到拦截器中</p></li><li><p>分页功能的基本使用</p><ol><li>这是简单封装了一个PageVO,用于处理分页查询后的数据，方便返回前端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pubilc class PageVO&lt;T&gt;&#123;</span><br><span class="line">    public Ingter pages;</span><br><span class="line">    public Ingter total;</span><br><span class="line">    public List&lt;T&gt; list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>简单使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public PageVO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;</span><br><span class="line">    String name = query.getName();</span><br><span class="line">    Integer status = query.getstatus();</span><br><span class="line">    //1.构建分页条件</span><br><span class="line">    // 1.1.分页条件 Page.of()需要两个参数 一个当前的页数，一个每页查询的数据量</span><br><span class="line">    Page&lt;User&gt;page = Page.of(query.getPageNo(),query.getPagesize());</span><br><span class="line">    // 1.2.排序条件</span><br><span class="line">    page.addorder(new orderItem(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    //1 2.分页查询</span><br><span class="line">    Page&lt;User&gt; p=lambdaQuery()</span><br><span class="line">    .like( condition: name != null, User::getUsername, name)</span><br><span class="line">    .eq( condition: status != null, User::getstatus, status)</span><br><span class="line">    .page(page);</span><br><span class="line">    // 处理数据</span><br><span class="line">    PageVO(UserVO)  pagevo =new PageVO()</span><br><span class="line">    pagevo.setPages(p.getPages);</span><br><span class="line">    pagevo.setTotal(p.getTotal);</span><br><span class="line">    List&lt;User&gt; list = p.getRecords();</span><br><span class="line">    List&lt;UserVO&gt; vo= BeanUtil.copyToList(list,UserVo.class)</span><br><span class="line">    pagevo.setlist(vo);</span><br><span class="line">    return pagevo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上就是一个分页查询用户的简单例子<br>在实际功能中 构建分页条件 排序条件 处理数据 这三个步骤在多次分页中代码基本相同<br>所以其实可以将这几部分代码抽取成三个工具类，使用到这几个步骤的时候直接调用对应的工具类</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识MybatisPlus&quot;&gt;&lt;a href=&quot;#初识MybatisPlus&quot; class=&quot;headerlink&quot; title=&quot;初识MybatisPlus&quot;&gt;&lt;/a&gt;初识MybatisPlus&lt;/h1&gt;&lt;p&gt;MybatisPlus的特点&lt;/p&gt;
&lt;ol&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis学习</title>
    <link href="http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-03T02:34:21.000Z</published>
    <updated>2024-10-07T09:23:23.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis雪崩"><a href="#redis雪崩" class="headerlink" title="redis雪崩"></a>redis雪崩</h1><p>  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>  对key的过期时间进行调整，防止大量key同时失效，最简单的方法对key的过期时间统一成 固定时间+random</p><h1 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h1><p>   缓存击穿是指一个非常 “热” 的 key（通常是被频繁访问的数据）在某个时间点过期，此时若有大量并发请求过来，这些请求发现缓存中没有数据，就会同时去数据库查询该数据，对数据库造成巨大的压力。</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><pre><code>在高并发下，只有获取锁成功的线程才会去查询数据库，并更新缓存，其他线程则等待一段时间。</code></pre><h4 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h4><p>   利用redis中的nx命令自定义实现锁<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA,自定义锁]">public Boolean trylock(String key)&#123;<br>    Boolean falg = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.MINUTES);<br>    return BooleanUtil.isTrue(falg);<br>&#125;<br>public void unlock(String key)&#123;<br>    stringRedisTemplate.delete(key);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><pre><code>当一个线程执行到这里时，会先从缓存中查询，则会先进入StrUtil.isNotBlank(s)判断，StrUtil.isNotBlank()的作用为判断是否字符串是否不为空且不为仅包含空白字符的方法；如果为true,则说明缓存中存在且不为空，直接返回。如果为false，则说明缓存中不存在或者值为空，即进入下一个判断，如果是s！=null为true，说明缓存中存在s,但是s的值为空所以返回null,当s！=null为false后尝试获取锁，获取锁失败则等待重试，获取锁成功则查询数据库，如果数据库中存在则写入缓存中，如果不存在则向缓存中写入空值，这样可以保证在高并发的情况下只有获取锁成功的线程会访问数据库</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]">public Shop queryWithMutex(Long id) &#123;<br>    String key = RedisConstants.CACHE_SHOP_KEY + id;<br>    //从redis中查询<br>    String s = stringRedisTemplate.opsForValue().get(key);<br>    if (StrUtil.isNotBlank(s)) &#123;<br>        return JSONUtil.toBean(s, Shop.class);<br>    &#125;<br>    //判断是否为空值<br>    if (s != null) &#123;<br>        return null;<br>    &#125;<br>    //不存在尝试获取锁<br>    String lockkey = &quot;lock:shop:&quot; + id;<br>    Boolean islock = trylock(lockkey);<br>    Shop shop=null;<br>    try &#123;<br>        //获取锁不成功则等待反复尝试<br>        if (!islock) &#123;<br>            Thread.sleep(50);<br>            return queryWithMutex(id);<br>        &#125;<br>        //如果不存在查询数据库<br>        shop = getById(id);<br>        //模拟实际<br>        Thread.sleep(200);<br>        if (shop != null) &#123;<br>            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL);<br>        &#125;<br>        //如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库<br>        else &#123;<br>            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL);<br>            return null;<br>        &#125;<br><br>    &#125; catch (Exception e) &#123;<br>        throw new RuntimeException(e);<br>    &#125; finally &#123;<br>        unlock(lockkey);<br>    &#125;<br>    return shop;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><pre><code>设置逻辑过期时间，这样可以保证key永远存在，只需要判断是否逻辑过期进行更形即可</code></pre><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>  查询一个一定不存在的数据，由于缓存中没有该数据，所有的请求都会落到数据库上，导致数据库压力瞬间增大。如果有人利用这个漏洞不断发起这种查询，就可能使数据库因承受不住大量请求而崩溃。</p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-添加NULL值"><a href="#1-添加NULL值" class="headerlink" title="1 添加NULL值"></a>1 添加NULL值</h3><p><img src="https://www.helloimg.com/i/2024/09/03/66d6b0ae1fcda.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]">public Shop redisPassThrought(Long id) &#123;<br>        String key =RedisConstants.CACHE_SHOP_KEY+id;<br>        //从redis中查询<br>        String s= stringRedisTemplate.opsForValue().get(key);<br>        if (StrUtil.isNotBlank(s)) &#123;<br>            return JSONUtil.toBean(s,Shop.class);<br>        &#125;<br>        //判断是否为空值<br>        if (s!=null)&#123;<br>            return null;<br>        &#125;<br>        //如果不存在查询数据库<br>        Shop shop =getById(id);<br>        if (shop != null)&#123;<br>            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL);<br>        &#125;<br>        //如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库<br>        else &#123; stringRedisTemplate.opsForValue().set(key,&quot;&quot;,RedisConstants.CACHE_NULL_TTL);<br>            return null;<br>        &#125;<br>        return shop;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h1 id="Redis分布式锁-："><a href="#Redis分布式锁-：" class="headerlink" title="Redis分布式锁 ："></a>Redis分布式锁 ：</h1><h2 id="1-自定义分布式锁："><a href="#1-自定义分布式锁：" class="headerlink" title="1 自定义分布式锁："></a>1 自定义分布式锁：</h2><pre><code>  调用该方法的时候需要new一个RedisLock的对象，并传入两个需要的参数key</code></pre><h3 id="原理-："><a href="#原理-：" class="headerlink" title="原理 ："></a>原理 ：</h3><pre><code> 利用Redis中的NX命令判断是否存在，不存在则创建，存在创建会失败  注意 ： 返回值是Boolean类型时,不建议直接返回对象success，自动拆箱可能会空指针</code></pre><p>自定义分布式锁：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs []">public class SimpleRedisLock implements ILock &#123;<br>    //锁的前缀<br>    private static final String KEY_PREFIX = &quot;lock:&quot;;<br>    //具体业务名称，将前缀和业务名拼接之后当做Key<br>    private String name;<br>    //这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入<br>    private StringRedisTemplate stringRedisTemplate;<br><br>    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) &#123;<br>        this.name = name;<br>        this.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    @Override<br>    public boolean tryLock(long timeoutSec) &#123;<br>        //获取线程标识<br>        long threadId = Thread.currentThread().getId();<br>        //获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁<br>        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);<br>        //自动拆箱可能会出现null，这样写更稳妥<br>        return Boolean.TRUE.equals(success);<br>    &#125;<br><br>    @Override<br>    public void unlock() &#123;<br>        //通过DEL来删除锁<br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>业务逻辑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs []">@Override<br>public Result seckillVoucher(Long voucherId) &#123;<br>    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();<br>    //1. 查询优惠券<br>    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);<br>    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);<br>    //2. 判断秒杀时间是否开始<br>    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;<br>        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);<br>    &#125;<br>    //3. 判断秒杀时间是否结束<br>    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;<br>        return Result.fail(&quot;秒杀已经结束！&quot;);<br>    &#125;<br>    //4. 判断库存是否充足<br>    if (seckillVoucher.getStock() &lt; 1) &#123;<br>        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);<br>    &#125;<br>    Long userId = UserHolder.getUser().getId();<br>    // 创建锁对象<br>    SimpleRedisLock redisLock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);<br>    // 获取锁对象<br>    boolean isLock = redisLock.tryLock(120);<br>    // 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）<br>    if (!isLock) &#123;<br>        return Result.fail(&quot;不允许抢多张优惠券&quot;);<br>    &#125;<br>    try &#123;<br>        // 获取代理对象<br>        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();<br>        return proxy.createVoucherOrder(voucherId);<br>    &#125; finally &#123;<br>        // 释放锁<br>        redisLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h4><ol><li><p>逻辑说明<br>持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放<br>此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到<br>但是现在线程1阻塞完了，继续往下执行，要开始释放锁了<br>那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</p></li><li><p>解决方案<br>解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。<br>假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁<br><img src="https://www.helloimg.com/i/2024/09/04/66d87a2c99d06.png" alt=""></p><h4 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]">      public class RedisLock &#123;<br>    private static  final  String KEY_PREFIX = UUID.randomUUID().toString(true)+&quot;-&quot;;<br>    private String key;<br>    private StringRedisTemplate redisTemplate;<br><br>    public RedisLock(String key, StringRedisTemplate redisTemplate) &#123;<br>        this.key = key;<br>        this.redisTemplate = redisTemplate;<br>    &#125;<br><br><br>    public boolean tryLock(Long timeout) &#123;<br>        //获取锁的时候将该线程标识（UUID+线程Id）存入缓存中，释放锁是判断，防止误删<br>       String threadId = KEY_PREFIX +Thread.currentThread().getId();<br>       Boolean success= redisTemplate.opsForValue().setIfAbsent(key, threadId , timeout, TimeUnit.SECONDS);<br>       return Boolean.TRUE.equals(success);<br>    &#125;<br><br>    public void unlock() &#123;<br>        String threadId = KEY_PREFIX +Thread.currentThread().getId();<br>         String id = redisTemplate.opsForValue().get(key);<br>         if(threadId.equals(id)) &#123;<br>             redisTemplate.delete(key);<br>         &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Redisson-可重入锁"><a href="#Redisson-可重入锁" class="headerlink" title="Redisson 可重入锁"></a>Redisson 可重入锁</h2><p>基于SETNX实现的分布式锁存在以下问题</p><ol><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li><li>重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的</li><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患</li><li>主从一致性<br>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题<h2 id="那么什么是Redisson呢"><a href="#那么什么是Redisson呢" class="headerlink" title="那么什么是Redisson呢"></a>那么什么是Redisson呢</h2>Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现<br>Redis提供了分布式锁的多种多样功能</li></ol></li><li>可重入锁(Reentrant Lock)</li><li>公平锁(Fair Lock)</li><li>联锁(MultiLock)</li><li>红锁(RedLock)</li><li>读写锁(ReadWriteLock)</li><li>信号量(Semaphore)</li><li>可过期性信号量(PermitExpirableSemaphore)</li><li>闭锁(CountDownLatch)</li></ol><h3 id="需要提前导入依赖坐标"><a href="#需要提前导入依赖坐标" class="headerlink" title="需要提前导入依赖坐标"></a>需要提前导入依赖坐标</h3><h3 id="对其进行配置"><a href="#对其进行配置" class="headerlink" title="对其进行配置"></a>对其进行配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs [JAV]">//配置Redisson，用于分布式锁<br>@Configuration<br>public class RedissonConfig &#123;<br><br>    @Bean<br>    public RedissonClient RedissonClient() &#123;<br>        //配置<br>        Config config = new Config();<br>        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);<br>        //创建RedissonClient对象<br>        return Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">@Resource<br>private RedissonClient redissonClient;<br><br>@Test<br>void testRedisson() throws InterruptedException &#123;<br>    //获取可重入锁<br>    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);<br>    //尝试获取锁，三个参数分别是：获取锁的最大等待时间(期间会重试)，锁的自动释放时间，时间单位<br>    boolean success = lock.tryLock(1,10, TimeUnit.SECONDS);<br>    //判断获取锁成功<br>    if (success) &#123;<br>        try &#123;<br>            System.out.println(&quot;执行业务&quot;);<br>        &#125; finally &#123;<br>            //释放锁<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理的话要读源码，读不懂一点好吧，太难读了。等我回头学会了再来补充。<br>目前只知道一点Redisson可重入的原理大概是 采用了hash结构存储锁，外层key代表锁存在，<br>内层key代表是线程的标识 即一个方法会先获取外层key，如果锁存在，则该方法继续获取<br>内层key,如果内层key和自己的线程标识相同，则获取锁成功，此时value +1,方法执行完后<br>也不是直接释放锁，而是value -1，直到value =0时才释放锁</p><h1 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>  字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<br>  消息队列：存储和管理消息，也被称为消息代理（Message Broker）<br>  生产者：发送消息到消息队列<br>  消费者：从消息队列获取消息并处理消息</p><h2 id="使用队列的好处在于解耦："><a href="#使用队列的好处在于解耦：" class="headerlink" title="使用队列的好处在于解耦："></a>使用队列的好处在于解耦：</h2><p>  举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br>  那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br>  这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</p><h2 id="redis基于List的消息队列"><a href="#redis基于List的消息队列" class="headerlink" title="redis基于List的消息队列"></a>redis基于List的消息队列</h2><p> 消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果<br>  队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。<br> 不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或 者BLPOP来实现阻塞效果</p><h3 id="基于List的消息队列有哪些优缺点？"><a href="#基于List的消息队列有哪些优缺点？" class="headerlink" title="基于List的消息队列有哪些优缺点？"></a>基于List的消息队列有哪些优缺点？</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)<h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息<br>SUBSCRIBE channel [channel]：订阅一个或多个频道<br>PUBLISH channel msg：向一个频道发送消息<br>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li></ol><h3 id="基于PubSub的消息队列有哪些优缺点"><a href="#基于PubSub的消息队列有哪些优缺点" class="headerlink" title="基于PubSub的消息队列有哪些优缺点"></a>基于PubSub的消息队列有哪些优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>采用发布订阅模型，支持多生产，多消费</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不支持数据持久化<br>2 .无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）<br>3 .消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）<h2 id="Stream的单消费模式"><a href="#Stream的单消费模式" class="headerlink" title="Stream的单消费模式"></a>Stream的单消费模式</h2><img src="https://www.helloimg.com/i/2024/09/03/66d6ef96a5d79.jpg" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]"><br>## 创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID<br>XADD users * name jack age 21<br></code></pre></td></tr></table></figure></li></ol><p>读取队列方法之一 ：XREAD<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure></p><ol><li>[COUNT count]<br>每次读取消息的最大数量</li><li>[BLOCK milliseconds]<br>当没有消息时，是否阻塞，阻塞时长</li><li>STREAMS key [key …]<br>要从哪个队列读取消息，key就是队列名</li><li>ID [ID …]<br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始</li></ol><p>注意：<br> 当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题</p><h3 id="STREAM类型消息队列的XREAD命令特点"><a href="#STREAM类型消息队列的XREAD命令特点" class="headerlink" title="STREAM类型消息队列的XREAD命令特点"></a>STREAM类型消息队列的XREAD命令特点</h3><ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol><h2 id="Sream的组消费模式"><a href="#Sream的组消费模式" class="headerlink" title="Sream的组消费模式"></a>Sream的组消费模式</h2><pre><code>将多个消费者划分为一组，监听一个队列</code></pre><h3 id="1-消息分流"><a href="#1-消息分流" class="headerlink" title="1.消息分流"></a>1.消息分流</h3><p>队列中消息分给组内不同的消费者，而不是重复消费者（也可以消费者重复去执行）提高效率</p><h3 id="2-消息标识"><a href="#2-消息标识" class="headerlink" title="2. 消息标识"></a>2. 消息标识</h3><p>消费者在读取一个消息后，会给该消息添加一个标识，从而可以记录到最后被处理的消息，即使消费者宕机。重启后可以<br>继续从标识的地方继续读取，直到消费者执行完毕该消息，进行确认后，该消息才会被消息队列移除，确保了每个消息最少执行一遍</p><h3 id="3。消息确认"><a href="#3。消息确认" class="headerlink" title="3。消息确认"></a>3。消息确认</h3><p>消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</p><h2 id="基于Stream实现异步秒杀"><a href="#基于Stream实现异步秒杀" class="headerlink" title="基于Stream实现异步秒杀"></a>基于Stream实现异步秒杀</h2><pre><code>异步秒杀所以需要子线程中消费队列思路：在子线程中一直循环，循环中该线程指定g1组的消费者c1读取Stream中的消息，然后判断读取的消息是否为空，为空则进行下一次循环，不为空则解析消息中的数据，得到需要的对象，然后创建订单，订单完成后进行消息确认消息队列会移除该消息，如果执行过程中出现异常，就会先捕捉异常，然后执行pending-list中的消息，因为出现异常消息被读取加上标识，但是并未确定，所以会在pending-list中。读取消息，判断是否为空，不为空则创建订单，确认消息，如果为空说明pending-list中没有消息，直接break。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs []">String queuename =&quot;stream.order&quot;;<br>private class  VoucherOrderHander implements Runnable&#123;<br><br>      @Override<br>      public void run() &#123;<br>          while(true)&#123;<br>              try &#123;<br>                  //1.2 stream<br>                  //获取消息队列中的信息<br>                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(&quot;g1&quot;, &quot;c1&quot;),<br>                          //.count(1) 表示只读取一个元素， .block(Duration.ofSeconds(2))表示如果没有消息则等待两秒,<br>                          StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),<br>                          // ReadOffset.lastConsumed()表示从最新元素开始读取<br>                          StreamOffset.create(queuename, ReadOffset.lastConsumed()));<br>                  //判断是否获取成功<br>                  if (list ==null || list.isEmpty())&#123;<br>                      continue;<br>                  &#125;<br>                  //解析信息<br>                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(0);<br>                  Map&lt;Object,Object&gt; value = mapRecord.getValue();<br>                 VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, new VoucherOrder(),true);<br>                  //创建订单<br>                  porxy.CreateVoucher1(voucherOrder);<br>                  //xack确认<br>                  stringRedisTemplate.opsForStream().acknowledge(queuename,&quot;g1&quot;,mapRecord.getId());<br>              &#125; catch (Exception e) &#123;<br>                  log.info(&quot;异步订单&quot;,e);<br>                  //获取消息队列中的信息<br>                  //0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息<br>                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(&quot;g1&quot;, &quot;c1&quot;),<br>                          StreamReadOptions.empty().count(1),<br>                          StreamOffset.create(queuename,ReadOffset.from(&quot;0&quot;)));<br>                  //判断是否获取成功<br>                  if (list ==null || list.isEmpty())&#123;<br>                     break;<br>                  &#125;<br>                  //解析信息<br>                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(0);<br>                  Map&lt;Object,Object&gt; value = mapRecord.getValue();<br>                  VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, new VoucherOrder(),true);<br>                  //创建订单<br>                  porxy.CreateVoucher1(voucherOrder);<br>                  //xack确认<br>                  stringRedisTemplate.opsForStream().acknowledge(queuename,&quot;g1&quot;,mapRecord.getId());<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p> 主线程中的异步秒杀的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs [JAVA]">/*  Long userId = UserHolder.getUser().getId();<br>        long orderId= redisIdWorker.nextId(&quot;order&quot;);<br>        //执行lua脚本<br>        Long result = stringRedisTemplate.execute(<br>                SECKILL_SCRIPT, Collections.emptyList(),<br>                voucherId.toString(), userId.toString(),String.valueOf(orderId)<br>        );<br>        //判断是否为0<br>        int r = result.intValue();<br>        if (r!=0)&#123;<br>            return Result.fail(r==1? &quot;库存不足&quot; : &quot;不能重复下单&quot;) ;<br>        &#125;<br>        porxy = (IVoucherOrderService) AopContext.currentProxy();<br>        return Result.ok(orderId); <br></code></pre></td></tr></table></figure><br>Lua脚本的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs [Lua]">-- 订单id<br>local voucherId = ARGV[1]<br>-- 用户id<br>local userId = ARGV[2]<br>-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的<br>local id = ARGV[3]<br>-- 优惠券key<br>local stockKey = &#x27;seckill:stock:&#x27; .. voucherId<br>-- 订单key<br>local orderKey = &#x27;seckill:order:&#x27; .. voucherId<br>-- 判断库存是否充足<br>if (tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then<br>    return 1<br>end<br>-- 判断用户是否下单<br>if (redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then<br>    return 2<br>end<br>-- 扣减库存<br>redis.call(&#x27;incrby&#x27;, stockKey, -1)<br>-- 将userId存入当前优惠券的set集合<br>redis.call(&#x27;sadd&#x27;, orderKey, userId)<br>-- 将下单数据保存到消息队列中<br>redis.call(&quot;sadd&quot;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, id)<br>return 0<br></code></pre></td></tr></table></figure><br>redis的学习就先到这里吧，时间紧任务重就要先去学微服务啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis雪崩&quot;&gt;&lt;a href=&quot;#redis雪崩&quot; class=&quot;headerlink&quot; title=&quot;redis雪崩&quot;&gt;&lt;/a&gt;redis雪崩&lt;/h1&gt;&lt;p&gt;  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="redis" scheme="http://example.com/categories/redis/"/>
    
    
  </entry>
  
</feed>

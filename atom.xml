<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Little Monste&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-22T11:32:35.637Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小怪兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springcloud</title>
    <link href="http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-09-10T08:20:20.287Z</published>
    <updated>2024-09-22T11:32:35.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>将业务的所有功能集中在一个项目中开发，打成一个包部署</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>架构简单</li><li>部署成本低<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>团队协作成本高</li><li>系统发布效率低</li><li>系统可用性差<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2>把单体架构的功能模块拆分成多个独立的项目<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3></li><li>粒度小： 拆分的项目可以可以只是一个单独的功能</li><li>团队自治</li><li>服务自治<h1 id="拆分黑马商城"><a href="#拆分黑马商城" class="headerlink" title="拆分黑马商城"></a>拆分黑马商城</h1>原单体架构的目录结构<br><img src="https://pic.imgdb.cn/item/66e2a722d9c307b7e9bb1bfa.png" alt=""><h2 id="拆分商品功能为一个微服务"><a href="#拆分商品功能为一个微服务" class="headerlink" title="拆分商品功能为一个微服务"></a>拆分商品功能为一个微服务</h2>本项目利用maven模块拆分，亦可以创建多个项目实例<h3 id="创建maven模块（item-service）"><a href="#创建maven模块（item-service）" class="headerlink" title="创建maven模块（item-service）"></a>创建maven模块（item-service）</h3>将item商品的有关代码复制粘贴到item-service中<br>需要创建启动类和修改yaml文件(端口号，和swagger的扫描路径)和添加pom的依赖<br><img src="https://pic.imgdb.cn/item/66e2a801d9c307b7e9bc13cf.png" alt=""><h3 id="创建item数据库"><a href="#创建item数据库" class="headerlink" title="创建item数据库"></a>创建item数据库</h3>因为是微服务和原本的项目已经隔离开了，所以每一个微服务都要需要对应的mysql表<br><img src="https://pic.imgdb.cn/item/66e2a957d9c307b7e9bda7b1.png" alt=""><h2 id="同理拆分购物车"><a href="#同理拆分购物车" class="headerlink" title="同理拆分购物车"></a>同理拆分购物车</h2></li></ol><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p>微服务之间是互相隔离的，相当于独立的小项目，所以微服务之间不能直接相互调用<br>但在实际业务中，经常会需要商品业务的业务逻辑中需要调用购物车的api，同理购物车也要商品的api等<br>注册中心就可以解决微服务之间互相调用的问题</p><h2 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h2><p><img src="https://pic.imgdb.cn/item/66e2aac9d9c307b7e9bf65e9.png" alt=""><br>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>简介 Nacos 有阿里开发<br>实际上 Nacos也需要一台独立的计算机来部署，为了方便学习，我们在虚拟机上利用Docker部署Nacos</p><h3 id="创建Nacos数据库"><a href="#创建Nacos数据库" class="headerlink" title="创建Nacos数据库"></a>创建Nacos数据库</h3><p>数据库sql可在官方文档中查找<br><img src="https://pic.imgdb.cn/item/66e2ac6fd9c307b7e9c1afa9.png" alt=""></p><h3 id="Docker部署Nacos"><a href="#Docker部署Nacos" class="headerlink" title="Docker部署Nacos"></a>Docker部署Nacos</h3><p>nacos的数据库配置传入虚拟机<br><img src="https://pic.imgdb.cn/item/66e2ace0d9c307b7e9c24390.png" alt=""><br>创造容器并执行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs []">docker run -d \<br>--name nacos \<br>--env-file ./nacos/custom.env \<br>-p 8848:8848 \<br>-p 9848:9848 \<br>-p 9849:9849 \<br>--restart=always \<br>nacos/nacos-server:v2.1.0-slim<br></code></pre></td></tr></table></figure><br>部署成功页面<br><img src="https://pic.imgdb.cn/item/66e2ad7bd9c307b7e9c310a5.png" alt=""></p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><ol><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66e2b98ad9c307b7e9d11c3f.png" alt=""></li></ol><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><ol><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3></li><li>添加依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos 服务注册发现--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>yaml文件配置地址和端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: item-service # 服务名称<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br></code></pre></td></tr></table></figure></li><li>利用DiscoveryClient工具<br>以下代码可以获取到nacos中的一个item-service的实例，然后获取该实例url发送请求即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs []">//获取实例<br>      List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;item-service&quot;);<br>      if (CollUtils.isEmpty(instances)) &#123;<br>          return;<br>      &#125;<br>      //负载均衡 选择一个实例<br>      ServiceInstance serviceInstance = instances.get(RandomUtil.randomInt(instances.size()));<br></code></pre></td></tr></table></figure><h1 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h1>OpenFeign 用于简化服务调用的过程<h2 id="OpenFeign快速入门"><a href="#OpenFeign快速入门" class="headerlink" title="OpenFeign快速入门"></a>OpenFeign快速入门</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3>在cart-service服务的pom.xml中引入OpenFeign的依赖和loadBalancer依赖<br>loadBalancer依赖是用与负载均衡的<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--openFeign--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--负载均衡器--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="2-启动OpenFeign功能"><a href="#2-启动OpenFeign功能" class="headerlink" title="2.启动OpenFeign功能"></a>2.启动OpenFeign功能</h3>接下来，我们在cart-service的CartApplication启动类上添加注解，启动OpenFeign功能<br><img src="https://pic.imgdb.cn/item/66e2dd53d9c307b7e911453a.png" alt=""></li></ol><h3 id="3-编写FeignClient"><a href="#3-编写FeignClient" class="headerlink" title="3.编写FeignClient"></a>3.编写FeignClient</h3><ol><li><p>@GetMapping(“/items”)<br>List<ItemDTO> queryItemByIds(@RequestParam(“ids”) Collection<Long> ids);<br>这个方法使需要从item-service模块的controller找到对应的方法<br>例如这是未拆分前的购物车中调用item的方法这是一个通过id查询商品的功能，<br>如果需要拆分调用，我们就需要在item模块的controller中找到通过id查询商品的接口，将这个接口抽取出来<br><img src="https://pic.imgdb.cn/item/66e434e0d9c307b7e9f3889b.png" alt=""><br>如果需要拆分调用，我们就需要在item模块的controller中找到通过id查询商品的接口，将这个接口抽取出来<br><img src="https://pic.imgdb.cn/item/66e4359cd9c307b7e9f434a5.png" alt=""><br>抽取到一个公共模块中<br><img src="https://pic.imgdb.cn/item/66e435e7d9c307b7e9f47292.png" alt=""></p></li><li><p>@FeignClient(“item-service”)的作用是获取nacos中item-service的实例</p></li><li>@GetMapping(“/items”)的作用：声明请求路径，会在获得实例的http路径后加上/items <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.hmall.cart.client;<br><br>import com.hmall.cart.domain.dto.ItemDTO;<br>import org.springframework.cloud.openfeign.FeignClient;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RequestParam;<br><br>import java.util.List;<br><br>@FeignClient(&quot;item-service&quot;)<br>public interface ItemClient &#123;<br><br>    @GetMapping(&quot;/items&quot;)<br>    List&lt;ItemDTO&gt; queryItemByIds(@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-调用-ItemClient"><a href="#4-调用-ItemClient" class="headerlink" title="4.调用 ItemClient"></a>4.调用 ItemClient</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">List&lt;ItemDTO&gt; items = itemClient.queryItembyidList(itemIds);<br></code></pre></td></tr></table></figure>相比于之前代码比较<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">/获取实例<br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;item-service&quot;);<br>        if (CollUtils.isEmpty(instances)) &#123;<br>            return;<br>        &#125;<br>        //负载均衡 选择一个实例<br>        ServiceInstance serviceInstance = instances.get(RandomUtil.randomInt(instances.size()));<br>        ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(<br>                serviceInstance.getUri() + &quot;/items?ids=&#123;ids&#125;&quot;,<br>                HttpMethod.GET,<br>                null,<br>                new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<br>                Map.of(&quot;ids&quot;, CollUtils.join(itemIds, &quot;,&quot;))<br>        );<br>        List&lt;ItemDTO&gt; items =null;<br>        if (response.getStatusCode().is2xxSuccessful()) &#123;<br>           items = response.getBody();<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="OpenFeign-的连接池"><a href="#OpenFeign-的连接池" class="headerlink" title="OpenFeign 的连接池"></a>OpenFeign 的连接池</h3>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</li></ol><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--OK http 的依赖 --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;<br>  &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h4 id="开启连接池-在yaml文件中"><a href="#开启连接池-在yaml文件中" class="headerlink" title="开启连接池 在yaml文件中"></a>开启连接池 在yaml文件中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs []">feign:<br>  okhttp:<br>    enabled: true # 开启OKHttp功能<br></code></pre></td></tr></table></figure><h3 id="抽取OpenFeign为公共模块"><a href="#抽取OpenFeign为公共模块" class="headerlink" title="抽取OpenFeign为公共模块"></a>抽取OpenFeign为公共模块</h3><p>因为很多功能模块都需要用到OpenFeign，抽取成公共模块可以使代码更优雅<br>抽取成如下，同时需要添加nacos，OpenFeign等需要的依赖<br><img src="https://pic.imgdb.cn/item/66e3f3dfd9c307b7e9aa5fa9.png" alt=""><br>当其他功能模块需要使用远程调用的时候导入hm-api的坐标即可<br>这个错误表示查找不到对应的Bean，说明扫描包并没有扫描到hm-api<br><img src="https://pic.imgdb.cn/item/66e3f469d9c307b7e9aaf1ec.png" alt=""><br>在启动类添加注解 @EnableFeignClients(basePackages = “com.heima.api.client”) 即可</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关 就是网络的关口，负责请求的路由，转发，身份校验。<br>网关一般用于微服务中，微服务中每个微服务都有各自的ip地址请求路径等，</p><ol><li>不使用网关的情况下 前端每次发送请求都需要发送到微服务的IP地址上，并且都需要身份验证，这样会很麻烦。</li><li>使用网关的情况下，前端的所有请求都可以发送到网关上，由网关分析，身份验证，处理然后转发到对应的微服务上<br>网关的作用我觉得和单体架构的拦截器有点像，都可以拦截请求路径，然后处理判断，再发送到具体的请求方法上，<br>不过网关更加强大，可以拦截不同IP地址的请求，再转发<br>网关也更像小区保安 ： 一个前端请求过来，网关就会判断请求转发的IP地址，在身份确认后转发该请求<br><img src="https://pic.imgdb.cn/item/66e55a68d9c307b7e9ee8ddd.jpg" alt=""><br><img src="https://pic.imgdb.cn/item/66e55aced9c307b7e9eefe28.jpg" alt=""><h2 id="网关快速入门"><a href="#网关快速入门" class="headerlink" title="网关快速入门"></a>网关快速入门</h2>网关本身也是一个微服务，所以需要先创建网关微服务</li></ol><ul><li>创建网关<br><img src="https://pic.imgdb.cn/item/66e55b5ad9c307b7e9ef8904.png" alt=""></li><li>引入网关和负载均衡的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--网关--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--nacos discovery--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--负载均衡--&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>创建启动类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.hmall.gateway;<br><br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;<br><br>@SpringBootApplication<br>public class GatewayApplication &#123;<br>    public static void main(String[] args) &#123;<br>        SpringApplication.run(GatewayApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>配置yaml文件<br><img src="https://pic.imgdb.cn/item/66e55c2ad9c307b7e9f04495.jpg" alt=""></li></ul><h2 id="网关登录验证"><a href="#网关登录验证" class="headerlink" title="网关登录验证"></a>网关登录验证</h2><p>使用网关进行登录校验，首先我们需要先了解网关的执行流程</p><h3 id="网关的执行流程"><a href="#网关的执行流程" class="headerlink" title="网关的执行流程"></a>网关的执行流程</h3><p>当前端发来请求到网关，网关会先执行断言（HandlerMapper），断言的作用是根据前端传来的请求，来判断目的地微服务，断言结束后，会执行过滤器处理器，里面会有很多的过滤器，会依次执行这些过滤器，NettyRoutingFilter是最后一个过滤器，它负责将处理后的请求转发到微服务上<br>所以网关登录校验即是自定义一个过滤器用来判断身份<br><img src="https://pic.imgdb.cn/item/66e6c8b2d9c307b7e9b2d7fa.jpg" alt=""></p><h3 id="自定义网关过滤器"><a href="#自定义网关过滤器" class="headerlink" title="自定义网关过滤器"></a>自定义网关过滤器</h3><p> GlobalFilter : 全局过滤器，作用范围i是所有路由，声明后自动生效<br> 以下是一个自定义的网关过滤器：</p><ol><li>该过滤器实现了 GlobalFilter接口，其中ServerWebExchange exchange变量是存储过滤器中的数据的，所以每一个过滤器调用数据都需要从exchange中调取，经过过滤器处理后需要得到一个新的ServerWebExchange类型的变量例如exchange1，然后 利用GatewayFilterChain chain的chain.filter(exchange1)方法将处理后的数据传入下一个过滤器</li><li>该过滤器实现了  Ordered接口 ，是用来规定过滤器的执行顺序的，Ordered的方法返回值越小，则越先执行</li><li>该过滤器的作用：先获取请求头，从请求头中的路径判断是否需要拦截（因为有些功能不需要拦截，例如注册登录），需要拦截则获取请求头Authorization中的token，如果token为空则返会401，token不为空则解析token，获得token中的userId，然后将userId封装到user-info请求头中，并放入新的exchange1 中，传入下一个过滤器，最终转发到微服务上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs []">@RequiredArgsConstructor<br>@Component<br>public class AuthGlobalFilter implements GlobalFilter, Ordered &#123;<br>    private final AuthProperties authProperties;<br>    private final JwtTool jwtTool;<br>    private final AntPathMatcher antPathMatcher = new AntPathMatcher();<br>    @Override<br>    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;<br>        // 1,获取请求头<br>       ServerHttpRequest request = exchange.getRequest();<br>       // 判断是否需要拦截<br>        if(isExclude(request.getPath().toString()))<br>        &#123;<br>            return chain.filter(exchange);<br>        &#125;<br>        // 获取token<br>        String token =null;<br>         List&lt;String&gt; authorization = request.getHeaders().get(&quot;Authorization&quot;);<br>         if (authorization != null &amp;&amp; authorization.size() &gt; 0) &#123;<br>             token = authorization.get(0);<br>         &#125;<br>         // 解析校验token<br>        Long userId = null;<br>         try &#123;<br>             userId= jwtTool.parseToken(token);<br>         &#125;catch (UnauthorizedException e)<br>         &#123;<br>              ServerHttpResponse response = exchange.getResponse();<br>              response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>              return response.setComplete();<br>         &#125;<br>         //传递用户信息<br>       String userInfo = userId.toString();<br>         ServerWebExchange exchange1 = exchange.mutate()<br>                .request(builder -&gt; builder.header(&quot;user-info&quot;, userInfo))<br>                .build();<br>        return chain.filter(exchange1);<br>    &#125;<br><br>    private boolean isExclude(String path) &#123;<br>        for(String pathPattern : authProperties.getExcludePaths())&#123;<br>            if (antPathMatcher.match(pathPattern, path)) &#123;<br>                return true;<br>            &#125;<br>        &#125;<br>        return false;<br>    &#125;<br><br><br>    @Override<br>    public int getOrder() &#123;<br>        return 0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网关传递用户信息"><a href="#网关传递用户信息" class="headerlink" title="网关传递用户信息"></a>网关传递用户信息</h3><ol><li>在自定义网关过滤器中，已经将用户Id传入请求头中，所以在微服务中需要拦截器获取用户Id<br><img src="https://pic.imgdb.cn/item/66e6c8d5d9c307b7e9b2f1e1.jpg" alt=""></li><li>在公共类中创建拦截器,因为在网关中已经做过获取和解析token了，所以这个请求头里并没有加密，只有用户id<br><img src="https://pic.imgdb.cn/item/66e6c9f1d9c307b7e9b3db6a.png" alt=""></li><li>注册拦截器，拦截器需要一个配置类注册才能生效<br>需要多加一个注解@ConditionalOnClass(DispatcherServlet.class)，该注解的意思是这个配置类生效的范围是拥有DispatcherServlet.class的模块，因为网关的依赖的中并没有springmvc，其他模块微服务都是基于springmvc的，而DispatcherServlet.class正是springmvc的核心之一，所以这个配置类将不会再网关中生效<br><img src="https://pic.imgdb.cn/item/66e6ca4fd9c307b7e9b4243a.png" alt=""><h1 id="OpenFeign的补充"><a href="#OpenFeign的补充" class="headerlink" title="OpenFeign的补充"></a>OpenFeign的补充</h1></li><li>前面已经实现了用OpenFeign进行微服务之间的调用，还有一个问题微服务之间调用的同时传入用户信息需要OpenFeign解决</li><li>我们利用网关将用户登录的信息转发到了微服务上，但是微服务和微服务之间相互调用的时候并不能传入用户的登录信息，</li><li>我们又知道微服务之间的远程调用时利用OpenFeign做到的，所以OpenFeign提供了拦截器为我们解决这个问题<br><img src="https://pic.imgdb.cn/item/66e7dd28d9c307b7e908b110.jpg" alt=""><h2 id="OpenFeign的拦截器"><a href="#OpenFeign的拦截器" class="headerlink" title="OpenFeign的拦截器"></a>OpenFeign的拦截器</h2><img src="https://pic.imgdb.cn/item/66e7deadd9c307b7e90b2a17.jpg" alt=""><br>这个拦截器很简单就写在了同一个配置类下，当然可以新建一个配置类然后实现RequestInterceptor接口<br><img src="https://pic.imgdb.cn/item/66e7de5fd9c307b7e90ab226.png" alt=""></li></ol></li></ol><h1 id="Nacos的扩展-配置共享"><a href="#Nacos的扩展-配置共享" class="headerlink" title="Nacos的扩展 配置共享"></a>Nacos的扩展 配置共享</h1><p>在我们的微服务中很多配置（例如mybatispuls,日志，数据库连接池）都是微服务共有的，这需要我们在每个微服务里都写一遍，这是很麻烦的<br>所以Nacos为我们解决了这个问题</p><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><h3 id="在Nacos上添加配置"><a href="#在Nacos上添加配置" class="headerlink" title="在Nacos上添加配置"></a>在Nacos上添加配置</h3><p>注意 ：dataID不能乱写，因为是yaml格式的文件，所以 dataid的结尾必须是 .yaml<br><img src="https://pic.imgdb.cn/item/66eac48df21886ccc0d074fc.png" alt=""></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--nacos配置管理--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--读取bootstrap文件--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="编写bootstrap-yaml"><a href="#编写bootstrap-yaml" class="headerlink" title="编写bootstrap.yaml"></a>编写bootstrap.yaml</h3><p>在此之前我们需要先了解sringboot的启动顺序，springboot启动会先加载application.yml，然后初始化ApplicationContext；<br>在微服务Springcloud中启动，sringclound会先在bootstrap.yaml中拉取nacos的共享配置，然后初始化ApplicationContext，接着加载springboard的application.yml，进行配置整合，最后初始化<br><img src="https://pic.imgdb.cn/item/66eac6b4f21886ccc0d26cf3.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: cart-service # 服务名称<br>  profiles:<br>    active: dev<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128 # nacos地址<br>      config:<br>        file-extension: yaml # 文件后缀名<br>        shared-configs: # 共享配置<br>          - dataId: shared-jdbc.yaml # 共享mybatis配置<br>          - dataId: shared-swagger.yaml # 共享日志配置<br></code></pre></td></tr></table></figure></p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>当我们在idea中修改了项目的配置的时候，一般都需要重启项目才能生效，但利用nacos可以做到热更新<br> 添加配置<br> <img src="https://pic.imgdb.cn/item/66ebf2a7f21886ccc0d3b104.png" alt=""><br>然后需要创建一个类用于接收配置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">package com.hmall.cart.config;<br><br>import lombok.Data;<br>import org.springframework.boot.context.properties.ConfigurationProperties;<br>import org.springframework.stereotype.Component;<br><br>@Data<br>@Component<br>@ConfigurationProperties(prefix = &quot;hm.cart&quot;)<br>public class CartProperties &#123;<br>    private Integer maxAmount;<br>&#125;<br></code></pre></td></tr></table></figure><br>这样maxAmount 就可以实时等于配置中的数据了</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由也一样，防止路由变化然后需要项目重启</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--统一配置管理--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--加载bootstrap--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="然后在网关gateway的resources目录创建bootstrap-yaml文件"><a href="#然后在网关gateway的resources目录创建bootstrap-yaml文件" class="headerlink" title="然后在网关gateway的resources目录创建bootstrap.yaml文件"></a>然后在网关gateway的resources目录创建bootstrap.yaml文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: gateway<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.150.101<br>      config:<br>        file-extension: yaml<br>        shared-configs:<br>          - dataId: shared-log.yaml # 共享日志配置<br>          - dataId: gateway-routes.json #这个需要根据自己定义的dataId<br></code></pre></td></tr></table></figure><h3 id="配置路由监听器"><a href="#配置路由监听器" class="headerlink" title="配置路由监听器"></a>配置路由监听器</h3><p>因为我们需要先监听路由是否变化，如果路由没有变化，就不用去更新路由;<br> RouteDefinitionWriter接口是由nacos提供的Bean，导入nacos的依赖就可以注入，作用是更新和删除路由。但不能批量<br>NacosConfigManager也是由nacos提供的Bean,作用是与nacos建立联系，可以实时获取nacos里的配置，并监听是否发生变化<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs []">@Slf4j<br>@Component<br>@RequiredArgsConstructor<br>public class RouterLoader &#123;<br><br>    private final RouteDefinitionWriter writer;<br>    private final NacosConfigManager nacosConfigManager;<br><br>    // 路由配置文件的id和分组<br>    private final String dataId = &quot;gateway-routes.json&quot;;<br>    private final String group = &quot;DEFAULT_GROUP&quot;;<br>    // 保存更新过的路由id<br>    private final Set&lt;String&gt; routeIds = new HashSet&lt;&gt;();<br><br>    @PostConstruct<br>    public void initRouteConfigListener() throws NacosException &#123;<br>        // 1.注册监听器并首次拉取配置<br>        String configInfo = nacosConfigManager.getConfigService()<br>                .getConfigAndSignListener(dataId, group, 5000, new Listener() &#123;<br>                    @Override<br>                    public Executor getExecutor() &#123;<br>                        return null;<br>                    &#125;<br>                    <br>                    @Override  //路由变化则触发<br>                    public void receiveConfigInfo(String configInfo) &#123;<br>                        updateConfigInfo(configInfo);<br>                    &#125;<br>                &#125;);<br>        // 2.首次启动时，更新一次配置<br>        updateConfigInfo(configInfo);<br>    &#125;<br><br>    private void updateConfigInfo(String configInfo) &#123;<br>        log.debug(&quot;监听到路由配置变更，&#123;&#125;&quot;, configInfo);<br>        // 1.反序列化<br>        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);<br>        // 2.更新前先清空旧路由<br>        // 2.1.清除旧路由<br>        for (String routeId : routeIds) &#123;<br>            writer.delete(Mono.just(routeId)).subscribe();<br>        &#125;<br>        routeIds.clear();<br>        // 2.2.判断是否有新的路由要更新<br>        if (CollUtils.isEmpty(routeDefinitions)) &#123;<br>            // 无新路由配置，直接结束<br>            return;<br>        &#125;<br>        // 3.更新路由<br>        routeDefinitions.forEach(routeDefinition -&gt; &#123;<br>            // 3.1.更新路由<br>            writer.save(Mono.just(routeDefinition)).subscribe();<br>            // 3.2.记录路由id，方便将来删除<br>            routeIds.add(routeDefinition.getId());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="nacos添加路由"><a href="#nacos添加路由" class="headerlink" title="nacos添加路由"></a>nacos添加路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs []">[<br>    &#123;<br>        &quot;id&quot;: &quot;item&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/items/**&quot;, &quot;_genkey_1&quot;:&quot;/search/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://item-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;cart&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/carts/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://cart-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;user&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/users/**&quot;, &quot;_genkey_1&quot;:&quot;/addresses/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://user-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;trade&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/orders/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://trade-service&quot;<br>    &#125;,<br>    &#123;<br>        &quot;id&quot;: &quot;pay&quot;,<br>        &quot;predicates&quot;: [&#123;<br>            &quot;name&quot;: &quot;Path&quot;,<br>            &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/pay-orders/**&quot;&#125;<br>        &#125;],<br>        &quot;filters&quot;: [],<br>        &quot;uri&quot;: &quot;lb://pay-service&quot;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h1 id="微服务的雪崩问题"><a href="#微服务的雪崩问题" class="headerlink" title="微服务的雪崩问题"></a>微服务的雪崩问题</h1><p>微服务调用链路中的某个服务故障，引起整个链路中的所有的微服务都不可用。<br>简单来说就是蝴蝶效应，因为微服务之间是错用复杂的，如果一个微服务A故障，那么由于微服务B调用A，导致B也故障，微服务C调用B，结果导致C也故障了。以此类推就会可能发生微服务大面积雪崩</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Sentinel 是一款开源的微服务限流器，可以帮助我们解决微服务的雪崩问题</p><ul><li>初识Sentinel</li></ul><ol><li>官网下载Jar，并运行<br>端口号冲突，更改了一下端口号<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs []">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br></code></pre></td></tr></table></figure>运行成功即可访问</li><li>添加依赖和配置<br>这些配置可以共享到nacos中以后更加方便<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--sentinel--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; <br>    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br><br><br>spring:<br>  cloud: <br>    sentinel:<br>      transport:<br>        dashboard: localhost:8090<br></code></pre></td></tr></table></figure></li><li>访问8090端口<br><img src="https://pic.imgdb.cn/item/66ed294af21886ccc0e9941d.png" alt=""><h2 id="sentinel-之线程隔离"><a href="#sentinel-之线程隔离" class="headerlink" title="sentinel 之线程隔离"></a>sentinel 之线程隔离</h2>一个微服务A中可能会调用多个微服务 B,C,D等，但是如果B微服务宕机等，会导致A调用B的线程也出问题，会占用微服务A的资源。当异常线程组都多，会影响到微服务A调用其他微服务。<br>所以sentinel会我们提供了线程隔离，例如给一个请求规定5个线程，当这个请求的线程达到5个，就不允许这个请求的线程再增加。这样就不会影响到其他线程<br><img src="https://pic.imgdb.cn/item/66eeb555f21886ccc056f5c5.jpg" alt=""><br>sentinel设置线程隔离很简单，再请求的流控中设置并发线程数即可<br><img src="https://pic.imgdb.cn/item/66eeb694f21886ccc058690d.png" alt=""><h2 id="sentinel-之线程熔断"><a href="#sentinel-之线程熔断" class="headerlink" title="sentinel 之线程熔断"></a>sentinel 之线程熔断</h2>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。<br>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口熔断。当商品服务接口恢复正常后，再允许调用。这其实就是断路器的工作模式了。</li></ol><p>Sentinel中的断路器不仅可以统计某个接口的慢请求比例，还可以统计异常请求比例。当这些比例超出阈值时，就会熔断该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。<br>断路器的工作状态切换有一个状态机来控制：<br><img src="https://pic.imgdb.cn/item/66efc8e5f21886ccc05c0878.png" alt=""><br>状态机包括三个状态：</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li>open：打开状态，服务调用被熔断，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态<br><img src="https://pic.imgdb.cn/item/66efc946f21886ccc05c6653.png" alt=""><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1>首先我们以前在单体架构中实现事务的同成功同失败是需要在方法上添加@Transactional注解实现的；<br>但是这个方法已经对微服务不适用了，我们先来看一个业务流程<br><img src="https://pic.imgdb.cn/item/66efd045f21886ccc0639203.png" alt=""><br>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</li></ul></li><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务<br>这些分开的交易，购物车，库存 被称为分支事务，组合在一起被称为全局事务，分布式事务需要保证全局事务同成功同失败<h2 id="认识Seata"><a href="#认识Seata" class="headerlink" title="认识Seata"></a>认识Seata</h2>解决分布式事务的思路：分布式事务的主要问题是分支事务都可以保证自己事务的同成功同失败，但是分支事务之间不知道对方是否成功或失败，<br>所以就需要找到一个事务协调者，帮忙记录下每个分支事务的结果</li></ul><ol><li>Seata的架构图<br>在Seata的事务管理中有三个重要的角色：</li></ol><ul><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。 </li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li><li>RM (Resource Manager) - 资源管理器：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。<br><img src="https://pic.imgdb.cn/item/66efd20cf21886ccc0656212.png" alt=""><br>个人理解呢：TC既是事务协调者记录每个分支事务结果，当一个业务中所有分支事务结束后判断是否需要回滚。<pre><code>    但是TC并不知道这个业务的最后一个分支事务是哪个，中间也由可能有其他业务的分支事务，所以TM出现了，    TM定义了一个业务的开始和结束，当TM开始的时候，TC会接收信号然后记录分支事务的结果，当TM结束后，TC也会结束这个业务的事务    RM即是每个分支事务结束后会通过RM向TC传入自己分支事务的状态和结果。    个人觉得RM中还会带有TM的标识，TC根据标识可以分辨出这个事务是否属于TM，这样可以多个全局事务一起执行</code></pre><h3 id="部署Seata"><a href="#部署Seata" class="headerlink" title="部署Seata"></a>部署Seata</h3></li></ul><ol><li>准备Seata的数据库<br>具体sql语句可以查询Seata的官方文档有给出<br><img src="https://pic.imgdb.cn/item/66efd4dbf21886ccc0682856.png" alt=""></li><li>在Docker上部署Seata<ul><li>准备好seata的配置文件application.yml上传到虚拟机中<br>配置文件官网中也有，也可以之下在seata的镜像文件，然后修改</li><li>启动容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []"> docker run --name seata \<br>-p 8099:8099 \<br>-p 7099:7099 \<br>-e SEATA_IP=192.168.150.101 \<br>-v ./seata:/seata-server/resources \<br>--privileged=true \<br>--network hm-net \<br>-d \<br>seataio/seata-server:1.5.2<br></code></pre></td></tr></table></figure>这里我出现了报错，docker ps -a 查看后发现状态码为139，<br>查看日志发现报错是<br><img src="https://pic.imgdb.cn/item/66efe7f0f21886ccc07a89a4.png" alt=""><br>查询了半天后需要添加一项命令在run命令后<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs []">  docker run --name seata \<br>-p 8099:8099 \<br>-p 7099:7099 \<br>-e SEATA_IP=192.168.150.101 \<br>-v ./seata:/seata-server/resources \<br>--privileged=true \<br>--network hm-net \<br>-d --ulimit nofile=1024:1024 \<br>seataio/seata-server:1.5.2<br></code></pre></td></tr></table></figure></li></ul></li><li>启动成功<br><img src="https://pic.imgdb.cn/item/66efe861f21886ccc07aebce.png" alt=""><h3 id="微服务整合seata"><a href="#微服务整合seata" class="headerlink" title="微服务整合seata"></a>微服务整合seata</h3></li><li>添加相关依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;!--统一配置管理--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br>  &lt;!--读取bootstrap文件--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br>  &lt;!--seata--&gt;<br>  &lt;dependency&gt;<br>      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;<br>      &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;<br>  &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></li><li>seata的配置添加到nacos上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs []">seata:<br>  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址<br>    type: nacos # 注册中心类型 nacos<br>    nacos:<br>      server-addr: 192.168.217.128:8848 # nacos地址<br>      namespace: &quot;&quot; # namespace，默认为空<br>      group: DEFAULT_GROUP # 分组，默认是DEFAULT_GROUP<br>      application: seata-server # seata服务名称<br>      username: nacos<br>      password: nacos<br>  tx-service-group: hmall # 事务组名称<br>  service:<br>    vgroup-mapping: # 事务组与tc集群的映射关系<br>      hmall: &quot;default&quot;<br></code></pre></td></tr></table></figure></li><li>在bootstrap.yaml文件中添加<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs []">spring:<br>  application:<br>    name: trade-service # 服务名称<br>  profiles:<br>    active: dev<br>  cloud:<br>    nacos:<br>      server-addr: 192.168.217.128 # nacos地址<br>      config:<br>        file-extension: yaml # 文件后缀名<br>        shared-configs: # 共享配置<br>          - dataId: shared-jdbc.yaml # 共享mybatis配置<br>          - dataId: shared-log.yaml # 共享日志配置<br>          - dataId: shared-swagger.yaml # 共享日志配置<br>          - dataId: shared-seata.yaml # 共享seata配置<br></code></pre></td></tr></table></figure>之后就可以启动服务啦，不过这里记录一下JDK21我启动遇见的问题<br><img src="https://pic.imgdb.cn/item/66efff7cf21886ccc0937a79.png" alt=""><br>解决方法JVM启动添加—add-opens=java.base/java.lang=ALL-UNNAMED<br><img src="https://pic.imgdb.cn/item/66efffcaf21886ccc093e689.png" alt=""><br>百度了一下：—add-opens选项是Java 9引入的一个命令行选项，用于打开模块之间的包，以便其他模块可以访问这些包中的类和成员。通过使用—add-opens选项，我们可以解决由于模块的隔离性而导致的访问限制问题</li></ol><h1 id="RequiredArgsConstructor注解"><a href="#RequiredArgsConstructor注解" class="headerlink" title="@RequiredArgsConstructor注解"></a>@RequiredArgsConstructor注解</h1><p>该注解可以是Lombok所提供的，其主要的作用是简化@Autowired 的书写过程。在编写 Controller 层或 Service 层代码时，常常需要注入众多的 mapper 接口或 service 接口。若每个接口都使用 @Autowired 进行标注，代码会显得繁琐。而 @RequiredArgsConstructor 注解能够替代 @Autowired 注解，但需注意，在类上添加 @RequiredArgsConstructor 时，需要注入的类必须使用 final 进行声明。</p><p>其底层原理是为final的字段生成构造参数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;h2 id=&quot;单体架构&quot;&gt;&lt;a href=&quot;#单体架构&quot; class=&quot;headerlink&quot; title=&quot;单体架构&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="http://example.com/2024/09/07/vue3/"/>
    <id>http://example.com/2024/09/07/vue3/</id>
    <published>2024-09-07T09:53:12.890Z</published>
    <updated>2024-09-22T03:03:39.408Z</updated>
    
    <content type="html"><![CDATA[<p>什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧</p><h1 id="vue3概要"><a href="#vue3概要" class="headerlink" title="vue3概要"></a>vue3概要</h1><p>Vue是一套前端框架，用于简化JavaScript中的DOM操作，简化书写。</p><p>在之前我们也学习过后端的框架MyBatis，MyBatis是用来简化JDBC代码编写的；而Vue是前端框架，简化JavaScript代码编写的</p><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><ol><li>vue3的使用前提需要下载安装好node.js版本要在15.0以上</li><li>在命令窗中输入 npm init vue@laste 即可创建一个初始的vue文件夹</li><li>hello vue<br>值得一提的是每个绑定仅支持单一的js表达式，如{ {n+1} },页面会显示11，{ {ok?yes:no} }，页面会显示ok<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;p&gt;&#123; &#123;meg&#125; &#125;&lt;/p&gt;<br>  &lt;p&gt;&#123; &#123;n+1&#125; &#125;&lt;/p&gt;<br>  &lt;p&gt;&#123; &#123;ok?yes:no &#125; &#125;&lt;/p&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;hello jsp&quot;,<br>          n:10,<br>          ok:true<br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2>v-bind可以简写为 ：<br>v-bind的作用的：可以为元素绑定vue属性<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p v-bind:class=&quot;meg&quot;&gt;测试&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;active&quot;<br><br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66e3a4dad9c307b7e92ffdef.png" alt=""><br>可以在控制台看到 测试的class属性已经绑定成了active</li></ol><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>用于条件判断是否展示元素</p><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>当meg为true时显示，为false不显示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p v-if=&quot;meg&quot;&gt;这是meg为true&lt;/p&gt;<br>    &lt;p v-else&gt;为false &lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><br>&lt;script &gt;<br>    export default &#123;<br>      data()&#123;<br>        return&#123;<br>          meg:&quot;true&quot;<br><br>        &#125;<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66e3a631d9c307b7e9316d28.png" alt=""></p><p>多条件语句<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p v-if=&quot;meg === &#x27;A&#x27;&quot;&gt;A&lt;/p&gt;<br>    &lt;p v-else-if=&quot;meg === &#x27;B&#x27;&quot;&gt;B&lt;/p&gt;<br>    &lt;p v-else&gt;D&lt;/p&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>               meg:&quot;B&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br>&lt;style&gt;<br>html&#123;<br>font-size:16px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><br>页面显示B</p><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>事件处理，用来监听DOM事件，并在事件触发时执行对应的JS语句 ，v-on可简写为@</p><h3 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h3><p>每点击一次Add就会触发add()方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>        &lt;button @click=&quot;add&quot;&gt;Add&lt;/button&gt;<br>        &lt;p&gt;&#123; &#123; count &#125; &#125;&lt;/p&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            count:0,<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>       add()&#123;<br>        console.log(this.count)<br>        this.count++<br>       &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><h3 id="方法传参"><a href="#方法传参" class="headerlink" title="方法传参"></a>方法传参</h3><p>点击谁，会在控制台输出谁<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>        &lt;p  @click=&quot;name(item,$event)&quot; v-for=&quot;(item,index) in names&quot;:key=&quot;index&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/p&gt;<br>       <br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            names:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>      name(meg,e)&#123;<br>        console.log(meg)<br>        <br>       &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66ea83f4f21886ccc07e1937.png" alt=""></p><h2 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h2><h3 id="变更数据-可以直接使页面更新"><a href="#变更数据-可以直接使页面更新" class="headerlink" title="变更数据 可以直接使页面更新"></a>变更数据 可以直接使页面更新</h3><p><img src="https://pic.imgdb.cn/item/66ea8741f21886ccc081247d.jpg" alt=""><br>代码案例：点击添加数据，会给meg数组增加一个数据sakura<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>    &lt;button v-on:click=&quot;ADD&quot;&gt;添加数据&lt;/button&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(item,index) in meg&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ADD()&#123;<br>            this.meg.push(&quot;sakura&quot;)<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击前<br><img src="https://pic.imgdb.cn/item/66ea88fbf21886ccc083ae62.png" alt=""><br>点击后<br><img src="https://pic.imgdb.cn/item/66ea896ef21886ccc0851e99.png" alt=""> </p><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>这个方法不会使前端直接展示<br><img src="https://pic.imgdb.cn/item/66ea89bdf21886ccc0860f13.jpg" alt=""><br>代码案例：点击添加数据，会给meg数组增加一个数据sakura<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>    &lt;button v-on:click=&quot;ADD&quot;&gt;添加数据&lt;/button&gt;<br>    &lt;ul&gt;<br>        &lt;li v-for=&quot;(item,index) in meg&quot;&gt;&#123; &#123; item &#125; &#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ADD()&#123;<br>           this.meg.concat([&quot;sakura&quot;])<br>            console.log(this.meg.concat([&quot;sakura&quot;]))<br>        &#125;<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>点击后 可以看到页面并没有展示出新添加的数据，但是在控制台可以输出可以看到<br><img src="https://pic.imgdb.cn/item/66ea8ac6f21886ccc089b6fd.png" alt=""></p><p>原因：因为这个方法是新建了一个数组，在原本的数组数据基础上添加新数据，所以将新数据赋值给原本的数组即可<br>将  this.meg.concat([“sakura”]) 改成 this.meg= this.meg.concat([“sakura”]) 即可</p><p>点击后<br><img src="https://pic.imgdb.cn/item/66ea896ef21886ccc0851e99.png" alt=""> </p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>用来监听响应式数据变化，当监听数据变化时可执行一个函数<br>代码示例：meg默认值为hello,当点击按钮时meg的值改为world,watch监听到数据变化时会执行将新数据和老数据打印到控制台的函数<br>注意！！ watch里的函数名称必须与响应式数据名称一样<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>    &lt;button @click=&quot;ischange&quot;&gt;改变数据&lt;/button&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br> export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:&quot;hello&quot;<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        ischange()&#123;<br>            this.meg=&quot;world&quot;<br>        &#125;<br>    &#125;,<br>    watch:&#123;<br>        meg(newValue,oldValue)&#123;<br>            console.log(newValue,oldValue)<br>        &#125;<br>    &#125;<br> &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66eb99b7f21886ccc07c7b02.png" alt=""></p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>进行表单数据双向绑定<br>代码实例：输入框中输入的数据会实时显示在下方<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;div&gt;<br>   &lt;input type=&quot;text&quot; v-model=&quot;meg&quot;&gt;<br>   &lt;p&gt;实时输入的是&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>                meg:&quot;&quot;,<br>                a: &quot;&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br><img src="https://pic.imgdb.cn/item/66ebc6bef21886ccc0a5b3b8.png" alt=""></p><h3 id="v-model-lazy"><a href="#v-model-lazy" class="headerlink" title="v-model.lazy"></a>v-model.lazy</h3><p>不加lazy 每输入一个数据都会实时绑定<br>加上lazy 全部输入完数据才会进行绑定</p><h3 id="v-model-number"><a href="#v-model-number" class="headerlink" title="v-model.number"></a>v-model.number</h3><p>只有输入的数字才会进行绑定</p><h3 id="v-moder-trim"><a href="#v-moder-trim" class="headerlink" title="v-moder.trim"></a>v-moder.trim</h3><p>删除数据的前后空格在绑定</p><h1 id="局部引用组件"><a href="#局部引用组件" class="headerlink" title="局部引用组件"></a>局部引用组件</h1><p><img src="https://pic.imgdb.cn/item/66ecd47ef21886ccc088d3e9.jpg" alt=""></p><h1 id="全局引入组件"><a href="#全局引入组件" class="headerlink" title="全局引入组件"></a>全局引入组件</h1><p><img src="https://pic.imgdb.cn/item/66ecd4c1f21886ccc08902a4.jpg" alt=""></p><h1 id="组件传递数据"><a href="#组件传递数据" class="headerlink" title="组件传递数据"></a>组件传递数据</h1><h2 id="父传子-Props"><a href="#父传子-Props" class="headerlink" title="父传子 Props"></a>父传子 Props</h2><p>父组件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>&lt;p&gt;父传子&lt;/p&gt;<br>&lt;Props1 :meg=&quot;meg&quot;  :num=&quot;num&quot; :zu=&quot;zu&quot;/&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import Props1 from &#x27;./Props1.vue&#x27;;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            meg:&quot;这是Props传的字符串数据&quot;,<br>            num: 20,<br>            zu:[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]<br>        &#125;<br>    &#125;,<br>    components:&#123;<br>        Props1<br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><br>子组件接收<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs []">&lt;template&gt;<br>    &lt;p&gt;Props1打印传递的数据&lt;/p&gt;<br>   &lt;p&gt;&#123; &#123; meg &#125; &#125;&lt;/p&gt;<br>   &lt;p&gt;&#123; &#123; num &#125; &#125;&lt;/p&gt;<br>   &lt;p v-for=&quot;item in zu&quot;&gt; &#123; &#123; item &#125; &#125;&lt;/p&gt;<br>    &lt;/template&gt;<br>    <br>    &lt;script&gt;<br>    import Props1 from &#x27;./Props1.vue&#x27;;<br>    export default&#123;<br>        data()&#123;<br>            return&#123;<br>            &#125;<br>        &#125;,<br>        props:[&quot;meg&quot;,&quot;num&quot;,&quot;zu&quot;]<br>    &#125;<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><br>结果<br><img src="https://pic.imgdb.cn/item/66ee2ce1f21886ccc0c94ab2.png" alt=""><br>这是局部引用组件，被引用的组件是子组件，子组件接收数据要用props；<br>props可以接收任何形式的数据</p><h2 id="子接收数据校验"><a href="#子接收数据校验" class="headerlink" title="子接收数据校验"></a>子接收数据校验</h2><p>子组件可以规定接收数据的类型，如果父组件传递的类型不是子组件规定的，会报警告<br>利用props中的type<br><img src="https://pic.imgdb.cn/item/66ee2e4ff21886ccc0ca8d10.jpg" alt=""></p><h2 id="子传父-this-emit"><a href="#子传父-this-emit" class="headerlink" title="子传父 this.$emit"></a>子传父 this.$emit</h2><p>子传父利用this.$emit，其实原理是回调父组件的函数<br>先看子组件,子组件利用this.$emit，向父组件传递了一个函数名，和一个新数据<br><img src="https://pic.imgdb.cn/item/66ef879ef21886ccc01c203f.jpg" alt=""><br>父组件用v-on绑定了子组件传过来的函数名和数据，并再methods中实现了。<br><img src="https://pic.imgdb.cn/item/66ef8838f21886ccc01cbc31.jpg" alt=""><br>最后效果<br><img src="https://pic.imgdb.cn/item/66ef88c3f21886ccc01d7994.jpg" alt=""></p><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>插槽用于组件接收模板内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧&lt;/p&gt;
&lt;h1 id=&quot;vue3概要&quot;&gt;&lt;a href=&quot;#vue3概要&quot; class=&quot;headerlink&quot; title=&quot;vue3概要&quot;&gt;&lt;/a&gt;vue3概要&lt;/h1&gt;&lt;p&gt;Vue是一套前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/"/>
    <id>http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/</id>
    <published>2024-09-07T07:10:34.612Z</published>
    <updated>2024-09-09T13:14:35.219Z</updated>
    
    <content type="html"><![CDATA[<p>每次学新东西，就想到当初选JAVA后端，我就想扇自己<br>一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了<br>虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦<br>为什么不能docker一键安装docker呢</p><h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>Docker是一款应用容器引擎，可以帮助我们快速部署和搭建<br>Docker需要在Linux环境下运行，所以需要虚拟机搭建环境</p><p>使用Docker的前提当然是搭建虚拟机了<br>具体安装虚拟机和Docker可看<a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d</a></p><h2 id="基于Docker安装mysql"><a href="#基于Docker安装mysql" class="headerlink" title="基于Docker安装mysql"></a>基于Docker安装mysql</h2><p>只需要一条命令即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d \</span><br><span class="line">&gt;   --name mysql \</span><br><span class="line">&gt;    -p 3306:3306 \</span><br><span class="line">&gt;    -e TZ=Asia/Shanghai \</span><br><span class="line">&gt;    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">&gt;    mysql</span><br></pre></td></tr></table></figure><br><img src="https://t.tutu.to/img/0mlwr" alt=""><br>以上就是Docker安装mysql，真是太简单了，我大一安装mysql可是一直出错，安装了一整天了<br>Docker安装部署这么容易是因为Docker下载的是已经部署好的mysql镜像，而且Docker运行这些镜像的时候<br>会创建一个隔离环境，称为容器。所以同时运行多个镜像也是可以的<br>正是因为如此Docker可以解决依赖兼容问题<br><img src="https://pic.imgdb.cn/item/639872ecb1fccdcd3695de9e.jpg" alt=""></p><h2 id="Docker的常见命令"><a href="#Docker的常见命令" class="headerlink" title="Docker的常见命令"></a>Docker的常见命令</h2><ol><li>docker run 创建并运行镜像</li><li>-d 让镜像在后台运行<br>如果不加 -d 镜像会在控制台执行，不能进行其他操作直到停止</li><li>-p 端口映射<br>因为我们的Docker是在Linux虚拟机上部署的，假设虚拟机的IP是192.168.150.101.<br>Docker运行镜像会创建单独的容器，其实这个容器也是有IP地址的，但是我们直接访问容器的IP会失败<br>所以会进行映射，通过访问虚拟机的IP端口映射到容器的IP端口<br><img src="https://t.tutu.to/img/0mtW6" alt=""></li><li>-e 设置环境变量 格式为 KEY=VALUE<br>具体的环境变量需要查看Docker的镜像官网</li><li>—name 设置镜像的名称</li><li>docker pull 从镜像仓库拉取镜像到本地仓库</li><li>docker images 查看本地镜像</li><li>docker rmi 删除本地镜像</li><li>docker push 将本地镜像推送到镜像仓库</li><li>docker stop 停止容器</li><li>docker start 启动容器</li><li>docker ps 查看容器运行状态</li><li>docker rm 删除容器</li><li>docker exec -it 容器名 bash 通过命令行操作容器</li></ol><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><ol><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录的之间映射的桥梁；<br>数据卷解决的问题：docker为我们下载的镜像文件只包含了该文件运行所需要的依赖环境，<br>所以如果我们通过docker exec -it 容器名 bash命令进入该容器去操作容器内文件时，<br>会发现容器内并没有 vi 等操作文件的命令，所以我们不能在容器里操作容器里的文件<br>因此数据卷可以为我们解决这个问题<br>解决的原理     ：数据卷可以进行双向映射，创建数据卷目录，然后分别对应容器中的目录和<br>虚拟机docker中的目录，映射成功后，通过操作虚拟机中的目录就可以达到操作容器目录的效果<br>数据卷对应的虚拟机目录一般都在volume目录下<br><img src="https://pic.imgdb.cn/item/66dd5deed9c307b7e9d22582.png" alt=""> <h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><img src="https://pic.imgdb.cn/item/66dd5f38d9c307b7e9d538f6.png" alt=""><h2 id="数据卷映射目录"><a href="#数据卷映射目录" class="headerlink" title="数据卷映射目录"></a>数据卷映射目录</h2>docker run -v 数据卷名（自定义）：容器目录</li><li>docker run 是创造并执行容器，所以如果一个容器已经被创造，但是没有挂载数据卷，即就不能挂载数据卷或者会自动挂载一个匿名卷</li><li>如果执行该命令的时候数据卷不存在，会自动创建，数据卷会和虚拟机volums目录下和数据卷同名的文件目录自动挂载，<h2 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h2>使用命令：docker run -v 本地目录（自定义）：容器目录</li><li>本地目录必须以 / 或者 ./开头</li><li>和数据卷挂载的区别：直接将本地目录 和容器目录挂载，本地目录不需要是在volume目录下<h3 id="本地挂载mysql"><a href="#本地挂载mysql" class="headerlink" title="本地挂载mysql"></a>本地挂载mysql</h3></li><li>创建对应的文件夹<br><img src="https://pic.imgdb.cn/item/66deb3c1d9c307b7e9dd1fc9.png" alt=""></li><li>将提前准备好的sql语句脚本和dockerfile文件导入mysql文件夹</li><li>运行命令<br>记得前提把上面示例创造的mysql容器删除，不然会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66deb4b5d9c307b7e9de2474.png" alt=""><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3>镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。</li></ol><h3 id="docker镜像的结构"><a href="#docker镜像的结构" class="headerlink" title="docker镜像的结构"></a>docker镜像的结构</h3><ol><li>基础镜像是通用的，因为是分层结构，所以其他镜像也可以使用<br><img src="https://pic.imgdb.cn/item/66dd7842d9c307b7e9ff4976.png" alt=""></li><li>设置镜像结构 Dockerfile<br><img src="https://pic.imgdb.cn/item/66dd7934d9c307b7e901e387.png" alt=""><h3 id="尝试自定义镜像"><a href="#尝试自定义镜像" class="headerlink" title="尝试自定义镜像"></a>尝试自定义镜像</h3></li><li>编写Dockerfile<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像</span><br><span class="line">FROM openjdk:11.0-jre-buster</span><br><span class="line"># 设定时区</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"># 拷贝jar包</span><br><span class="line">COPY docker-demo.jar /app.jar</span><br><span class="line"># 入口</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure></li><li>将准备好的demo.jar和Dockerfile上传到虚拟机中</li><li>执行 docker build -t docker-demo .<br>-t :给镜像命名<br>. :表示当前路径，如果不在上传的demo文件下，需要指定demo的位置</li><li>执行 docker run -d —name dd -p 8080:8080 docker-dome<br><img src="https://pic.imgdb.cn/item/66dd7b60d9c307b7e90673d4.png" alt=""><br>如图成功，访问8080端口<br><img src="https://pic.imgdb.cn/item/66dd7bc7d9c307b7e906e7ab.png" alt=""></li></ol><h2 id="容器网络互联"><a href="#容器网络互联" class="headerlink" title="容器网络互联"></a>容器网络互联</h2><p>如果在创建容器的时候没有指定网段IP，docker会通过网桥自动分配给容器一个IP，但是容器关闭后，这个IP会被分配给其他容器<br><img src="https://pic.imgdb.cn/item/66deb600d9c307b7e9df983f.png" alt=""></p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>加入自定义网络的容器可以通过容器名互相访问<br><img src="https://pic.imgdb.cn/item/66deb669d9c307b7e9e00690.png" alt=""><br>创建自定义网络 hmall<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create hmall</span><br></pre></td></tr></table></figure><br>使mysql处于自定义网络中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect hmall mysql</span><br></pre></td></tr></table></figure></p><h2 id="部署JAVA应用"><a href="#部署JAVA应用" class="headerlink" title="部署JAVA应用"></a>部署JAVA应用</h2><ol><li>对JAVA应用打包，将写好的dockerfile和jar导入虚拟机root目录下<br><img src="https://pic.imgdb.cn/item/66deba94d9c307b7e9e842f0.png" alt=""></li><li>构建镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hmall .</span><br></pre></td></tr></table></figure></li><li>创造运行容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hmall --network hmall -p 8080:8080 hmall</span><br></pre></td></tr></table></figure>本地浏览器访问<br><img src="https://pic.imgdb.cn/item/66debb41d9c307b7e9ea3f41.png" alt=""><h2 id="部署前端应用"><a href="#部署前端应用" class="headerlink" title="部署前端应用"></a>部署前端应用</h2>emmm~,这个最后一步一直报错 404，花了一下无，给我气红温了，就先跳过了<h2 id="一键部署DockerCompose"><a href="#一键部署DockerCompose" class="headerlink" title="一键部署DockerCompose"></a>一键部署DockerCompose</h2>DockerCompose是通过一个单独的YAML格式的文件来定义一组相关联的应用容器，帮<br>助我们实现多个相互关联的Docker容器的快速部署。<br>右边即是YAML格式的容器等同于左边<br><img src="https://pic.imgdb.cn/item/66def3b0d9c307b7e94885ac.png" alt=""><br><img src="https://pic.imgdb.cn/item/66def40ad9c307b7e949b63a.png" alt=""><br>将准备好的YAML文件传入虚拟机中，再执行 docker compose up 即可一键部署</li></ol><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>Docker并不作为JAVA后端的一个重点，再加上最近有些浮躁，很难静下心来，所以学的有点粗糙，<br>也想早点开启下一章微服务的学习<br>Docker就作为了解吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每次学新东西，就想到当初选JAVA后端，我就想扇自己&lt;br&gt;一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了&lt;br&gt;虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦&lt;br&gt;为什么不能docker一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MybatisPlus</title>
    <link href="http://example.com/2024/09/06/MybatisPlus/"/>
    <id>http://example.com/2024/09/06/MybatisPlus/</id>
    <published>2024-09-06T05:46:45.235Z</published>
    <updated>2024-09-07T10:28:42.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识MybatisPlus"><a href="#初识MybatisPlus" class="headerlink" title="初识MybatisPlus"></a>初识MybatisPlus</h1><p>MybatisPlus的特点</p><ol><li>可以对现有工程只做增强不做改变，引入MybatisPlus后Mybatis的代码依旧可以使用</li><li>方便快捷实现对单表的增删改查</li><li>功能丰富 例如 代码生成，自动分页，自动填充<h2 id="使用MybatisPlus"><a href="#使用MybatisPlus" class="headerlink" title="使用MybatisPlus"></a>使用MybatisPlus</h2></li><li>引入MybatisPlus<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>自定义的Mapper 继承MybatisPlus提供的BaseMapper<br> 注意：BaseMapper需要指定实体类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MybatisPlus的常用注解"><a href="#MybatisPlus的常用注解" class="headerlink" title="MybatisPlus的常用注解"></a>MybatisPlus的常用注解</h2></li><li>@TableName : 用于指定表名<br>当实体类名和数据库表名不一致的时候使用</li><li>@TableId :用于指定表中的主键字段信息<br>可以指定主键的憎长类型，共有三种，（AUTO）数据库自增长，(INPUT)get方式输入,（ASSIGN_ID）自带的雪花算法<br>若不指定则默认为yaml配置的方式</li><li>@TableFieId :用于指定表中的普通字段信息<br>直接上图<br><img src="https://www.helloimg.com/i/2024/09/04/66d81e5d52204.png" alt=""></li></ol><h2 id="MybatisPlus的配置"><a href="#MybatisPlus的配置" class="headerlink" title="MybatisPlus的配置"></a>MybatisPlus的配置</h2><p><img src="https://www.helloimg.com/i/2024/09/04/66d820a887981.png" alt=""></p><h1 id="MybatisPlus的条件构造器"><a href="#MybatisPlus的条件构造器" class="headerlink" title="MybatisPlus的条件构造器"></a>MybatisPlus的条件构造器</h1><p>MybatisPlus提供了三种条件构造器</p><ol><li>QueryWrapper<br>提供了很多关于查询的条件方法,方法很多就不一一展示了，通过一个示例简单说明一下<br><img src="https://www.helloimg.com/i/2024/09/04/66d826f608f60.png" alt=""><br>将图中sql可简化为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper queryWrapper = new QueryWrapper&lt;User&gt;()</span><br><span class="line">             .select(&quot;id&quot;,&quot;username&quot;,&quot;info&quot;,&quot;balance&quot;).like(&quot;username&quot;,&quot;o&quot;)</span><br><span class="line">             .gt(&quot;blance&quot;,1000);</span><br><span class="line"></span><br><span class="line">      List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure></li><li>UpdateWrapper<br>提供了更新的条件方法<br><img src="https://www.helloimg.com/i/2024/09/04/66d82981d5053.png" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;()</span><br><span class="line">             .setSql(&quot;balance =balance - 200&quot;).in(&quot;id&quot;,&quot;1,2,4&quot;);</span><br><span class="line"></span><br><span class="line">     userMapper.update(null,updateWrapper);</span><br></pre></td></tr></table></figure><img src="https://www.helloimg.com/i/2024/09/04/66d8262a6963d.png" alt=""></li></ol><h1 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h1><p><img src="https://www.helloimg.com/i/2024/09/05/66d966d0eb1d4.png" alt=""><br>MybatisPuls提供了IService接口更帮助我们实现对单表的增删改查<br>使用IService接口需要两步</p><ol><li>自定义的XXXService接口去继承Iservice接口</li><li>XXXService的实现类XXXServiceImpl实现Service的同时也要继承IService的实现类<br>注意！！ XXXServiceImpl继承IService的实现类的时候需要给IService的实现类两个参数</li><li>第一个参数所对应的Mapper接口，因为在IService的实现类里面是需要引入对应的mapper<br> 即IService里面很多方法底层还是通过MybatisPuls提供的Mapper的方法实现</li><li>第二个参数为对应的实体对象<br>例如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService extends IService&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IService的应用"><a href="#IService的应用" class="headerlink" title="IService的应用"></a>IService的应用</h2>IService提供更多的方法供我们使用，同样这么多方法也就不一一介绍了<br>值得一提的是IService提供的批量插入方法saveBeach方法<br>假设我们需要像数据库中插入10000条数据</li><li>单条数据插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void test1() &#123;</span><br><span class="line">        long a =System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt;10000 ; i++) &#123;</span><br><span class="line">            Test1 test =new Test1();</span><br><span class="line">            test.setUser(i);</span><br><span class="line">            test.setName(&quot;test&quot;+i);</span><br><span class="line">            tsetService.save(test);</span><br><span class="line">        &#125;</span><br><span class="line">        long b =System.currentTimeMillis();</span><br><span class="line">        System.out.println(b-a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>最后耗时10180毫秒</li><li>批量插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void test2() &#123;</span><br><span class="line">        long a =System.currentTimeMillis();</span><br><span class="line">        List&lt;Test1&gt; list =new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;10000 ; i++) &#123;</span><br><span class="line">            Test1 test =new Test1();</span><br><span class="line">            test.setUser(i);</span><br><span class="line">            test.setName(&quot;test&quot;+i);</span><br><span class="line">            list.add(test);</span><br><span class="line">            if (list.size()==100) &#123;</span><br><span class="line">                tsetService.saveBatch(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long b =System.currentTimeMillis();</span><br><span class="line">        System.out.println(b-a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>最后耗时264毫秒，显著提升了50倍速度！！！<br>当然啦这还不是最快的</li><li>MYSQL的rewriteBatchedStatements=true<br>在配置数据库的url后面添加rewriteBatchedStatements=true 即可<br>代码与上面代码相同不变<br>最后耗时202毫秒，由于我直插入了10000条数据所以性能不明显，数据越多明显越大</li></ol><p>最后再来说一下rewriteBatchedStatements=true的作用</p><ol><li>如果不加，我们操作会是将一千条数据封装到list中，由list传入数据库，然后每一条数据执行一次insert语句<br>所以提升速度的原因是减少了连接数据库的次数</li><li>加上rewriteBatchedStatements=true后，list传入后数据库只需要执行一次insert语句，因为者一千条数据会进行拼接</li></ol><h2 id="DB静态工具"><a href="#DB静态工具" class="headerlink" title="DB静态工具"></a>DB静态工具</h2><p>介绍之前先看几个需求,前置条件，用户和地址是两个表，用外键链接<br><img src="https://www.helloimg.com/i/2024/09/06/66db1b101f551.png" alt=""><br>根据已经学习到的知识，如果我们想解决第一个问题就需要</p><ol><li>在UserService中不仅仅调用自己的IService提供的方法，也需要调用AddressService<br>(当然啦也可以调用AddressMapper)</li><li>解决第三个问题呢就需要在AddressService中调用UserService,这样互相调用的话，业务复杂<br>很多个Service层或者Mapper互相调用很大可能会造成循环依赖<br>为了解决循环依赖问题，MybatisPlus提供了DB静态工具(注意：需要3.5.0版本以上)</li><li>DB提供了和IService几乎一摸一样的方法 不过在调用DB的时候需要将所对应的实体类传入<br>利用DB解决问题1<br><img src="https://www.helloimg.com/i/2024/09/06/66db2070aef10.png" alt=""></li></ol><h2 id="JOSN处理器"><a href="#JOSN处理器" class="headerlink" title="JOSN处理器"></a>JOSN处理器</h2><p>作用：如果数据库表中有字段类型为JOSN时，可以使用Mybatis提供的JOSN处理器，简化开发<br>普通方法我会用一个String类型的变量去接收 表中JOSN类型的字段，但是这样后续业务处理比较麻烦<br>使用JSON处理器可以解决这个问题，需要三步</p><ol><li>定义一个表中JOSN类型字段锁对应的实体类，用这个实体类类型的变量去接收</li><li>同时需要使用@TableFiled中添加JOSN处理器 即typeHandler=JacksonTypeHandler.class</li><li>在@TableName中加上 autoResultMap =true 返回映射<br><img src="https://www.helloimg.com/i/2024/09/07/66dbc04951e2e.png" alt=""></li></ol><h2 id="MybatisPlus的分页功能"><a href="#MybatisPlus的分页功能" class="headerlink" title="MybatisPlus的分页功能"></a>MybatisPlus的分页功能</h2><p>MybatisPlus提供了很多拓展功能其中较为常用的就是分页功能</p><ol><li><p>分页功能的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisConfig &#123;</span><br><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">    // 1.初始化核心插件</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    // 2.添加分更插件 和指定数据库类型</span><br><span class="line">    PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MysOL)</span><br><span class="line">    pageInterceptor.setMaxLimit(1000L);//设置分页上限</span><br><span class="line">    interceptor.addInnerInterceptor(pagenterceptor);</span><br><span class="line">    return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解：先new一个MybatisPlus的拦截器对象，在new一个分页对象并设置初始值添加到拦截器中</p></li><li><p>分页功能的基本使用</p><ol><li>这是简单封装了一个PageVO,用于处理分页查询后的数据，方便返回前端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pubilc class PageVO&lt;T&gt;&#123;</span><br><span class="line">    public Ingter pages;</span><br><span class="line">    public Ingter total;</span><br><span class="line">    public List&lt;T&gt; list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>简单使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public PageVO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;</span><br><span class="line">    String name = query.getName();</span><br><span class="line">    Integer status = query.getstatus();</span><br><span class="line">    //1.构建分页条件</span><br><span class="line">    // 1.1.分页条件 Page.of()需要两个参数 一个当前的页数，一个每页查询的数据量</span><br><span class="line">    Page&lt;User&gt;page = Page.of(query.getPageNo(),query.getPagesize());</span><br><span class="line">    // 1.2.排序条件</span><br><span class="line">    page.addorder(new orderItem(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    //1 2.分页查询</span><br><span class="line">    Page&lt;User&gt; p=lambdaQuery()</span><br><span class="line">    .like( condition: name != null, User::getUsername, name)</span><br><span class="line">    .eq( condition: status != null, User::getstatus, status)</span><br><span class="line">    .page(page);</span><br><span class="line">    // 处理数据</span><br><span class="line">    PageVO(UserVO)  pagevo =new PageVO()</span><br><span class="line">    pagevo.setPages(p.getPages);</span><br><span class="line">    pagevo.setTotal(p.getTotal);</span><br><span class="line">    List&lt;User&gt; list = p.getRecords();</span><br><span class="line">    List&lt;UserVO&gt; vo= BeanUtil.copyToList(list,UserVo.class)</span><br><span class="line">    pagevo.setlist(vo);</span><br><span class="line">    return pagevo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上就是一个分页查询用户的简单例子<br>在实际功能中 构建分页条件 排序条件 处理数据 这三个步骤在多次分页中代码基本相同<br>所以其实可以将这几部分代码抽取成三个工具类，使用到这几个步骤的时候直接调用对应的工具类</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识MybatisPlus&quot;&gt;&lt;a href=&quot;#初识MybatisPlus&quot; class=&quot;headerlink&quot; title=&quot;初识MybatisPlus&quot;&gt;&lt;/a&gt;初识MybatisPlus&lt;/h1&gt;&lt;p&gt;MybatisPlus的特点&lt;/p&gt;
&lt;ol&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis学习</title>
    <link href="http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-03T02:34:21.000Z</published>
    <updated>2024-09-06T07:15:18.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis雪崩"><a href="#redis雪崩" class="headerlink" title="redis雪崩"></a>redis雪崩</h1><p>  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>  对key的过期时间进行调整，防止大量key同时失效，最简单的方法对key的过期时间统一成 固定时间+random</p><h1 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h1><p>   缓存击穿是指一个非常 “热” 的 key（通常是被频繁访问的数据）在某个时间点过期，此时若有大量并发请求过来，这些请求发现缓存中没有数据，就会同时去数据库查询该数据，对数据库造成巨大的压力。</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><pre><code>在高并发下，只有获取锁成功的线程才会去查询数据库，并更新缓存，其他线程则等待一段时间。</code></pre><h4 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h4><p>   利用redis中的nx命令自定义实现锁<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Boolean trylock(String key)&#123;</span><br><span class="line">    Boolean falg = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.MINUTES);</span><br><span class="line">    return BooleanUtil.isTrue(falg);</span><br><span class="line">&#125;</span><br><span class="line">public void unlock(String key)&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><pre><code>当一个线程执行到这里时，会先从缓存中查询，则会先进入StrUtil.isNotBlank(s)判断，StrUtil.isNotBlank()的作用为判断是否字符串是否不为空且不为仅包含空白字符的方法；如果为true,则说明缓存中存在且不为空，直接返回。如果为false，则说明缓存中不存在或者值为空，即进入下一个判断，如果是s！=null为true，说明缓存中存在s,但是s的值为空所以返回null,当s！=null为false后尝试获取锁，获取锁失败则等待重试，获取锁成功则查询数据库，如果数据库中存在则写入缓存中，如果不存在则向缓存中写入空值，这样可以保证在高并发的情况下只有获取锁成功的线程会访问数据库</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Shop queryWithMutex(Long id) &#123;</span><br><span class="line">    String key = RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    //从redis中查询</span><br><span class="line">    String s = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    if (StrUtil.isNotBlank(s)) &#123;</span><br><span class="line">        return JSONUtil.toBean(s, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否为空值</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //不存在尝试获取锁</span><br><span class="line">    String lockkey = &quot;lock:shop:&quot; + id;</span><br><span class="line">    Boolean islock = trylock(lockkey);</span><br><span class="line">    Shop shop=null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取锁不成功则等待反复尝试</span><br><span class="line">        if (!islock) &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            return queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不存在查询数据库</span><br><span class="line">        shop = getById(id);</span><br><span class="line">        //模拟实际</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        if (shop != null) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库</span><br><span class="line">        else &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock(lockkey);</span><br><span class="line">    &#125;</span><br><span class="line">    return shop;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><pre><code>设置逻辑过期时间，这样可以保证key永远存在，只需要判断是否逻辑过期进行更形即可</code></pre><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>  查询一个一定不存在的数据，由于缓存中没有该数据，所有的请求都会落到数据库上，导致数据库压力瞬间增大。如果有人利用这个漏洞不断发起这种查询，就可能使数据库因承受不住大量请求而崩溃。</p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-添加NULL值"><a href="#1-添加NULL值" class="headerlink" title="1 添加NULL值"></a>1 添加NULL值</h3><p><img src="https://www.helloimg.com/i/2024/09/03/66d6b0ae1fcda.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Shop redisPassThrought(Long id) &#123;</span><br><span class="line">        String key =RedisConstants.CACHE_SHOP_KEY+id;</span><br><span class="line">        //从redis中查询</span><br><span class="line">        String s= stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        if (StrUtil.isNotBlank(s)) &#123;</span><br><span class="line">            return JSONUtil.toBean(s,Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否为空值</span><br><span class="line">        if (s!=null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不存在查询数据库</span><br><span class="line">        Shop shop =getById(id);</span><br><span class="line">        if (shop != null)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库</span><br><span class="line">        else &#123; stringRedisTemplate.opsForValue().set(key,&quot;&quot;,RedisConstants.CACHE_NULL_TTL);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="Redis分布式锁-："><a href="#Redis分布式锁-：" class="headerlink" title="Redis分布式锁 ："></a>Redis分布式锁 ：</h1><h2 id="1-自定义分布式锁："><a href="#1-自定义分布式锁：" class="headerlink" title="1 自定义分布式锁："></a>1 自定义分布式锁：</h2><pre><code>  调用该方法的时候需要new一个RedisLock的对象，并传入两个需要的参数key</code></pre><h3 id="原理-："><a href="#原理-：" class="headerlink" title="原理 ："></a>原理 ：</h3><pre><code> 利用Redis中的NX命令判断是否存在，不存在则创建，存在创建会失败  注意 ： 返回值是Boolean类型时,不建议直接返回对象success，自动拆箱可能会空指针</code></pre><p>自定义分布式锁：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleRedisLock implements ILock &#123;</span><br><span class="line">    //锁的前缀</span><br><span class="line">    private static final String KEY_PREFIX = &quot;lock:&quot;;</span><br><span class="line">    //具体业务名称，将前缀和业务名拼接之后当做Key</span><br><span class="line">    private String name;</span><br><span class="line">    //这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeoutSec) &#123;</span><br><span class="line">        //获取线程标识</span><br><span class="line">        long threadId = Thread.currentThread().getId();</span><br><span class="line">        //获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br><span class="line">        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        //自动拆箱可能会出现null，这样写更稳妥</span><br><span class="line">        return Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        //通过DEL来删除锁</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>业务逻辑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //1. 查询优惠券</span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    //2. 判断秒杀时间是否开始</span><br><span class="line">    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 判断秒杀时间是否结束</span><br><span class="line">    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    // 创建锁对象</span><br><span class="line">    SimpleRedisLock redisLock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br><span class="line">    // 获取锁对象</span><br><span class="line">    boolean isLock = redisLock.tryLock(120);</span><br><span class="line">    // 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="line">    if (!isLock) &#123;</span><br><span class="line">        return Result.fail(&quot;不允许抢多张优惠券&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取代理对象</span><br><span class="line">        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        return proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h4><ol><li><p>逻辑说明<br>持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放<br>此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到<br>但是现在线程1阻塞完了，继续往下执行，要开始释放锁了<br>那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</p></li><li><p>解决方案<br>解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。<br>假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁<br><img src="https://www.helloimg.com/i/2024/09/04/66d87a2c99d06.png" alt=""></p><h4 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">      public class RedisLock &#123;</span><br><span class="line">    private static  final  String KEY_PREFIX = UUID.randomUUID().toString(true)+&quot;-&quot;;</span><br><span class="line">    private String key;</span><br><span class="line">    private StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public RedisLock(String key, StringRedisTemplate redisTemplate) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean tryLock(Long timeout) &#123;</span><br><span class="line">        //获取锁的时候将该线程标识（UUID+线程Id）存入缓存中，释放锁是判断，防止误删</span><br><span class="line">       String threadId = KEY_PREFIX +Thread.currentThread().getId();</span><br><span class="line">       Boolean success= redisTemplate.opsForValue().setIfAbsent(key, threadId , timeout, TimeUnit.SECONDS);</span><br><span class="line">       return Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        String threadId = KEY_PREFIX +Thread.currentThread().getId();</span><br><span class="line">         String id = redisTemplate.opsForValue().get(key);</span><br><span class="line">         if(threadId.equals(id)) &#123;</span><br><span class="line">             redisTemplate.delete(key);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redisson-可重入锁"><a href="#Redisson-可重入锁" class="headerlink" title="Redisson 可重入锁"></a>Redisson 可重入锁</h2><p>基于SETNX实现的分布式锁存在以下问题</p><ol><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li><li>重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的</li><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患</li><li>主从一致性<br>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题<h2 id="那么什么是Redisson呢"><a href="#那么什么是Redisson呢" class="headerlink" title="那么什么是Redisson呢"></a>那么什么是Redisson呢</h2>Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现<br>Redis提供了分布式锁的多种多样功能</li></ol></li><li>可重入锁(Reentrant Lock)</li><li>公平锁(Fair Lock)</li><li>联锁(MultiLock)</li><li>红锁(RedLock)</li><li>读写锁(ReadWriteLock)</li><li>信号量(Semaphore)</li><li>可过期性信号量(PermitExpirableSemaphore)</li><li>闭锁(CountDownLatch)</li></ol><h3 id="需要提前导入依赖坐标"><a href="#需要提前导入依赖坐标" class="headerlink" title="需要提前导入依赖坐标"></a>需要提前导入依赖坐标</h3><h3 id="对其进行配置"><a href="#对其进行配置" class="headerlink" title="对其进行配置"></a>对其进行配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//配置Redisson，用于分布式锁</span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient RedissonClient() &#123;</span><br><span class="line">        //配置</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class="line">        //创建RedissonClient对象</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void testRedisson() throws InterruptedException &#123;</span><br><span class="line">    //获取可重入锁</span><br><span class="line">    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);</span><br><span class="line">    //尝试获取锁，三个参数分别是：获取锁的最大等待时间(期间会重试)，锁的自动释放时间，时间单位</span><br><span class="line">    boolean success = lock.tryLock(1,10, TimeUnit.SECONDS);</span><br><span class="line">    //判断获取锁成功</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;执行业务&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理的话要读源码，读不懂一点好吧，太难读了。等我回头学会了再来补充。<br>目前只知道一点Redisson可重入的原理大概是 采用了hash结构存储锁，外层key代表锁存在，<br>内层key代表是线程的标识 即一个方法会先获取外层key，如果锁存在，则该方法继续获取<br>内层key,如果内层key和自己的线程标识相同，则获取锁成功，此时value +1,方法执行完后<br>也不是直接释放锁，而是value -1，直到value =0时才释放锁</p><h1 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>  字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<br>  消息队列：存储和管理消息，也被称为消息代理（Message Broker）<br>  生产者：发送消息到消息队列<br>  消费者：从消息队列获取消息并处理消息</p><h2 id="使用队列的好处在于解耦："><a href="#使用队列的好处在于解耦：" class="headerlink" title="使用队列的好处在于解耦："></a>使用队列的好处在于解耦：</h2><p>  举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br>  那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br>  这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</p><h2 id="redis基于List的消息队列"><a href="#redis基于List的消息队列" class="headerlink" title="redis基于List的消息队列"></a>redis基于List的消息队列</h2><p> 消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果<br>  队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。<br> 不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或 者BLPOP来实现阻塞效果</p><h3 id="基于List的消息队列有哪些优缺点？"><a href="#基于List的消息队列有哪些优缺点？" class="headerlink" title="基于List的消息队列有哪些优缺点？"></a>基于List的消息队列有哪些优缺点？</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)<h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息<br>SUBSCRIBE channel [channel]：订阅一个或多个频道<br>PUBLISH channel msg：向一个频道发送消息<br>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li></ol><h3 id="基于PubSub的消息队列有哪些优缺点"><a href="#基于PubSub的消息队列有哪些优缺点" class="headerlink" title="基于PubSub的消息队列有哪些优缺点"></a>基于PubSub的消息队列有哪些优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>采用发布订阅模型，支持多生产，多消费</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不支持数据持久化<br>2 .无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）<br>3 .消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）<h2 id="Stream的单消费模式"><a href="#Stream的单消费模式" class="headerlink" title="Stream的单消费模式"></a>Stream的单消费模式</h2><img src="https://www.helloimg.com/i/2024/09/03/66d6ef96a5d79.jpg" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID</span><br><span class="line">XADD users * name jack age 21</span><br></pre></td></tr></table></figure></li></ol><p>读取队列方法之一 ：XREAD<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure></p><ol><li>[COUNT count]<br>每次读取消息的最大数量</li><li>[BLOCK milliseconds]<br>当没有消息时，是否阻塞，阻塞时长</li><li>STREAMS key [key …]<br>要从哪个队列读取消息，key就是队列名</li><li>ID [ID …]<br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始</li></ol><p>注意：<br> 当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题</p><h3 id="STREAM类型消息队列的XREAD命令特点"><a href="#STREAM类型消息队列的XREAD命令特点" class="headerlink" title="STREAM类型消息队列的XREAD命令特点"></a>STREAM类型消息队列的XREAD命令特点</h3><ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol><h2 id="Sream的组消费模式"><a href="#Sream的组消费模式" class="headerlink" title="Sream的组消费模式"></a>Sream的组消费模式</h2><pre><code>将多个消费者划分为一组，监听一个队列</code></pre><h3 id="1-消息分流"><a href="#1-消息分流" class="headerlink" title="1.消息分流"></a>1.消息分流</h3><p>队列中消息分给组内不同的消费者，而不是重复消费者（也可以消费者重复去执行）提高效率</p><h3 id="2-消息标识"><a href="#2-消息标识" class="headerlink" title="2. 消息标识"></a>2. 消息标识</h3><p>消费者在读取一个消息后，会给该消息添加一个标识，从而可以记录到最后被处理的消息，即使消费者宕机。重启后可以<br>继续从标识的地方继续读取，直到消费者执行完毕该消息，进行确认后，该消息才会被消息队列移除，确保了每个消息最少执行一遍</p><h3 id="3。消息确认"><a href="#3。消息确认" class="headerlink" title="3。消息确认"></a>3。消息确认</h3><p>消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</p><h2 id="基于Stream实现异步秒杀"><a href="#基于Stream实现异步秒杀" class="headerlink" title="基于Stream实现异步秒杀"></a>基于Stream实现异步秒杀</h2><pre><code>异步秒杀所以需要子线程中消费队列思路：在子线程中一直循环，循环中该线程指定g1组的消费者c1读取Stream中的消息，然后判断读取的消息是否为空，为空则进行下一次循环，不为空则解析消息中的数据，得到需要的对象，然后创建订单，订单完成后进行消息确认消息队列会移除该消息，如果执行过程中出现异常，就会先捕捉异常，然后执行pending-list中的消息，因为出现异常消息被读取加上标识，但是并未确定，所以会在pending-list中。读取消息，判断是否为空，不为空则创建订单，确认消息，如果为空说明pending-list中没有消息，直接break。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">String queuename =&quot;stream.order&quot;;</span><br><span class="line">private class  VoucherOrderHander implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          while(true)&#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  //1.2 stream</span><br><span class="line">                  //获取消息队列中的信息</span><br><span class="line">                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(&quot;g1&quot;, &quot;c1&quot;),</span><br><span class="line">                          //.count(1) 表示只读取一个元素， .block(Duration.ofSeconds(2))表示如果没有消息则等待两秒,</span><br><span class="line">                          StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),</span><br><span class="line">                          // ReadOffset.lastConsumed()表示从最新元素开始读取</span><br><span class="line">                          StreamOffset.create(queuename, ReadOffset.lastConsumed()));</span><br><span class="line">                  //判断是否获取成功</span><br><span class="line">                  if (list ==null || list.isEmpty())&#123;</span><br><span class="line">                      continue;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //解析信息</span><br><span class="line">                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(0);</span><br><span class="line">                  Map&lt;Object,Object&gt; value = mapRecord.getValue();</span><br><span class="line">                 VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, new VoucherOrder(),true);</span><br><span class="line">                  //创建订单</span><br><span class="line">                  porxy.CreateVoucher1(voucherOrder);</span><br><span class="line">                  //xack确认</span><br><span class="line">                  stringRedisTemplate.opsForStream().acknowledge(queuename,&quot;g1&quot;,mapRecord.getId());</span><br><span class="line">              &#125; catch (Exception e) &#123;</span><br><span class="line">                  log.info(&quot;异步订单&quot;,e);</span><br><span class="line">                  //获取消息队列中的信息</span><br><span class="line">                  //0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span><br><span class="line">                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(&quot;g1&quot;, &quot;c1&quot;),</span><br><span class="line">                          StreamReadOptions.empty().count(1),</span><br><span class="line">                          StreamOffset.create(queuename,ReadOffset.from(&quot;0&quot;)));</span><br><span class="line">                  //判断是否获取成功</span><br><span class="line">                  if (list ==null || list.isEmpty())&#123;</span><br><span class="line">                     break;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //解析信息</span><br><span class="line">                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(0);</span><br><span class="line">                  Map&lt;Object,Object&gt; value = mapRecord.getValue();</span><br><span class="line">                  VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, new VoucherOrder(),true);</span><br><span class="line">                  //创建订单</span><br><span class="line">                  porxy.CreateVoucher1(voucherOrder);</span><br><span class="line">                  //xack确认</span><br><span class="line">                  stringRedisTemplate.opsForStream().acknowledge(queuename,&quot;g1&quot;,mapRecord.getId());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p> 主线程中的异步秒杀的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*  Long userId = UserHolder.getUser().getId();</span><br><span class="line">        long orderId= redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        //执行lua脚本</span><br><span class="line">        Long result = stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(),String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        //判断是否为0</span><br><span class="line">        int r = result.intValue();</span><br><span class="line">        if (r!=0)&#123;</span><br><span class="line">            return Result.fail(r==1? &quot;库存不足&quot; : &quot;不能重复下单&quot;) ;</span><br><span class="line">        &#125;</span><br><span class="line">        porxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        return Result.ok(orderId); </span><br></pre></td></tr></table></figure><br>Lua脚本的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 订单id</span><br><span class="line">local voucherId = ARGV[1]</span><br><span class="line">-- 用户id</span><br><span class="line">local userId = ARGV[2]</span><br><span class="line">-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的</span><br><span class="line">local id = ARGV[3]</span><br><span class="line">-- 优惠券key</span><br><span class="line">local stockKey = &#x27;seckill:stock:&#x27; .. voucherId</span><br><span class="line">-- 订单key</span><br><span class="line">local orderKey = &#x27;seckill:order:&#x27; .. voucherId</span><br><span class="line">-- 判断库存是否充足</span><br><span class="line">if (tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then</span><br><span class="line">    return 1</span><br><span class="line">end</span><br><span class="line">-- 判断用户是否下单</span><br><span class="line">if (redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then</span><br><span class="line">    return 2</span><br><span class="line">end</span><br><span class="line">-- 扣减库存</span><br><span class="line">redis.call(&#x27;incrby&#x27;, stockKey, -1)</span><br><span class="line">-- 将userId存入当前优惠券的set集合</span><br><span class="line">redis.call(&#x27;sadd&#x27;, orderKey, userId)</span><br><span class="line">-- 将下单数据保存到消息队列中</span><br><span class="line">redis.call(&quot;sadd&quot;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, id)</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure><br>redis的学习就先到这里吧，时间紧任务重就要先去学微服务啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis雪崩&quot;&gt;&lt;a href=&quot;#redis雪崩&quot; class=&quot;headerlink&quot; title=&quot;redis雪崩&quot;&gt;&lt;/a&gt;redis雪崩&lt;/h1&gt;&lt;p&gt;  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
  </entry>
  
</feed>

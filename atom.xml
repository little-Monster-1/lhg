<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Little Monste&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2026-01-11T00:00:00.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小怪兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQ重复消费问题</title>
    <link href="http://example.com/2026/01/11/InternshipDiary/MQ/"/>
    <id>http://example.com/2026/01/11/InternshipDiary/MQ/</id>
    <published>2026-01-11T00:00:00.000Z</published>
    <updated>2026-01-11T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近上班比较忙，一直没来写日记。趁周末来记录一下最近遇到的一个奇葩问题。</p><ul><li>场景：线上出现bug导致 2025.12.27 - 2025.12.29号的MQ消息处理失败了。我在29号晚上将代码修复后，新的消息可以正常处理了。所以需要将这两天的MQ的消息重新处理一下。30号我写了一个task,将这两天的消息重新发给MQ，让消费者重新处理。我观察了一下27号的消息处理成功后，就没放在心上。结果消费者一直在重复消费27号的消息。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>问题1: 消费记录没有报错异常，为什么会重复消费</li><li>问题2: 为什么只重复消费27号的消息，之后的消息去哪了？</li><li>问题3: 1.4号我将重复消费的消息id 发给阿里那边工作人员，阿里告诉我这条30号发送的消息，已经投递了17次了，并且全部没有ACK，导致这条消息进了死信队列，并删除了。哪为什么我在1.4号还能收到这条消息的消费记录？<br><p align="center">阿里回复</p><br><img src="https://pic1.imgdb.cn/item/69632afb75db907620f21292.png" alt=""><br><p align="center">日志中确实显示今天又收到了一次消费信息</p><br><img src="https://pic1.imgdb.cn/item/69632b4775db907620f21293.png" alt=""></li><li>问题4: 阿里说 收到了1.4号发的消息，同样的也是投递了17次 无响应被删除了，但是我并没有收到1.4号的消息。那么这些消息去哪了？<br><p align="center">除了27号的消息，其他消息都投递次数过多被删除，但日志中完全搜不到消费记录</p><br><img src="https://pic1.imgdb.cn/item/69632be775db907620f2129c.png" alt=""></li></ul><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p><img src="https://pic1.imgdb.cn/item/69632f4375db907620f22d03.png" alt=""></p><p>在原本的消费者代码中 收到消息会直接去执行业务逻辑，有些消息处理的快，有些处理很慢（五六小时）。</p><ul><li>问题1: 消费记录没有报错异常，为什么会重复消费<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>因为超时了。MQ服务端 会将消息投放队列中，默认一次50个。默认一定时间如果无应答则会重新投放到队列中。假设消费者 是1个线程去处理。则如果第一个消息就超时很久很久，导致后面的消息还没处理，MQ服务端就认为这些消息已经全部超时了。会重新投递一次到队列中。 如果第一个消息没超时，第二条消息超时了，那么剩下 48条数据，就没有处理，就已经全部超时了</p></div></details></li><li>问题2，3，4<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p><img src="https://pic1.imgdb.cn/item/696331d475db907620f22d58.png" alt=""><br>这些消息并没有丢，而是阻塞住了。为什么一直在重复消费27号的？因为27号的消息，是我最先发出去的，但是因为有些消息处理很久，其实没有报错，处理完成后才会ACK，但这时候已经超时了。假设第一条消息就处理很久 导致这一批没有处理的消息也超时了。MQ服务端就会重新投递一次。 结果第一次投递的消息都没处理完。就导致第二次投递的消息完全超时了。结果就又投递了第三次，后面就是一直有消息超时，MQ服务端就认为前面投递的几次全超时了，就会投递下一次。最多投递17次。</p><p>消费者的表现就是： 刚处理完这一批50个消息，下一批还是这50个消息，下下一批还是这50个消息。下下下一批依旧是这50个消息。直到处理这50个消息处理17次，才会真正处理新的下一批消息，这也会导致新的下一批消息也在超时，重新投递。</p><p>这也就导致，阿里那边可看到的是消息已经投递次数过多，被删除了。但是我这边还在消费的情况。阿里那边之前还开过钉钉会议。我记得 他们说默认十分钟无应答就认为超时，会重新投递。</p></div></details></li></ul><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>不采用同步消费的方案。而是消费者收到消息后，将消息存入消息表。然后直接ACK。用定时任务去处理消息表中的消息，处理完成后改状态。一开始是单线程去处理的，结果处理速度赶不上进消息的速度，然后那个业务还给领导打我小报告！我真服啦。怎么这么烦人。后面又给他改成了采用线程池去处理加快了速度。好啦。问题结束！最近真的超想跳槽。干到过年就辞职吧</p>]]></content>
    
    
    <summary type="html">MQ异常消费奇葩问题</summary>
    
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>Data Lake</title>
    <link href="http://example.com/2025/12/06/InternshipDiary/%E6%95%B0%E6%8D%AE%E6%B9%96/"/>
    <id>http://example.com/2025/12/06/InternshipDiary/%E6%95%B0%E6%8D%AE%E6%B9%96/</id>
    <published>2025-12-06T00:00:00.000Z</published>
    <updated>2025-12-06T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Data-Lake"><a href="#什么是-Data-Lake" class="headerlink" title="什么是 Data Lake"></a>什么是 Data Lake</h1><ol><li><p>✅ 一句话解释：什么是数据湖？ （简单来说数据湖 是存放各种数据的地方）</p><ul><li>数据湖是一个能存放各种类型数据（结构化、半结构化、非结构化）的超大存储池，用来做大数据分析的。</li></ul></li><li><p>数据湖 和 MYSQL,Redis数据库的区别</p><ul><li>MYSQL 等数据库 是规则性数据库，存结构化数据， 而数据湖是所有数据都可存储 结构化，半结构化，非结构化 等所有数据 <ul><li>例如 MYSQL 不会存图片，视频。而是存的图片，视频的链接。数据湖可以直接存储图片 视频。</li></ul></li></ul></li><li><p>数据湖的宏观表现</p><ul><li>数据湖 其实就是一个文件夹 可以保存类型的数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs SQL">data<span class="hljs-operator">-</span>lake<span class="hljs-operator">/</span><br> │<br> ├── ods<span class="hljs-operator">/</span>              # 原始数据区（Enterprise ODS）<br> │   ├── mysql<span class="hljs-operator">/</span><br> │   │   ├── <span class="hljs-keyword">user</span><span class="hljs-operator">/</span><span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span><span class="hljs-operator">/</span>user_1.parquet<br> │   │   ├── <span class="hljs-keyword">order</span><span class="hljs-operator">/</span>...<br> │   ├── log<span class="hljs-operator">/</span><br> │   │   ├── app<span class="hljs-operator">/</span><span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-06</span><span class="hljs-comment">/*.log</span><br><span class="hljs-comment"> │   │   ├── nginx/2025-12-06/*.log</span><br><span class="hljs-comment"> │</span><br><span class="hljs-comment"> ├── dwd/              # 明细数据区（清洗后的）</span><br><span class="hljs-comment"> │   ├── user/</span><br><span class="hljs-comment"> │   ├── order/</span><br><span class="hljs-comment"> │</span><br><span class="hljs-comment"> ├── dws/              # 宽表层（预聚合）</span><br><span class="hljs-comment"> │   ├── order_summary/</span><br><span class="hljs-comment"> │</span><br><span class="hljs-comment"> ├── ads/              # 数据应用层（给 BI、可视化）</span><br><span class="hljs-comment"> │   ├── dashboard/</span><br></code></pre></td></tr></table></figure></li><li>对于结构化 半结构化的数据，也可以形成一张表，就像我们平常见到的MySQL表 <ul><li>例如这就是一张数据湖的表 但是不能用mysql的查看表结构语法查看 该表，数据湖的表也只支持根据主键id删除或者不删除。<br><img src="https://pic1.imgdb.cn/item/6937ef3af9354404e33fab8b.png" alt=""></li><li>当然数据湖的表 也可以执行SQL  但不是用 MySQL 引擎执行的</li></ul></li></ul></li></ol><div class="table-container"><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>能保存所有类型的数据</strong></td><td>不要求固定字段</td></tr><tr><td><strong>无限扩展</strong></td><td>TB~PB 级数据</td></tr><tr><td><strong>成本低</strong></td><td>一般用对象存储（如 MinIO、OSS、S3）</td></tr><tr><td><strong>支持数据分析</strong></td><td>可直接跑 SQL、AI、BI、大屏</td></tr><tr><td><strong>可以外挂计算引擎使用</strong></td><td>如 Spark、Flink、Presto、Doris</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>对比项</th><th>数据湖</th><th>MySQL</th></tr></thead><tbody><tr><td>数据类型</td><td><strong>所有数据</strong>（日志、图片、视频、JSON、CSV、表格）</td><td><strong>结构化表数据</strong></td></tr><tr><td>成本</td><td><strong>便宜</strong>（存储大文件很划算）</td><td><strong>贵</strong>（按行记录、索引维护）</td></tr><tr><td>查询方式</td><td>Spark / Flink / Presto / SQL on Lake</td><td>SQL</td></tr><tr><td>写入</td><td>批量、流式、文件导入</td><td>行级插入、更新、删除</td></tr><tr><td>适合场景</td><td>大数据分析、AI、数据仓库、离线批处理</td><td>业务系统、交易系统、订单、库存等</td></tr></tbody></table></div><h2 id="数据湖-与MYSQL的-区别"><a href="#数据湖-与MYSQL的-区别" class="headerlink" title="数据湖 与MYSQL的 区别"></a>数据湖 与MYSQL的 区别</h2><ol><li><p>🆚 一句话区别<br>MySQL 是在线事务处理（OLTP），数据湖是离线分析处理（OLAP）。<br>MySQL 适合存业务核心数据，数据湖适合存海量、多格式、不可丢的分析数据。</p><ul><li>mysql可以存几千万，一个亿 的书记，但是此时查询会很慢，必须加索引才能使用</li><li>数据湖可以存几个亿，TB级别的数据，在Spark/Trino 等分布式引擎跑的,也会比较快</li></ul></li></ol><div class="table-container"><table><thead><tr><th>项目</th><th><strong>数据湖（Data Lake）</strong></th><th><strong>MySQL</strong></th></tr></thead><tbody><tr><td>主要用途</td><td>大数据分析、AI、离线计算</td><td>在线业务系统（订单、商品、用户等）</td></tr><tr><td>数据格式</td><td>任意：CSV、JSON、Parquet、图片、视频</td><td>只能存表结构化数据</td></tr><tr><td>数据规模</td><td>PB 级</td><td>TB 级（再大就扛不住）</td></tr><tr><td>查询方式</td><td>Spark/Presto/Flink SQL（分布式）</td><td>MySQL 引擎（单机或主从）</td></tr><tr><td>事务能力</td><td>弱（依赖 Hudi/Iceberg）</td><td>强（ACID）</td></tr><tr><td>更新/删除</td><td>慢</td><td>快</td></tr><tr><td>查询类型</td><td>批量分析、宽表、报表、BI</td><td>单条、短查询、实时业务</td></tr><tr><td>成本</td><td>低（对象存储）</td><td>高（数据库存储）</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">数据湖</summary>
    
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="数据湖" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%B9%96/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB</title>
    <link href="http://example.com/2025/09/17/InternshipDiary/xxl-job/"/>
    <id>http://example.com/2025/09/17/InternshipDiary/xxl-job/</id>
    <published>2025-09-17T00:00:00.000Z</published>
    <updated>2025-09-17T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-XXL-JOB"><a href="#什么是-XXL-JOB" class="headerlink" title="什么是 XXL-JOB"></a>什么是 XXL-JOB</h1><p>XXL-JOB 是一个开源的 分布式任务调度平台，用来代替传统的 Quartz、Spring Task 等。</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>定时任务调度（支持 CRON 表达式）</li><li>分布式执行（多个执行器节点）</li><li>可视化任务管理（Web 控制台）</li><li>执行日志在线查看</li><li>失败重试 &amp; 失败告警</li><li>分片广播任务（支持大任务拆分成子任务并行执行）</li></ul><h1 id="📌-XXL-JOB-典型架构"><a href="#📌-XXL-JOB-典型架构" class="headerlink" title="📌 XXL-JOB 典型架构"></a>📌 XXL-JOB 典型架构</h1><ol><li>调度中心（xxl-job-admin）</li></ol><ul><li>提供任务管理后台（新建任务、修改、暂停、删除）</li><li>负责任务调度、分发给执行器</li><li>管理任务执行日志、失败告警等</li></ul><ol><li>执行器（xxl-job-executor）</li></ol><ul><li>部署在业务服务里</li><li>接收调度中心的任务调度请求</li><li>执行业务逻辑</li></ul><ol><li>调度中心和执行器通过 HTTP 通信。</li></ol><h1 id="📌-使用步骤"><a href="#📌-使用步骤" class="headerlink" title="📌 使用步骤"></a>📌 使用步骤</h1><ol><li>接入执行器 </li></ol><ul><li>在业务项目里引入 xxl-job-core 依赖</li><li>配置执行器信息（执行器名称、调度中心地址）<ul><li>nacos 或者 yaml文件配置</li></ul></li><li>编写任务方法（加上 @XxlJob(“handlerName”) 注解）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoJob</span> &#123;<br><br>    <span class="hljs-meta">@XxlJob(&quot;demoHandler&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demoJobHandler</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行任务: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><ol><li>登录 管理后台 配置执行器</li></ol><ul><li>选择执行器</li><li>填写 JobHandler 名称（比如 demoHandler）</li><li>配置 CRON 表达式（比如 0 0/5 <em> </em> * ? 每 5 分钟执行一次）</li><li>保存并启动任务</li></ul><p><img src="https://pic1.imgdb.cn/item/68ca7836c5157e1a88122cd5.png" alt=""><br><img src="https://pic1.imgdb.cn/item/68ca7816c5157e1a88122c19.png" alt=""><br><img src="https://pic1.imgdb.cn/item/68ca788fc5157e1a88122f8d.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>为什么 Spring Task 不适合分布式</li></ol><ul><li>因为 Spring Task 是基于JVM的，如果一个服务 有一个Spring Task 定时任务，但他有三个实例，那么这个定时任务会被三个实例都执行</li></ul><ol><li>为什么 XXL-JOB 适合 分布式</li></ol><ul><li>在 XXL-JOB 里，有一个独立的 调度中心（xxl-job-admin），负责统一下发任务，实例（执行器）只负责接收并执行。<ul><li>👉 这样即使部署多个节点，也不会发生 重复执行，因为调度中心可以确保只派发一次任务。<br><img src="https://pic1.imgdb.cn/item/68ca7de9c5157e1a88125462.png" alt=""></li></ul></li><li>📌 3. 分布式任务分片<ul><li>XXL-JOB 支持分片广播：</li><li>比如一个任务需要处理 1000 万条数据，可以拆成 10 份。</li><li>调度中心会把任务分成 10 片，分配给不同的执行器实例跑。</li><li>👉 分布式系统里最需要的就是这种 并行处理能力，Spring Task 天然做不到。</li></ul></li></ul><div class="table-container"><table><thead><tr><th>对比点</th><th>Spring Task</th><th>XXL-JOB</th></tr></thead><tbody><tr><td>部署方式</td><td>嵌入应用，随应用启动</td><td>独立调度中心 + 执行器（分布式）</td></tr><tr><td>定时配置</td><td>写在代码里，需重新发布</td><td>可视化管理后台，支持动态修改</td></tr><tr><td>集群支持</td><td>不支持（需自己加分布式锁）</td><td>原生支持，任务只会执行一次</td></tr><tr><td>扩展能力</td><td>弱，适合小规模</td><td>强，支持分片、路由策略、负载均衡</td></tr><tr><td>日志 &amp; 监控</td><td>自己实现</td><td>自带调度日志、执行日志、失败告警</td></tr><tr><td>使用场景</td><td>单机任务、轻量定时任务</td><td>分布式任务、复杂调度、大规模批处理</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">小怪兽的实习日记</summary>
    
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="XXL-JOB" scheme="http://example.com/tags/XXL-JOB/"/>
    
  </entry>
  
  <entry>
    <title>小怪兽的实习日记</title>
    <link href="http://example.com/2025/09/04/InternshipDiary/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>http://example.com/2025/09/04/InternshipDiary/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/</id>
    <published>2025-09-04T00:00:00.000Z</published>
    <updated>2025-09-04T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pdf-转图片"><a href="#pdf-转图片" class="headerlink" title="pdf 转图片"></a>pdf 转图片</h1><p>前景提示  需要用ai去校验数据，但是ai接口只支持单个图片，但是用户可以上传pdf，所以需要pdf转图片</p><h2 id="设计分析"><a href="#设计分析" class="headerlink" title="设计分析"></a>设计分析</h2><ol><li>url判断是否是 pdf<ul><li>否 直接调用ai接口</li><li>是 进行pdf下载<ul><li>pdf转图片 上传阿里云 获取到 图片链接<ul><li>用图片链接调用ai接口</li></ul></li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">cleanUrl</span> <span class="hljs-operator">=</span> StrUtil.subBefore(imageUrl, <span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 截掉 ? 后面</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">ext</span> <span class="hljs-operator">=</span> StrUtil.subAfter(cleanUrl, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">true</span>);   <span class="hljs-comment">// 取最后一个点后的部分</span><br>       String result;<br>       List&lt;String&gt; imagePaths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;pdf&quot;</span>.equalsIgnoreCase(ext)) &#123;<br>           System.out.println(<span class="hljs-string">&quot;pdf&quot;</span>);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> FilenameUtils.getName(cleanUrl);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">baseName</span> <span class="hljs-operator">=</span> FilenameUtils.getBaseName(originalFilename);<br>           <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(cleanUrl);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> url.getPath();<br>           <span class="hljs-comment">// 去掉最前面的 &#x27;/&#x27;</span><br>           <span class="hljs-keyword">if</span> (key.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>               key = key.substring(<span class="hljs-number">1</span>);<br>           &#125;<span class="hljs-comment">// 返回 /qualification/20250902/FILExxx.pdf</span><br>           <span class="hljs-comment">// 将pdf下载成IO流 调用转换方法，把 PDF 转成图片</span><br>           <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">pdfInputStream</span> <span class="hljs-operator">=</span> ossUploadService.downLoadFile4Qua(key)) &#123;<br>               List&lt;InputStream&gt; imageStrems = PdfToImageConverter.convertPdfToImages(pdfInputStream);<br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; imageStrems.size(); i++) &#123;<br>                   <span class="hljs-type">String</span> <span class="hljs-variable">fileNameAndType</span> <span class="hljs-operator">=</span> baseName + <span class="hljs-string">&quot;_page_&quot;</span> + i + <span class="hljs-string">&quot;.png&quot;</span>;<br>                   <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> ossUploadService.uploadFileToOssQualification(imageStrems.get(i), fileNameAndType, <span class="hljs-number">100L</span>);<br>                   <span class="hljs-type">String</span> <span class="hljs-variable">previewUrl</span> <span class="hljs-operator">=</span> fileUploadService.getPreviewUrlForQualification(path);<br>                   imagePaths.add(previewUrl);<br>               &#125;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;png&quot;</span>.equalsIgnoreCase(ext) || <span class="hljs-string">&quot;jpg&quot;</span>.equalsIgnoreCase(ext) || <span class="hljs-string">&quot;jpeg&quot;</span>.equalsIgnoreCase(ext)) &#123;<br>           imagePaths.add(imageUrl);<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="pdf转图片方法"><a href="#pdf转图片方法" class="headerlink" title="pdf转图片方法"></a>pdf转图片方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;InputStream&gt; <span class="hljs-title function_">convertPdfToImages</span><span class="hljs-params">(InputStream pdfInputStream)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    List&lt;InputStream&gt; imageStreams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">PDDocument</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> PDDocument.load(pdfInputStream)) &#123;<br>        <span class="hljs-type">PDFRenderer</span> <span class="hljs-variable">renderer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PDFRenderer</span>(document);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalPages</span> <span class="hljs-operator">=</span> document.getNumberOfPages();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; totalPages; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> renderer.renderImageWithDPI(i, <span class="hljs-number">200</span>);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(os.toByteArray());<br>            imageStreams.add(is);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> imageStreams;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="webclient-异步调用ai接口"><a href="#webclient-异步调用ai接口" class="headerlink" title="webclient 异步调用ai接口"></a>webclient 异步调用ai接口</h1><p>因为需要校验的数据很多，为了较短 的响应时间 所以采用异步的方式</p><ol><li>Mono 和 Flux 的定义<br>它们来自 Project Reactor（Spring WebFlux 的响应式编程库）：</li></ol><ul><li>Mono<T><ul><li>表示 一个异步计算的结果，这个结果要么是：恰好一个值（比如一个字符串，一个对象）或者没有值（empty）</li></ul></li><li>Flux<T><ul><li>表示 一个异步的数据流，可能包含 0、1 或多个元素。</li></ul></li></ul><h2 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h2><ol><li>Mono.just(…)<ul><li>表示创建一个 Mono，里面包着一个已经有的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Mono&lt;String&gt; mono = Mono.just(<span class="hljs-string">&quot;Hello&quot;</span>);<br>mono.subscribe(System.out::println); <span class="hljs-comment">// 打印 Hello</span><br></code></pre></td></tr></table></figure></li></ul></li><li>Tuples.of(field, data)<ul><li>Spring Reactor 提供了一个 Tuples 工具类，可以创建 Tuple（二元组，三元组…）。<ul><li>Tuple2<T1, T2> 表示两个元素。</li><li>Tuple3<T1, T2, T3> 表示三个元素。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Tuple2&lt;String, Integer&gt; t = Tuples.of(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>System.out.println(t.getT1()); <span class="hljs-comment">// age</span><br>System.out.println(t.getT2()); <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h2 id="（阻塞-vs-响应式）"><a href="#（阻塞-vs-响应式）" class="headerlink" title="（阻塞 vs 响应式）"></a>（阻塞 vs 响应式）</h2><ol><li>传统阻塞写法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 同步等待结果，直到 WebClient 完成请求</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> client.get()<br>    .uri(<span class="hljs-string">&quot;/hello&quot;</span>)<br>    .retrieve()<br>    .bodyToMono(String.class) <span class="hljs-comment">// Mono&lt;String&gt;</span><br>    .block();                 <span class="hljs-comment">// 阻塞等待，返回 String</span><br></code></pre></td></tr></table></figure></li><li>响应式写法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Mono&lt;String&gt; resultMono = client.get()<br>    .uri(<span class="hljs-string">&quot;/hello&quot;</span>)<br>    .retrieve()<br>    .bodyToMono(String.class);<br><span class="hljs-comment">//这里 .subscribe(...) 就像注册了一个“回调”，等结果异步到了才处理。</span><br>resultMono.subscribe(data -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;收到结果: &quot;</span> + data);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="最终写法"><a href="#最终写法" class="headerlink" title="最终写法"></a>最终写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 1) 用来保存每个异步任务（每个任务最终产出 Tuple2&lt;field,data&gt;）</span><br>List&lt;Mono&lt;Tuple2&lt;String, String&gt;&gt;&gt; tasksWithField = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 2) WebClient 只构建一次，复用连接池</span><br><span class="hljs-type">WebClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> WebClient.builder()<br>        .baseUrl(BASE_URL)<br>        .build();<br><br><span class="hljs-keyword">for</span> (String imagePath : imagePaths) &#123;<br>    <span class="hljs-keyword">for</span> (String field : fields) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prompt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;解析出图片上的&quot;</span> + field + <span class="hljs-string">&quot;，我只要答案，不要其他字&quot;</span>;<br><br>        Map&lt;String, Object&gt; requestBody = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        requestBody.put(<span class="hljs-string">&quot;imageUrl&quot;</span>, imagePath);<br>        requestBody.put(<span class="hljs-string">&quot;prompt&quot;</span>, prompt);<br>        requestBody.put(<span class="hljs-string">&quot;responseFormat&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        requestBody.put(<span class="hljs-string">&quot;serviceProvider&quot;</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 3) 每个任务：调用远程 AI 服务，解析响应，如果有有效 data 则返回 Tuple2(field,data)，否则返回 empty</span><br>        Mono&lt;Tuple2&lt;String, String&gt;&gt; task = client.post()<br>                .uri(QUALIFICATIONS_AI_URI)<br>                .contentType(MediaType.APPLICATION_JSON)<br>                .bodyValue(requestBody)<br>                .retrieve()<br>                .bodyToMono(JsonNode.class)<br>                .flatMap(response -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> response.has(<span class="hljs-string">&quot;success&quot;</span>) ? response.get(<span class="hljs-string">&quot;success&quot;</span>).asText() : <span class="hljs-string">&quot;false&quot;</span>;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> response.has(<span class="hljs-string">&quot;data&quot;</span>) ? response.get(<span class="hljs-string">&quot;data&quot;</span>).asText() : <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(success) &amp;&amp; data != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-string">&quot;无&quot;</span>.equals(data)) &#123;<br>                        <span class="hljs-keyword">return</span> Mono.just(Tuples.of(field, data)); <span class="hljs-comment">// 带上 field 的有效结果</span><br>                    &#125;<br>                    <span class="hljs-keyword">return</span> Mono.empty(); <span class="hljs-comment">// 无效 -&gt; 不发出值</span><br>                &#125;)<br>                .onErrorResume(e -&gt; Mono.empty()); <span class="hljs-comment">// 网络/解析异常也转成 empty，避免流中断</span><br><br>        tasksWithField.add(task);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 4) 合并所有任务，收集成 Map&lt;field,data&gt;，再 block() 阻塞获取</span><br>Map&lt;String, String&gt; resultMap = Flux.merge(tasksWithField)<br>        .collectMap(Tuple2::getT1, Tuple2::getT2)<br>        .block();<br></code></pre></td></tr></table></figure></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;retStatus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;retMessage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;success&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;retData&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;品牌&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;无品牌&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;报告编号&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lhg040211&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h1><h2 id="前景提示"><a href="#前景提示" class="headerlink" title="前景提示"></a>前景提示</h2><p>在今天准备上线的日子，遇见的一个关于PageHelper的坑，以后要注意一下<br>PageHelper开启分页后会对下面的 sql就行分页，一开始我是放到了第二个SQL上面，但是这样并不合理，因为第一个SQL可能也会查出来很多的数据，这样对第二个分页就没有意义了，但是当我把   PageHelper.startPage(param.getPageNum(), param.getPageSize()) .setReasonable(false) ; 放到一个SQL上面时，skuList是有数据的，但是在最后一行使用 pageHelper 进行构建分页结果的时候 会构建失败 返回空数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">  <span class="hljs-comment">//1. 根据精准查询 先查出来sku信息</span><br>  List&lt;ProductSkuModel&gt; productSkuModels = <span class="hljs-built_in">this</span>.myDAO.getSkuInfoUnIonBySkus(param);<br>  List&lt;String&gt; skuNos = productSkuModels.stream().map(ProductSkuModel::getSkuNo).collect(Collectors.toList());<br><span class="hljs-comment">//  List&lt;String&gt; auditSkuNos = auditProductSkuModel.stream().map(ProductSkuAuditModel::getSkuNo).collect(Collectors.toList());</span><br><span class="hljs-comment">//&#x27;  skuNos.addAll(auditSkuNos);</span><br>  skuInfoMap = productSkuModels.stream()<br>          .collect(Collectors.toMap(ProductSkuModel::getSkuNo, x -&gt; x, (a, b) -&gt; a)); <span class="hljs-comment">// 避免重复 key</span><br>  <span class="hljs-comment">//2 通过sku查询 单据信息</span><br>  param.setSkuNos(skuNos);<br>  PageHelper.startPage(param.getPageNum(), param.getPageSize()) .setReasonable(<span class="hljs-literal">false</span>) ;<br>  skuList = <span class="hljs-built_in">this</span>.myDAO.getSkuByParamWithSkuInfo(param);<br><br>  Pager&lt;PrepareRecordSkuVo&gt; pager = Pager.build4Mybatis(skuList);<br></code></pre></td></tr></table></figure><ul><li>原因：Pager.build4Mybatis 需要一个page对象，但是我的开启分页放到第一个SQL上面，第二个SQL查询出来的就是一个普通集合了，所以会构建失败</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Pager&lt;T&gt; <span class="hljs-title function_">build4Mybatis</span><span class="hljs-params">(List&lt;T&gt; list)</span> &#123;<br>    Pager&lt;T&gt; pager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pager</span>&lt;T&gt;();<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> Page) &#123;<br>        Page&lt;T&gt; page = (Page)list;<br>        pager.setPageShow(page.getPageSize());<br>        pager.setNowPage(page.getPageNum());<br>        pager.setTotalNum(Math.toIntExact(page.getTotal()));<br>        pager.setResults(page.getResult());<br>        <span class="hljs-keyword">return</span> pager;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> pager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>PageHelper.startPage 需要放到最上面的SQL，因为可能会小表驱动大表</li><li>Pager.build4Mybatis 需要一个page类型的参数</li></ul><h1 id="线上数据太多导致查询失败"><a href="#线上数据太多导致查询失败" class="headerlink" title="线上数据太多导致查询失败"></a>线上数据太多导致查询失败</h1><h2 id="前景提示-1"><a href="#前景提示-1" class="headerlink" title="前景提示"></a>前景提示</h2><p>做了一个查询功能，中间设计了多个表的查询，在测试环境上数据比较少只有几千条数据，所以测试环境上一直测试的都没问题，结果到了上线的时候，发现线上查不出来数据，只有加索引的几个条件 查询会很快。在无条件查询的情况下 就会出现查询不出来数据的情况</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>最后解决是 将加索引的几个搜索条件变成了必填条件，这样就会走索引了，这解决方案不是很好，毕竟是限制了用户，但是这是当时紧急情况下的最好的解决方案考虑了，<br>因为 搜索条件有很多，很多字段是没有索引的，例如创建时间，模糊查询名称，一个模糊查询走索引不慢。但是数据量会查出来两百万条数据。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>线上数据量太大，不加条件，会进行全表扫面 速度极慢，让用户必须输入一些条件查询，进行走索引，加快查询速度</p><h1 id="MYSQL-UPDATE-知识补充"><a href="#MYSQL-UPDATE-知识补充" class="headerlink" title="MYSQL UPDATE 知识补充"></a>MYSQL UPDATE 知识补充</h1><p>在 UPDATE 中不能在子查询里再次引用同一张表。 例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span>  product_collect <span class="hljs-keyword">set</span> salePlats <span class="hljs-operator">=</span>&quot;marketing_saleplat_swan&quot; <br><span class="hljs-keyword">where</span> uuid <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> uuid <span class="hljs-keyword">from</span> product_collect <span class="hljs-keyword">where</span> productType <span class="hljs-keyword">in</span>(&quot;05&quot;,&quot;08&quot;,&quot;09&quot;))<br></code></pre></td></tr></table></figure><ul><li><p>为什么不可以呢？</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>MySQL 的执行方式是“一边读一边写”<ul><li>而 MySQL 在执行 UPDATE 时是这样工作的：按顺序扫描表 → 找到符合条件的行 → 更新它 。但同时，你又要求 MySQL 在更新过程中，再去读同一张可能正在被更新的表。</li></ul></li><li>MySQL 的扫描和更新顺序会破坏子查询结果<ul><li>由于 UPDATE 会修改表内容，子查询读取的数据可能：<ul><li>被 UPDATE 刚刚修改过</li><li>还没被更新</li><li>扫描顺序变化</li><li>甚至行可能被锁住<br>这会导致执行结果 不确定、不稳定、不安全。</li></ul></li></ul></li></ol></div></details></li><li><p>解决方法：</p></li></ul><ol><li>用子查询包一层 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> product_collect<br><span class="hljs-keyword">SET</span> salePlats <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;marketing_saleplat_swan&#x27;</span><br><span class="hljs-keyword">WHERE</span> uuid <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> uuid <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> uuid<br>        <span class="hljs-keyword">FROM</span> product_collect<br>        <span class="hljs-keyword">WHERE</span> productType <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;05&#x27;</span>,<span class="hljs-string">&#x27;08&#x27;</span>,<span class="hljs-string">&#x27;09&#x27;</span>)<br>    ) <span class="hljs-keyword">AS</span> tmp<br>);<br></code></pre></td></tr></table></figure>原因： 最里面的子查询 会形成一个临时表 tem</li><li>使用临时表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 1. 创建临时表，保存需要更新的 skuNo</span><br><span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> tmp <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> uuid, <span class="hljs-string">&#x27;marketing_saleplat_swan&#x27;</span> <span class="hljs-keyword">AS</span> newSalePlats<br><span class="hljs-keyword">FROM</span> product_collect<br><span class="hljs-keyword">WHERE</span> productType <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;05&#x27;</span>, <span class="hljs-string">&#x27;08&#x27;</span>, <span class="hljs-string">&#x27;09&#x27;</span>);<br><br><span class="hljs-comment">-- 2. 用 JOIN 更新</span><br><span class="hljs-keyword">UPDATE</span> product_collect pc<br><span class="hljs-keyword">JOIN</span> tmp t <span class="hljs-keyword">ON</span> pc.uuid <span class="hljs-operator">=</span> t.uuid<br><span class="hljs-keyword">SET</span> pc.salePlats <span class="hljs-operator">=</span> t.newSalePlats;<br><br><span class="hljs-comment">-- 3. 更新完成后删除临时表</span><br><span class="hljs-keyword">DROP</span> TEMPORARY <span class="hljs-keyword">TABLE</span> tmp;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">小怪兽的实习日记</summary>
    
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/tags/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL日记</title>
    <link href="http://example.com/2025/08/28/InternshipDiary/SQL%E6%97%A5%E8%AE%B0/"/>
    <id>http://example.com/2025/08/28/InternshipDiary/SQL%E6%97%A5%E8%AE%B0/</id>
    <published>2025-08-28T00:00:00.000Z</published>
    <updated>2025-08-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL知识"><a href="#SQL知识" class="headerlink" title="SQL知识"></a>SQL知识</h1><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>UNION 和 UNION ALL 用来 合并两个或多个 SELECT 查询的结果集，要求每个 SELECT 查询的 列数和列类型必须一致。 </p><div class="table-container"><table><thead><tr><th>操作</th><th>功能</th><th>去重情况</th><th>性能</th></tr></thead><tbody><tr><td><code>UNION</code></td><td>合并结果集，并自动去掉重复行</td><td>会去重</td><td>较慢（需要排序去重）</td></tr><tr><td><code>UNION ALL</code></td><td>合并结果集，不去重</td><td>不去重</td><td>快（直接合并）</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> table1<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> table2;<br></code></pre></td></tr></table></figure><h2 id="GROUP-CONCAT"><a href="#GROUP-CONCAT" class="headerlink" title="GROUP_CONCAT"></a>GROUP_CONCAT</h2><p>GROUP_CONCAT 是一个SQL 函数，用来将拼接字符传的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 拼接 name<br><span class="hljs-keyword">SELECT</span> GROUP_CONCAT(name) <span class="hljs-keyword">AS</span> names <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br># 去重拼接<br><span class="hljs-keyword">SELECT</span> GROUP_CONCAT(<span class="hljs-keyword">DISTINCT</span> name) <span class="hljs-keyword">AS</span> names <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br># 多字段拼接<br><span class="hljs-keyword">SELECT</span> GROUP_CONCAT(CONCAT(<span class="hljs-string">&#x27;ID=&#x27;</span>, id, <span class="hljs-string">&#x27;,NAME=&#x27;</span>, name) SEPARATOR <span class="hljs-string">&#x27;; &#x27;</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br><br></code></pre></td></tr></table></figure><h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><ul><li>IN 会走索引吗？</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>答：走索引，MySQL 会把它当成多个 id = ? 的等值查询。<br>IN 的数量太大，超过表数据的四分之一时，会有全表扫描</p></div></details></li></ul><h1 id="SQL规范"><a href="#SQL规范" class="headerlink" title="SQL规范"></a>SQL规范</h1><ol><li><p>非主子表尽量不要连表查询</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>非主子表一般没有 一对多关系，或者外键关联的表。用join 极大可能会走全表扫面。使SQL速度很慢。</li><li>join 会使SQL 耦合较高，不好维护。</li></ul></div></details></li><li><p>多表 JOIN 时，尽量选择结果集较小（过滤后行数少）的表作为驱动表（Driving Table）</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>驱动表：先被读取、做循环的那张表</li><li>被驱动表：根据驱动表的行去匹配的表<br>-SQL执行的时候，会先去查 驱动表的数据，然后循环每一条数据，去匹配他表。所以 小表作为驱动表，可以使循环次数最少<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs S">for(驱动表每一行)&#123;<br>   去被驱动表匹配<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></div></details></li><li>update 语句 禁止携带 limit <details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>可能导致主从不一致。<br>主从数据库采用 Statement-Based Replication（SBR，语句复制） 时，binlog记录sql语句，同步到主表。主库和从库更新的数据可能不一样，如果没有明确指定 id<br>              Row-Based Replication（RBR，行复制） 记录的是一整行的数据，相对安全</p></div></details></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <summary type="html">SQL实习日记</summary>
    
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="SQL日记" scheme="http://example.com/tags/SQL%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>jenkins</title>
    <link href="http://example.com/2025/08/28/InternshipDiary/jenkins/"/>
    <id>http://example.com/2025/08/28/InternshipDiary/jenkins/</id>
    <published>2025-08-28T00:00:00.000Z</published>
    <updated>2025-08-28T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Jenkins 是一个 开源的自动化持续集成/持续交付（CI/CD）工具，用来帮助开发团队 自动化构建、测试、部署软件。 </p><h1 id="🔹-核心作用"><a href="#🔹-核心作用" class="headerlink" title="🔹 核心作用"></a>🔹 核心作用</h1><ol><li>持续集成（CI）<ul><li>当开发人员提交代码到 GitHub/GitLab/SVN 时，Jenkins 可以自动拉取代码、编译、运行单元测试，快速发现问题。</li></ul></li><li>持续交付（CD）<ul><li>在代码构建和测试完成后，Jenkins 可以自动将应用部署到测试环境、预生产环境甚至生产环境，实现“一键上线”。</li></ul></li><li>任务调度<ul><li>Jenkins 不止能跑构建任务，还可以做一些定时任务，例如每天自动跑测试、定时备份数据库等。</li></ul></li></ol><h1 id="🔹-主要特点"><a href="#🔹-主要特点" class="headerlink" title="🔹 主要特点"></a>🔹 主要特点</h1><ol><li>插件丰富：Jenkins 有上千个插件，可以集成 Git、Maven、Gradle、Docker、Kubernetes、SonarQube 等。</li><li>跨平台：支持 Windows、Linux、macOS，只要有 Java 环境就能跑。</li><li>可视化管理：提供 Web 界面，可以方便地配置流水线任务。</li><li>支持流水线（Pipeline as Code）：用 Jenkinsfile（Groovy 语法）来描述构建/部署流程，代码化管理。</li></ol><h1 id="🔹-工作流程"><a href="#🔹-工作流程" class="headerlink" title="🔹 工作流程"></a>🔹 工作流程</h1><ol><li>开发提交代码到 Git → 指定分支</li><li>Jenkins 触发任务（手动/定时/自动 webhook）→<ul><li>手动：<ul><li>找到模块<br><img src="https://pic1.imgdb.cn/item/68b11f0f58cb8da5c85ee09d.png" alt=""></li><li>更新<br><img src="https://pic1.imgdb.cn/item/68b11fd358cb8da5c85ee0e3.png" alt=""></li></ul></li></ul></li><li>拉取代码并执行构建脚本（Maven/Gradle/npm 等）（jenkins会自动拉取代码）→</li><li>执行测试（单元测试、接口测试）→</li><li>构建产物（jar、war、apk 等）→</li><li>部署到测试/生产环境。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    <summary type="html">了解jenkins</summary>
    
    
    
    <category term="小怪兽的实习日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="jenkins" scheme="http://example.com/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://example.com/2025/08/08/studyDiary/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2025/08/08/studyDiary/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2025-08-08T00:00:00.000Z</published>
    <updated>2025-08-08T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序-平均时间复杂度为-O-n-log-n-，最坏为-O-n-2"><a href="#快速排序-平均时间复杂度为-O-n-log-n-，最坏为-O-n-2" class="headerlink" title="快速排序 平均时间复杂度为 O(n log n)，最坏为 O(n^2)"></a>快速排序 平均时间复杂度为 O(n log n)，最坏为 O(n^2)</h1><ul><li>📌 快速排序步骤（以升序为例）<ul><li>使用两个指针：left 和 right</li><li>选定一个基准值 pivot</li><li>left 从左往右找大于等于 pivot的元素</li><li>right 从右往左找小于等于 pivot的元素</li><li>→ 交换它们</li><li>重复直到 left &gt;= right，此时返回 right（注意不是 left）</li></ul></li></ul><p>示例演示:</p><ul><li>初始数组 [6, 3, 1, 5, 2, 4]  pivot = 6</li><li>第1次递归<ul><li>第 1 轮：<ul><li>i 从 -1 ➜ 0（arr[0]=6 ≥ pivot）✅ 停止</li><li>j 从 6 ➜ 5（arr[5]=4 ≤ pivot）✅ 停止</li><li>i &lt; j 成立，交换 index=0 和 5 → 6 ↔ 4</li><li>数组变为：[4, 3, 1, 5, 2, 6]</li></ul></li><li>第 2 轮：<ul><li>i 从 1 ➜  i=5 ➜ arr[5]=6 == pivot ✅ 停止</li><li>j 从 5 ➜ 4（arr[4]=2 ≤ 6）✅ 停止</li><li>i=5 &gt;= j=4，循环结束，返回 j=4</li></ul></li><li>结果: [4, 3, 1, 5, 2 | 6]   pivotIndex = 4</li></ul></li><li>第2次递归：略</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hoarePartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[left];  <span class="hljs-comment">// Hoare 方法通常选最左边为 pivot</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 从左往右找 &gt;= pivot 的元素</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            i++;<br>        &#125; <span class="hljs-keyword">while</span> (arr[i] &lt; pivot);<br><br>        <span class="hljs-comment">// 从右往左找 &lt;= pivot 的元素</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            j--;<br>        &#125; <span class="hljs-keyword">while</span> (arr[j] &gt; pivot);<br><br>        <span class="hljs-comment">// 如果指针交错，分区完成</span><br>        <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>            <span class="hljs-keyword">return</span> j; <span class="hljs-comment">// 注意这里返回的是 j</span><br>        &#125;<br><br>        <span class="hljs-comment">// 交换 arr[i] 和 arr[j]</span><br>        swap(arr, i, j);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> hoarePartition(arr, left, right);<br>        quickSort(arr, left, pivotIndex);     <span class="hljs-comment">// 注意包含 pivotIndex</span><br>        quickSort(arr, pivotIndex + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="冒泡排序-平均时间复杂度为-O-n²-，最坏为-O-n²"><a href="#冒泡排序-平均时间复杂度为-O-n²-，最坏为-O-n²" class="headerlink" title="冒泡排序  平均时间复杂度为 O(n²)，最坏为 O(n²)"></a>冒泡排序  平均时间复杂度为 O(n²)，最坏为 O(n²)</h1><p>冒泡排序的核心思想是： 重复地比较相邻的两个元素，如果它们的顺序错误就交换它们的位置。</p><ul><li><p>📊 示例过程演示<br>  以数组 [5, 3, 4, 1, 2] 为例，执行冒泡排序的过程如下：</p><ul><li><p>第 1 趟（把最大的冒到最后）：</p><ul><li>比较 5 和 3 → 交换 → [3, 5, 4, 1, 2]</li><li>比较 5 和 4 → 交换 → [3, 4, 5, 1, 2]</li><li>比较 5 和 1 → 交换 → [3, 4, 1, 5, 2]</li><li>比较 5 和 2 → 交换 → [3, 4, 1, 2, 5] ✅</li></ul></li><li><p>第 2 趟：</p><ul><li>比较 3 和 4 → 不换</li><li>比较 4 和 1 → 交换 → [3, 1, 4, 2, 5]</li><li>比较 4 和 2 → 交换 → [3, 1, 2, 4, 5] ✅</li></ul></li><li>第 3 趟：<ul><li>比较 3 和 1 → 交换 → [1, 3, 2, 4, 5]</li><li>比较 3 和 2 → 交换 → [1, 2, 3, 4, 5] ✅<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">boolean</span> swapped;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        swapped = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 本轮是否有交换</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123; <span class="hljs-comment">// 每次都可以少比较1个</span><br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 交换 arr[j] 和 arr[j+1]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = temp;<br>                swapped = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果某一轮没有发生交换，说明已经有序，可以提前结束</span><br>        <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h1 id="选择排序-平均时间复杂度为-O-n²-，最坏为-O-n²"><a href="#选择排序-平均时间复杂度为-O-n²-，最坏为-O-n²" class="headerlink" title="选择排序 平均时间复杂度为 O(n²)，最坏为 O(n²)"></a>选择排序 平均时间复杂度为 O(n²)，最坏为 O(n²)</h1><p>每一轮从未排序部分中找出最小（或最大）的元素，放到已排序部分的末尾。</p><ul><li>📊 示例演示<br>  对数组 [5, 3, 4, 1, 2] 使用选择排序的过程如下：<ul><li>第 1 趟（从索引 0 开始）：<ul><li>找出最小值是 1，索引为 3</li><li>交换 arr[0] 和 arr[3]</li></ul></li><li>第 2 趟（从索引 1 开始）：<ul><li>找出最小值是 2，索引为 4</li><li>交换 arr[1] 和 arr[4]</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">// 假设当前位置是最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j; <span class="hljs-comment">// 找到更小的值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 交换当前位置和最小值的位置</span><br>        <span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
    <summary type="html">排序算法总结</summary>
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis面试总结</title>
    <link href="http://example.com/2025/08/04/interview/redis/"/>
    <id>http://example.com/2025/08/04/interview/redis/</id>
    <published>2025-08-04T00:00:00.000Z</published>
    <updated>2025-08-04T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面试官: redisson的看门狗机制是怎么实现的</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>Redisson 的看门狗机制就是通过 HashedWheelTimer 创建一个后台定时任务，每 10 秒续约一次 Redis 锁的 TTL，从而保证业务未完成时锁不会被误释放。<br>实现原理:</p><ul><li>设置定时任务，每十秒检查一次</li><li>如果锁存在且线程id是当前线程id,则重置过期时间<br>🧪看门狗续期过程图示：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>时间轴（秒）:<br>|--0----10----20----30----40----50----60----&gt;<br>|  加锁   🔁   🔁   🔁<br>|         ↑    ↑    ↑<br>|       续期  续期  续期<br><br></code></pre></td></tr></table></figure></li></ul></div></details></li></ul><ul><li>面试官: 什么是BigKey</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>定义:单个键对应的数据量非常大，无论是字符串值很长，还是集合/列表等容器类型包含大量元素。</li><li>影响：大 key 会导致 内存占用高、网络传输慢、阻塞事件循环、集群迁移困难 等一系列性能和稳定性问题。</li><li>解决： <ul><li>拆分成多个KV，比如一个 10MB 的 JSON，拆成多个 user:1001:part:1、user:1001:part:2。</li><li>定期清理</li></ul></li></ul></div></details></li><li><p>面试官: redis的持久化机制有哪些？</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>RDB: 每过一段时间会将数据通过子线程写入磁盘中<ul><li>优点：性能要求小，恢复速度快</li><li>缺点：在上一次快照之后宕机，数据会丢失。</li></ul></li><li>AOF:记录每一条写命令和删除命令，将每次写命令（set、hset、lpush 等）追加到 AOF 文件末尾。<ul><li>优点：丢失数据的可能性小</li><li>缺点： 占用内存大，性能要求高</li></ul></li></ul></div></details></li><li><p>面试官: 持久化有两种，那么该怎么选择呢？</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>采用RDB+AOF组合的方式: 恢复数据的时候先通过RDB去恢复，AOF只记录在上一次快照之后的写操作，然后AOF在恢复</p></div></details></li><li><p>面试官: redis的分片集群(Redis Cluster 模式)有了解吗</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>分片:把全量 key 按某种算法拆分成多个片段，每个片段放在不同的 Redis 实例中。</p><ul><li>数据分片：<ul><li>Redis 集群固定有 16384 个槽位（编号 0 ~ 16383）。</li><li>每个槽位分配给某个主节点（Master）。</li><li>Key 存储时：<ul><li>计算key的哈希值，获取槽位号，存入槽位所在的主节点<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">槽位 0-5460   -&gt; Master A<br>槽位 5461-10922 -&gt; Master B<br>槽位 10923-16383 -&gt; Master C<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>读写流程：<ul><li>客户端可惜向任意节点读取信息<ul><li>如果数据正好在该节点，则读取数据</li><li>如果不在该节点，则返回数据所在的节点的信息，重新读取</li></ul></li></ul></li></ul></div></details></li></ul>]]></content>
    
    
    <summary type="html">redis的面试题</summary>
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>spring面试总结</title>
    <link href="http://example.com/2025/07/18/interview/spring%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2025/07/18/interview/spring%E9%9D%A2%E8%AF%95/</id>
    <published>2025-07-18T00:00:00.000Z</published>
    <updated>2025-07-18T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-篇"><a href="#spring-篇" class="headerlink" title="spring 篇"></a>spring 篇</h1><h2 id="spring-IOC-（控制反转）"><a href="#spring-IOC-（控制反转）" class="headerlink" title="spring IOC （控制反转）"></a>spring IOC （控制反转）</h2><p>📖 定义：<br>IoC（Inversion of Control，控制反转）是一种 设计思想，指的是对象的创建与依赖关系的管理不再由程序员控制，而是交由容器（如 Spring）来管理。</p><ul><li>🔧 二、传统写法 vs IoC 思想<br>👎 传统写法（耦合度高）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Saving user&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();  <span class="hljs-comment">// 手动创建依赖</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness</span><span class="hljs-params">()</span> &#123;<br>        userDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>👍 使用 IoC：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Saving user&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;  <span class="hljs-comment">// 自动注入</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBusiness</span><span class="hljs-params">()</span> &#123;<br>        userDao.save();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>⚙️ 五、Spring IoC 容器的底层流程（重要）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs t">1. 扫描（@ComponentScan）<br>2. 注册（@Component、@Service 等注解）<br>3. 创建 Bean（反射）<br>4. 依赖注入（@Autowired）<br>5. 初始化（@PostConstruct）<br>6. 容器准备好，开发者调用 getBean() 获取 Bean 使用<br></code></pre></td></tr></table></figure></p><p>🔄 更准确的说法：<br>IoC 容器启动时，会：</p><ul><li>扫描或加载所有配置的类（如 @Component、XML <bean>）。</li><li>将这些类信息 注册为 BeanDefinition。</li><li>当程序需要某个对象（比如 UserService）时，Spring 会：</li><li>检查它的依赖（比如 UserRepository）。</li><li>自动创建依赖（通过反射）并注入（DI）进来。</li><li>这整个流程，是 IoC 的体现：我们不再手动 new 依赖，而是让容器帮我们创建并注入。</li></ul><h2 id="spring事务的传播机制"><a href="#spring事务的传播机制" class="headerlink" title="spring事务的传播机制"></a>spring事务的传播机制</h2><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>Spring 提供了 7 种传播行为，定义在 org.springframework.transaction.annotation.Propagation 枚举中。</p><div class="table-container"><table><thead><tr><th>传播行为</th><th>描述</th></tr></thead><tbody><tr><td><code>REQUIRED</code>（默认）</td><td><strong>有事务则加入</strong>，没有则新建事务。常用。</td></tr><tr><td><code>REQUIRES_NEW</code></td><td><strong>挂起当前事务</strong>，<strong>新建事务</strong>，互不影响。</td></tr><tr><td><code>NESTED</code></td><td>嵌套事务，<strong>内层异常只回滚自身</strong>，不影响外层。</td></tr><tr><td><code>SUPPORTS</code></td><td>有事务就加入，没事务就以非事务方式运行。</td></tr><tr><td><code>NOT_SUPPORTED</code></td><td>不支持事务，有事务则挂起，用非事务方式运行。</td></tr><tr><td><code>NEVER</code></td><td>不允许有事务，否则抛异常。</td></tr><tr><td><code>MANDATORY</code></td><td>必须在事务中运行，没有事务就抛异常。</td></tr></tbody></table></div><p>1️⃣ REQUIRED（默认）<br>A 有事务，B 就加入；<br>A 无事务，B 就新建事务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>    methodB(); <span class="hljs-comment">// 会加入 methodA 的事务</span><br>&#125;<br></code></pre></td></tr></table></figure></p></div></details><h2 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h2><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>1️⃣ 方法不是 public 的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123; ... &#125;  <span class="hljs-comment">// ❌ 不生效</span><br></code></pre></td></tr></table></figure>原因：Spring AOP 只能拦截 public 方法。非 public 方法不会被代理，自然事务不生效。</li><li>2️⃣ 方法被内部调用(在同一个java类中)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>   methodB(); <span class="hljs-comment">// 内部方法调用，事务不生效</span><br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure>原因：Spring AOP 是基于代理对象实现的，this.methodB() 这种内部调用不会走代理，事务不会生效。<ul><li>✅ 正确做法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Service self; <span class="hljs-comment">// 注入自身代理对象</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>   self.methodB(); <span class="hljs-comment">// 用代理调用才能生效</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>3️⃣ 异常被捕获了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// 可能抛异常的代码</span><br>   &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>       <span class="hljs-comment">// 异常被吃掉</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>原因:Spring 默认只在 运行时异常（RuntimeException）或 Error 时才回滚，且异常要能抛出，不能被吞掉。<br>✅ 正确做法：</li></ul><ol><li>异常不要随便吃掉，或者手动 throw</li><li>或者加 @Transactional(rollbackFor = Exception.class) 明确声明回滚类型</li></ol><ul><li>4️⃣ 事务方法没有被 Spring 管理（比如 new 出来的类）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserService</span>(); <span class="hljs-comment">// ❌ 非 Spring Bean</span><br>userService.saveUser(); <span class="hljs-comment">// 事务不会生效</span><br></code></pre></td></tr></table></figure>原因:Spring 只能代理容器内的 Bean，new 出来的对象是普通对象，事务无效。</li><li>5️⃣多线程导致事务失效<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 数据库操作</span><br>    &#125;).start();<br>&#125;<br><br></code></pre></td></tr></table></figure>原因:Spring 的事务是线程绑定的，开启事务的线程和新线程不是同一个，事务无效。</li></ul></div></details><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>实例化（new）<br>   ↓<br>属性注入（依赖注入）<br>   ↓<br>BeanPostProcessor（初始化前置处理）<br>   ↓<br>初始化方法（如 @PostConstruct / init-method）<br>   ↓<br>BeanPostProcessor（初始化后置处理）<br>   ↓<br>Bean 开始使用<br>   ↓<br>销毁前处理（如 @PreDestroy / destroy-method）<br>   ↓<br>Bean 被销毁（容器关闭）</p></div></details><h2 id="springbean的但历史怎么实现的"><a href="#springbean的但历史怎么实现的" class="headerlink" title="springbean的但历史怎么实现的"></a>springbean的但历史怎么实现的</h2><p>Spring 容器通过 一个 Map 来缓存单例 Bean 实例，在创建 Bean 时先查缓存，如果已存在就直接返回，不再重新创建。这样有点像CAS一样，保证了bean的单例。</p><p>Spring 单例 Bean 的生命周期流程:<br>Spring 容器启动 → 解析配置 → 实例化 Bean → 放入单例池（Map） → 后续使用都从池中取。</p><h1 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h1><h2 id="mybatis的二级缓存"><a href="#mybatis的二级缓存" class="headerlink" title="mybatis的二级缓存"></a>mybatis的二级缓存</h2><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>MyBatis 提供了两级缓存：</p><div class="table-container"><table><thead><tr><th>缓存级别</th><th>缓存范围</th><th>生命周期</th></tr></thead><tbody><tr><td>一级缓存</td><td><code>SqlSession</code> 级别</td><td>当前会话内有效</td></tr><tr><td>二级缓存</td><td><code>Mapper</code> 级别</td><td>跨 <code>SqlSession</code> 有效（多个会话共享）</td></tr></tbody></table></div><p>流程:<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">用户请求 -&gt; Mapper 查询方法<br>   ↓<br>一级缓存 (SqlSession)<br>   ↓（查不到）<br>二级缓存 (基于 Mapper 命名空间)<br>   ↓（查不到）<br>数据库查询<br></code></pre></td></tr></table></figure></p><ul><li>开启 MyBatis 二级缓存<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></div></details><h1 id="rpc篇"><a href="#rpc篇" class="headerlink" title="rpc篇"></a>rpc篇</h1><h2 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h2><h3 id="什么是grpc"><a href="#什么是grpc" class="headerlink" title="什么是grpc"></a>什么是grpc</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>定义:<br>gRPC 是一种高性能、开源、跨语言的远程过程调用（RPC）框架，由 Google 开发，基于 HTTP/2 和 Protobuf 协议。</li></ul><div class="table-container"><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td>📦 基于 Protobuf 序列化</td><td>使用 Google 的 Protocol Buffers（比 JSON/XML 更小更快）</td></tr><tr><td>🛣️ 使用 HTTP/2 协议</td><td>支持多路复用、流控制、头压缩，性能远超 HTTP/1.1</td></tr><tr><td>🔁 支持 4 种调用方式</td><td>普通调用、服务器流、客户端流、双向流</td></tr><tr><td>🧬 跨语言支持</td><td>支持 Java、Go、Python、C++、Node.js 等十几种语言</td></tr><tr><td>🧱 接口强类型</td><td>用 <code>.proto</code> 文件定义服务和消息，代码自动生成，接口规范统一</td></tr><tr><td>🔐 支持认证和加密</td><td>支持 TLS/SSL，支持 token、OAuth2 等安全机制</td></tr><tr><td>🔔 支持流式通信</td><td>天然支持 Server Push、双向长连接、实时消息等场景</td></tr><tr><td>🚀 高性能、低延迟</td><td>Protobuf + HTTP/2 = 高吞吐 + 低延迟</td></tr><tr><td>📦 支持负载均衡、服务发现（可配合 etcd）</td><td>在大型微服务架构中易于扩展</td></tr></tbody></table></div></div></details><h3 id="如何使用grpc"><a href="#如何使用grpc" class="headerlink" title="如何使用grpc"></a>如何使用grpc</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>大致过程:<ul><li>通过 gRPC 代理，把方法和参数序列化为 Protobuf 二进制；</li><li>用 HTTP/2 发送给远程服务端；</li><li>服务端解析请求，执行对应方法；</li><li>返回结果（也是 Protobuf 格式）；</li><li>客户端反序列化，获得最终结果。</li></ul></li><li>🔧 示例：gRPC 使用流程（Java / Go 都类似）<ul><li>1️⃣ 定义 proto 文件（接口说明）<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">syntax = &quot;proto3&quot;;<br><br>service UserService &#123;<br>rpc GetUserById (UserRequest) returns (UserResponse);<br>&#125;<br><br>message UserRequest &#123;<br>int32 id = 1;<br>&#125;<br><br>message UserResponse &#123;<br>string name = 1;<br>int32 age = 2;<br>&#125;   <br></code></pre></td></tr></table></figure></li><li>2️⃣ 使用 protoc 工具生成代码（Stub）<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">protoc --java_out=. user.proto<br></code></pre></td></tr></table></figure></li><li>3️⃣ 实现服务端逻辑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserServiceGrpc</span>.UserServiceImplBase &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUserById</span><span class="hljs-params">(UserRequest request, StreamObserver&lt;UserResponse&gt; responseObserver)</span> &#123;<br>    <span class="hljs-type">UserResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> UserResponse.newBuilder()<br>            .setName(<span class="hljs-string">&quot;Tom&quot;</span>).setAge(<span class="hljs-number">22</span>).build();<br>    responseObserver.onNext(resp);<br>    responseObserver.onCompleted();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>4️⃣ 客户端调用服务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ManagedChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ManagedChannelBuilder.forAddress(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">50051</span>).usePlaintext().build();<br>UserServiceGrpc.<span class="hljs-type">UserServiceBlockingStub</span> <span class="hljs-variable">stub</span> <span class="hljs-operator">=</span> UserServiceGrpc.newBlockingStub(channel);<br><span class="hljs-type">UserResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> stub.getUserById(UserRequest.newBuilder().setId(<span class="hljs-number">1</span>).build());<br></code></pre></td></tr></table></figure></li></ul></li></ul></div></details><h1 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h1><h2 id="八股文-1"><a href="#八股文-1" class="headerlink" title="八股文"></a>八股文</h2><h3 id="什么是etcd"><a href="#什么是etcd" class="headerlink" title="什么是etcd"></a>什么是etcd</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>etcd 是一个开源的、强一致性、高可用的分布式键值数据库，广泛用于服务注册、配置中心、选主、分布式协调等场景。</p><div class="table-container"><table><thead><tr><th>等级</th><th>etcd 用于</th><th>Redis 用于</th></tr></thead><tbody><tr><td>📦 轻量配置 / 注册中心</td><td>❌ Redis 不推荐做配置中心</td><td></td></tr><tr><td>💽 高频缓存 / 业务数据</td><td>✅ Redis 优于 etcd</td><td></td></tr><tr><td>⚠️ 一致性要求高的协调场景</td><td>✅ etcd 更安全稳定</td></tr></tbody></table></div></div></details><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="八股文-2"><a href="#八股文-2" class="headerlink" title="八股文"></a>八股文</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>ChatGPT 说：<br>单例模式（Singleton Pattern）是一种创建型设计模式，它的主要目的是确保一个类只有一个实例，并且提供一个全局访问点来获得该实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 私有构造方法，防止外部实例化</span><br>    &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 第一重检查，避免不必要的同步开销</span><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;  <span class="hljs-comment">// 同步锁住代码块，保证线程安全</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 第二重检查，避免多个线程同时进入同步块时创建多个实例</span><br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>(); <span class="hljs-comment">// 创建实例</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></div></details><h1 id="其它篇"><a href="#其它篇" class="headerlink" title="其它篇"></a>其它篇</h1><h2 id="什么是幂等性，接口幂等性"><a href="#什么是幂等性，接口幂等性" class="headerlink" title="什么是幂等性，接口幂等性"></a>什么是幂等性，接口幂等性</h2><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>✅ 一句话理解幂等性：<br>一次和多次执行的效果是一样的，不论你执行多少次，结果都是一样的。</p><div class="table-container"><table><thead><tr><th>请求类型</th><th>示例 URL</th><th>幂等性说明</th></tr></thead><tbody><tr><td><code>GET</code></td><td><code>/user/1001</code></td><td>每次获取数据，不改变状态 → ✅ 幂等</td></tr><tr><td><code>DELETE</code></td><td><code>/user/1001</code></td><td>多次删除同一个用户，结果一样 → ✅ 幂等</td></tr><tr><td><code>PUT</code></td><td><code>/user/1001</code> 设置 age=20</td><td>多次设置同一个值，结果一样 → ✅ 幂等</td></tr><tr><td><code>POST</code></td><td><code>/order</code> 新建订单</td><td>每次都创建一个新订单 → ❌ 不幂等</td></tr></tbody></table></div><p>如果 接口不幂等，就会导致：</p><ul><li>重复扣款</li><li>重复创建订单</li><li>数据不一致<br>所以设计接口时，最好让它幂等，或者用幂等机制来保护。</li></ul></div></details><h2 id="JWT-如何使用续约toekn避免用户登录过期的"><a href="#JWT-如何使用续约toekn避免用户登录过期的" class="headerlink" title="JWT 如何使用续约toekn避免用户登录过期的"></a>JWT 如何使用续约toekn避免用户登录过期的</h2><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>🔁 JWT 续约机制:</p><div class="table-container"><table><thead><tr><th>类型</th><th>用途</th><th>有效期</th><th>存储方式</th></tr></thead><tbody><tr><td><code>accessToken</code></td><td>访问业务接口用，权限控制</td><td>短（如15分钟）</td><td><code>Authorization</code> 头 / localStorage</td></tr><tr><td><code>refreshToken</code></td><td>用来刷新 accessToken</td><td>长（如7天~30天）</td><td>HttpOnly Cookie（推荐）或 localStorage</td></tr></tbody></table></div><ol><li>🧠 为什么需要 refreshToken？</li></ol><ul><li>如果只用一个长期有效的 accessToken，一旦泄露无法阻止使用；</li><li>如果 accessToken 很短，又不能刷新，用户就要频繁登录，体验差；</li><li>因此，需要一个长期有效的 refreshToken，专门用于续签新的 accessToken。</li></ul><ol><li><p>流程图</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">登录：<br>Client ----&gt; Server<br>         &lt;---- 返回 accessToken + refreshToken<br><br>访问接口：<br>Client 携带 accessToken ----&gt; Server 验证通过<br><br>accessToken 过期：<br>Client 携带 refreshToken ----&gt; /auth/refresh<br>                          &lt;---- 返回新的 accessToken<br><br>refreshToken 也过期：<br>Client 重新登录<br></code></pre></td></tr></table></figure><div class="note info flat"><p>当返回token过期时，需要前端去捕捉，捕捉成功后让前端主动调刷新accessToken的接口，再调用一次失败的接口</p></div></li><li><p>JWT 流程示意</p></li></ol><div class="table-container"><table><thead><tr><th>部分</th><th>说明</th><th>内容示例</th></tr></thead><tbody><tr><td>Header</td><td>头部，描述令牌类型和签名算法</td><td><code>{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</code></td></tr><tr><td>Payload</td><td>载荷，存放声明（claims）</td><td><code>{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;Alice&quot;,&quot;iat&quot;:1516239022}</code></td></tr><tr><td>Signature</td><td>签名，对前两部分进行签名校验</td><td>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</td></tr></tbody></table></div><ul><li>将 Header 和 Payload 转为 JSON 后，进行 Base64Url 编码；</li><li>用密钥和算法对编码后的头部和载荷拼接字符串签名，生成 Signature；</li><li>拼接成 header.payload.signature 格式的 JWT 字符串。</li></ul></div></details><ul><li>面试官: ThreadLocal的内存泄漏的原因</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>ThreadLocalMap 存储结构<br>ThreadLocalMap 存储结构<br>每个线程内部（Thread 类）有一个 ThreadLocalMap，它以 弱引用（WeakReference） 来引用 ThreadLocal 对象（key），而 value 是强引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jAVA">Thread -&gt; ThreadLocalMap<br>             <span class="hljs-title function_">key</span> <span class="hljs-params">(弱引用)</span>: ThreadLocal对象<br>             value (强引用): 线程绑定的变量值<br><br><span class="hljs-comment">// 例如</span><br>ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>threadLocal.set(<span class="hljs-string">&quot;Hello, ThreadLocal!&quot;</span>);  <span class="hljs-comment">// 绑定变量值</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>key：就是 threadLocal 这个对象（弱引用）</li><li>value：就是 “Hello, ThreadLocal!” 这个字符串</li></ol><ul><li><p>内存泄漏的关键点：</p><ul><li>当 ThreadLocal 对象被垃圾回收（key 为弱引用，没被外部引用了），</li><li>但是 ThreadLocalMap 中对应的 value 是强引用，不会被自动回收，</li><li>导致这个 value 对象一直存在，造成内存泄漏。</li></ul></li><li><p>必须在使用完 ThreadLocal 后调用 remove()</p></li></ul></div></details></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring-篇&quot;&gt;&lt;a href=&quot;#spring-篇&quot; class=&quot;headerlink&quot; title=&quot;spring 篇&quot;&gt;&lt;/a&gt;spring 篇&lt;/h1&gt;&lt;h2 id=&quot;spring-IOC-（控制反转）&quot;&gt;&lt;a href=&quot;#spring-IOC-（</summary>
      
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>计网面试题</title>
    <link href="http://example.com/2025/07/17/interview/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2025/07/17/interview/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2025-07-17T00:00:00.000Z</published>
    <updated>2025-07-17T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面试官:当你在浏览器上输入一个url，回车之后发生了什么</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>你在浏览器输入 URL 并回车：<br> ↓</p><ol><li>解析 URL（协议、主机、路径等）<br>↓</li><li>浏览器查找缓存（DNS、本地缓存、HTTP 缓存等）<br>↓</li><li>DNS 域名解析（将域名转换为 IP）<br>↓</li><li>建立 TCP 连接（三次握手）<br>↓</li><li>发起 HTTP 请求<br>↓</li><li>服务器处理请求，返回响应（HTML 等）<br>↓</li><li>浏览器解析渲染页面（HTML -&gt; DOM、CSS、JS 执行）<br>↓</li><li>页面展示出来</li></ol></div></details></li><li><p>面试官:TCP和UDP的区别</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>TCP 像打电话📞：你要接通对方，确保每句话听清楚。</li><li>UDP 像寄明信片📮：你写完直接发，收不收到不管，发的快。</li></ul><p>核心区别详解</p><ul><li><p>1️⃣ 连接机制</p><ul><li>TCP 是面向连接的，通信前要建立连接（三次握手）。</li><li>UDP 是无连接的，直接发送，不需要握手。</li></ul></li><li><p>2️⃣ 是否可靠</p></li><li>TCP 保证可靠传输<ul><li>包含顺序控制</li><li>有确认应答 ACK</li><li>丢包重传（超时重传、滑动窗口）</li><li>有拥塞控制</li></ul></li><li>UDP 是尽力而为，不可靠<ul><li>不确认、不重传、不排序，收不到就丢了</li><li>程序自己实现可靠性（如 QUIC 或 RTP）</li></ul></li></ul><p>3️⃣ 传输效率</p><ul><li>UDP 更轻便、快<ul><li>无连接开销、无状态</li><li>适合实时性强的通信（如直播、语音、游戏）</li></ul></li><li>TCP 更可靠<ul><li>适合要求数据不能出错的场景</li></ul></li></ul></div></details></li><li><p>面试官:TCP的三次握手，必须三次吗，两次行不行</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><div class="table-container"><table><thead><tr><th>步骤</th><th>谁发出</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>第一次</td><td>客户端</td><td><code>SYN=1</code></td><td>客户端请求建立连接</td></tr><tr><td>第二次</td><td>服务端</td><td><code>SYN=1, ACK=1</code></td><td>服务端收到请求并同意连接</td></tr><tr><td>第三次</td><td>客户端</td><td><code>ACK=1</code></td><td>客户端确认服务端响应，连接建立完成</td></tr></tbody></table></div><p>🌟 场景类比：你和朋友打电话<br>你 = 客户端（Client）<br>朋友 = 服务端（Server）</p><p>✅ 如果用三次握手：<br>你打电话过去，说：“喂，我想和你聊聊！”（SYN）<br>→ 表示你能说。</p><p>朋友接到电话，回应说：“好的，我也能听见你，也能说话！”（SYN + ACK）<br>→ 表示他能听、能说。</p><p>你回应：“我听到你了，咱开始聊吧！”（ACK）<br>→ 表示你能听到他，双向都通了，通信正式开始。</p><p>❌ 如果只用两次握手：<br>你说：“我想聊聊”（SYN）<br>朋友说：“好的，我能听到你，也能说话”（SYN + ACK）<br>🚨 但是你没回应！<br>这时候你可能没听到，或者你已经不想聊了（网络问题、掉线、退出）。<br>但朋友误以为你要开始聊天，于是一直在等你说话……</p></div></details></li><li><p>面试官:TCP的四次挥手</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>TCP 是 全双工（双方都能同时收发数据），所以断开连接时，两边都需要分别关闭 自己的发送通道。<br>因此需要两次 FIN + 两次 ACK，总共四次。</p><p>客户端（Client）             服务端（Server）<br>     |—- FIN ——————-&gt;|   （1）我数据发完了<br>     |&lt;— ACK ———————|   （2）收到，但我还有数据<br>     |&lt;— FIN ———————|   （3）我也发完了<br>     |—- ACK ——————-&gt;|   （4）收到，连接关闭</p></div></details></li><li><p>面试官:TCP的四层模型是什么</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><div class="table-container"><table><thead><tr><th>层级</th><th>名称</th><th>功能简介</th><th>对应协议举例</th><th>对应 OSI 七层</th></tr></thead><tbody><tr><td>1</td><td>网络接口层（或链路层）</td><td>负责数据在物理网络中的传输，例如以太网、Wi-Fi、光纤等</td><td>Ethernet、Wi-Fi、ARP、PPP</td><td>OSI 的第1层（物理层）和第2层（数据链路层）</td></tr><tr><td>2</td><td>网络层（或网际层）</td><td>实现网络之间的通信和寻址，提供数据包的路由功能</td><td>IP、ICMP、ARP、RARP</td><td>OSI 的第3层（网络层）</td></tr><tr><td>3</td><td>传输层</td><td>提供端到端的通信服务（可靠或不可靠），负责数据的传输控制、重传、流控等</td><td>TCP、UDP</td><td>OSI 的第4层（传输层）</td></tr><tr><td>4</td><td>应用层</td><td>提供应用程序之间的通信接口，如网页访问、邮件发送等</td><td>HTTP、FTP、SMTP、DNS、SSH、Telnet 等</td><td>OSI 的第5层~第7层（会话层、表示层、应用层）</td></tr></tbody></table></div></div></details></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;面试官:当你在浏览器上输入一个url，回车之后发生了什么&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我:&lt;/p&gt;
&lt;details class=&quot;toggle&quot; style=&quot;border: 1px solid  white&quot;&gt;&lt;summary class=&quot;toggle-but</summary>
      
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>小怪兽的刷题日记</title>
    <link href="http://example.com/2025/07/15/interview/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    <id>http://example.com/2025/07/15/interview/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</id>
    <published>2025-07-15T00:00:00.000Z</published>
    <updated>2025-07-15T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<style>.reveal-on-hover {  background-color: #ccc;  color: transparent;  border-radius: 4px;  padding: 4px 8px;  transition: color 0.3s ease;  cursor: pointer;}.reveal-on-hover:hover {  color: #000;}</style><div class="note info flat"><p>2025-07-27 11:39</p><p><span class="reveal-on-hover">刷题刷的觉得自己是个傻子</span></p></div><h1 id="LC-91-解码方法"><a href="#LC-91-解码方法" class="headerlink" title="LC 91 解码方法"></a>LC 91 解码方法</h1><p><a href="https://leetcode.cn/problems/decode-ways/description/">解码方法</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这道题我一开始一直没能理解  这两行代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (one &gt;= <span class="hljs-number">1</span> &amp;&amp; one &lt;= <span class="hljs-number">9</span>) dp[i] += dp[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (two &gt;= <span class="hljs-number">10</span> &amp;&amp; two &lt;= <span class="hljs-number">26</span>) dp[i] += dp[i-<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><br>我一直在思考为什么 dp[i] += dp[i-1]，dp[i] += dp[i-2]。想了一个半小时后我终于茅塞顿开！</p><ol><li>分析第 i 个字符可能的解码方式</li></ol><ul><li>第 i 个字符 s[i-1] 可以单独解码吗？<ul><li>如果 s[i-1] 是 ‘1’~’9’，那么它可以单独解码为一个字母；</li><li>这种情况下，所有前 i-1 个字符的解码方式（dp[i-1]）都可以延续下来，接上这个单独的字符。<br>所以 dp[i] += dp[i-1]，因为dp[i-1]的解码方法都被延续下来了</li></ul></li><li>第 i 个字符与第 i-1 个字符合起来是否能解码？<ul><li>第 i-1 和 i 两个字符组成的字符串 s[i-2..i-1] 是不是合法的两位数？合法区间是 10~26。</li><li>如果是，那么这两个字符可以合起来表示一个字母；</li><li>此时，所有前 i-2 个字符的解码方式（dp[i-2]）都可以延续下来，接上这两个字符合起来的字母。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecodeWays</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDecodings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(i-<span class="hljs-number">2</span>, i));<br><br>            <span class="hljs-keyword">if</span> (one &gt;= <span class="hljs-number">1</span> &amp;&amp; one &lt;= <span class="hljs-number">9</span>) dp[i] += dp[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (two &gt;= <span class="hljs-number">10</span> &amp;&amp; two &lt;= <span class="hljs-number">26</span>) dp[i] += dp[i-<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(numDecodings(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// 输出 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>总结：动态规划的核心是 明确dp[i]状态是什么，找到状态转化方程，常用于以下类型:</li></ul></li><li>求最值（最大、最小、最多、最少）</li><li>求方案数（有多少种方法、路径、可能）</li><li>子结构可重复利用</li><li>状态由一个或多个维度组成（位置、容量、次数等）</li></ul><h1 id="LC-2560-打家劫舍"><a href="#LC-2560-打家劫舍" class="headerlink" title="LC 2560 打家劫舍"></a>LC 2560 打家劫舍</h1><p><a href="https://leetcode.cn/problems/house-robber-iv/description/">打家劫舍</a><br>看到这题我的思路是这样的:</p><ul><li>把原数组复制并排序；</li><li>从第 k 小的值开始尝试，试一试能不能选出 k 个不相邻的数字，最大值不超过它；</li><li>如果不行，就继续试下一个更大的数（k+1 小、k+2 小…）；</li><li>每次都从头找一遍，排除相邻的数字。<br>以下是我写的代码,不出意外的没有完全通过，A了0.66<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//        int left = Arrays.stream(nums).min().getAsInt();</span><br>        <span class="hljs-type">int</span>[] nums1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ArrayList&lt;Integer&gt; index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, nums1, <span class="hljs-number">0</span>, nums.length);<br>        Arrays.sort(nums1);<br>        <span class="hljs-comment">//设置最优解</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">money1</span> <span class="hljs-operator">=</span> nums1[k - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> k-<span class="hljs-number">1</span>;<br>        list.add(money1);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; i++) &#123;<br>            map.put(nums[i], i);<br>        &#125;<br>        index.add(map.get(money1));<br><br><br>        <span class="hljs-comment">//最优解第K小的值正好，寻找K-1个比第K小值小的数，如果找不到则退而求起次值</span><br>        <span class="hljs-comment">// 且找到数的小标不能连续，需要用递归</span><br>        <span class="hljs-keyword">while</span> (list.size() &lt; k) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &lt; money1 &amp;&amp; add(index,i)) &#123;<br>                    list.add(nums[i]);<br>                    index.add(map.get(nums[i]));<br>                &#125;<br><span class="hljs-comment">//                if (nums[i]==money1)&#123;</span><br><span class="hljs-comment">//                    continue;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//                if (list.size() &lt; k &amp;&amp; nums[i] &gt; money1) &#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                    money1 = nums1[x+1];</span><br><span class="hljs-comment">//                    x++;</span><br><span class="hljs-comment">//                    list.clear();</span><br><span class="hljs-comment">//                    index.clear();</span><br><span class="hljs-comment">//                    list.add(money1);</span><br><span class="hljs-comment">//                    index.add(map.get(money1));</span><br><span class="hljs-comment">//                    break;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                &#125;</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (list.size() &lt; k) &#123;<br>                money1 = nums1[x+<span class="hljs-number">1</span>];<br>                x++;<br>                list.clear();<br>                index.clear();<br>                list.add(money1);<br>                index.add(map.get(money1));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> money1;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(ArrayList index, <span class="hljs-type">int</span> x)</span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;index.size(); i++)&#123;<br>            <span class="hljs-keyword">if</span> (Math.abs((Integer) index.get(i) -x)==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>官方的答案是用二分+贪心,看到代码的时候我很疑惑，为什么直接使用i+=2，我在想不会出现一种不规则的选取（如i=1,4,7,9,13等）导致贪心函数没找出来，然后进而影响二分算法，实则不然，经过我仔细研究代码后发现，这段代码很巧妙，只要找出了K个最小值即可，就说明maxVal的范围偏大，而不是枚举出所有的组合方式。为什么我想不出来这样的解法呢！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCapability</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Arrays.stream(nums).min().getAsInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().getAsInt();<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (canPick(nums, k, mid)) &#123;<br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否能选出 k 个不相邻的元素，且每个 ≤ maxVal</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> maxVal)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt;= maxVal) &#123;<br>                count++;<br>                i += <span class="hljs-number">2</span>; <span class="hljs-comment">// 跳过一个，保证不相邻</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count &gt;= k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC-最热-42"><a href="#LC-最热-42" class="headerlink" title="LC 最热 42"></a>LC 最热 42</h1><a href="https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&amp;envId=top-100-liked">接雨水</a></li></ul><p>分析题目花了十分钟，本想着用几何法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">ans += 容器总高度 * 宽度<br>      - 中间所有柱子的高度<br></code></pre></td></tr></table></figure><br>所以我的思路是双指针，一个left和right,固定一个位置 i，获取到i左边的最大值和i右边的最大值，这样就可以获取到right-left区间的雨水了<br>但是这个边界问题很容易出错，所以果不其然没有通过。<br>而正确的思路应该是:<br>water[i] = min(leftMax[i], rightMax[i]) - height[i]<br>同样使用双指针,记录左右两边最大值，这样就很简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 少于三个柱子肯定不能接水</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-comment">// 找左边最高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> height[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) &#123;<br>            leftMax = Math.max(leftMax, height[l]);<br>        &#125;<br><br>        <span class="hljs-comment">// 找右边最高</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> height[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; r &lt; n; r++) &#123;<br>            rightMax = Math.max(rightMax, height[r]);<br>        &#125;<br><br>        <span class="hljs-comment">// 当前位置可接水量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">water</span> <span class="hljs-operator">=</span> Math.min(leftMax, rightMax) - height[i];<br>        <span class="hljs-keyword">if</span> (water &gt; <span class="hljs-number">0</span>) &#123;<br>            ans += water;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC-438"><a href="#LC-438" class="headerlink" title="LC 438"></a>LC 438</h1><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">找到字符串中所有字母异位词</a></p><p>看到这题，我刚心里暗喜，这么简单，这不直接秒了吗？我直接就是将P转化成ASCII值，然后循环S，每次取3个字符，比对一下就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length()-p.length()+<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> s.substring(i, i + p.length());<br>            <span class="hljs-keyword">if</span> (isAnagram(substring,p))&#123;<br>                list.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String substring, String p)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = substring.toCharArray();<br>        <span class="hljs-type">char</span>[] chars1 = p.toCharArray();<br>        Arrays.sort(chars);<br>        Arrays.sort(chars1);<br>        <span class="hljs-keyword">return</span> Arrays.equals(chars, chars1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>然后当我看到结果，不是你这案例找茬是吧<br><img src="https://pic1.imgdb.cn/item/6878c2bc58cb8da5c8beb72a.png" alt=""></p><p>然后我就去看答案，发明答案的人真是个天才，使用的方法依然是滑动窗口，不过他用两个数组记录了p和s的字符数，每次只需要替换一个字符，确实比我自己写的高效<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (s.length() &lt; p.length()) <span class="hljs-keyword">return</span> list;<br><br>        <span class="hljs-type">int</span>[] pCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 记录 p 中每个字符出现的次数</span><br>        <span class="hljs-type">int</span>[] sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 当前窗口中字符的统计</span><br><br>        <span class="hljs-comment">// 初始化 pCount 和第一个窗口的 sCount</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>            pCount[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Arrays.equals(pCount, sCount)) list.add(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 开始滑动窗口</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 右移窗口：添加新字符</span><br>            sCount[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-comment">// 移除最左侧的字符</span><br>            sCount[s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br><br>            <span class="hljs-keyword">if</span> (Arrays.equals(pCount, sCount)) list.add(i - p.length() + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="LC-560"><a href="#LC-560" class="headerlink" title="LC 560"></a>LC 560</h1><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">和为 K 的子数组</a></p><p>那这题第一眼先来暴力循环试试,最后也是循环出来了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sun</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (left=<span class="hljs-number">0</span>; left &lt; nums.length; left++)&#123;<br>             sun = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (right=left; right &lt; nums.length; right++)&#123;<br>                sun += nums[right];<br>                <span class="hljs-keyword">if</span> (sun == k)&#123;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>不过还有时间复杂度更小的方法：前缀和+哈希<ul><li>优化思路的核心：前缀和<br>✅ 定义「前缀和」：</li><li>设 prefixSum[i] 表示数组前 i 个元素的和（不含第 i 个）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">prefixSum[i] = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + ... + nums[i - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li><li>那么：从 i 到 j 的子数组之和 sum(i~j) 为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">sum(i~j) = prefixSum[j + <span class="hljs-number">1</span>] - prefixSum[i]<br></code></pre></td></tr></table></figure>也就是说：两个前缀和的差值，就是一个子数组的和。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        preSum.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 前缀和为0的次数为1</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            sum += num;<br>            <span class="hljs-keyword">if</span> (preSum.containsKey(sum - k)) &#123;<br>                count += preSum.get(sum - k);<br>            &#125;<br>            preSum.put(sum, preSum.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC-239"><a href="#LC-239" class="headerlink" title="LC 239"></a>LC 239</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked">滑动窗口最大值</a><br>这题不是很简单吗，怎么会是困难题，直接两个指针滑动，找最大值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length-k+<span class="hljs-number">1</span>; i++) &#123;<br>      <span class="hljs-type">int</span>  x= findMax(nums, i, i+k-<span class="hljs-number">1</span>);<br>      res[i] = x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[left];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>        max = Math.max(max, nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><br>好好好是我大意了<br><img src="https://pic1.imgdb.cn/item/6879f79b58cb8da5c8c28842.png" alt=""></p><ul><li>正确解法是 双端队列</li></ul><ol><li>维护双端队列：</li></ol><ul><li>用Deque存放元素的索引。在任何时刻，Deque的头部总是滑动窗口中的最大值的索引。那么当窗口滑动时，我们只取Deque的头部即可获取最大值。</li></ul><ol><li>滑动窗口滑动：</li></ol><ul><li>移除窗口最左侧的元素：如果Deque头部元素的索引已经超出当前窗口的范围（即j - k + 1之前的元素），那么从头部移除该元素。</li><li>维护单调递减性：将当前元素和Deque尾部元素比较，如果当前元素比尾部元素大，那么尾部元素不可能是当前滑动窗口的最大值，那我们移除尾部元素。重复此操作，直至Deque中的所有元素都大于当前元素，即可保持单调递减。</li><li>添加当前元素：将当前元素的索引加入Deque。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 存储下标</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 1. 移除不在窗口内的下标</span><br>            <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="hljs-number">1</span>) &#123;<br>                deque.pollFirst();<br>            &#125;<br><br>            <span class="hljs-comment">// 2. 保持队列递减（从队尾移除比当前值小的）</span><br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>                deque.pollLast();<br>            &#125;<br><br>            <span class="hljs-comment">// 3. 加入当前元素索引</span><br>            deque.offerLast(i);<br><br>            <span class="hljs-comment">// 4. 形成窗口后写入结果</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>                res[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 🔍 举个例子来对比<br>假设：nums = [1, 3, 2, 5, 4], k = 3<br>🚫 暴力法：</p><ul><li>窗口 [1, 3, 2] → max = 3</li><li>窗口 [3, 2, 5] → max = 5</li><li>窗口 [2, 5, 4] → max = 5<br>→ 每次都重新扫描窗口中的 3 个元素，重复判断</li></ul><p>✅ Deque 单调队列法：<br>我们维护一个队列，始终让队列的头是当前窗口的最大值。</p><ul><li>插入 1 → [0]</li><li>插入 3 → 弹出 1 → [1]</li><li>插入 2 → 保留 → [1,2] → 当前窗口最大值：nums[1]=3</li><li>插入 5 → 弹出 2，弹出 3 → [3]</li><li>插入 4 → 保留 → [3,4] → 当前窗口最大值：nums[3]=5<br>你会发现：我们没有“重复”找最大值，而是动态维护了它！</li></ul><h1 id="LC-76"><a href="#LC-76" class="headerlink" title="LC 76"></a>LC 76</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">最小覆盖子串</a><br>刚看上去，这题我的思路是只要是覆盖字串，开头第一个字符必然在字符传t中，所以我先用Set将字串t存起来，然后而且只要找到一个覆盖字串的话，就直接跳到下一个是字符t中的任意一个字符开始循环找下一个覆盖字串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>             <span class="hljs-keyword">if</span> (s.length() &lt; t.length()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>     <span class="hljs-type">int</span>[] tCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>         tCount[c - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>     &#125;<br>     <span class="hljs-type">int</span>[] sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>     Set&lt;Character&gt; missing = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>         missing.add(c);<br>     &#125;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">minLen</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>         <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>         <span class="hljs-keyword">if</span> (missing.contains(c))&#123;<br>             sCount[c - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>             <span class="hljs-keyword">if</span>(Arrays.equals(tCount, sCount))&#123;<br>                 <span class="hljs-keyword">return</span> t;<br>             &#125;<br>             left = i;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>left+<span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>         <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>         <span class="hljs-keyword">if</span> (missing.contains(c))&#123;<br>             <span class="hljs-keyword">if</span> (sCount[c-<span class="hljs-string">&#x27;A&#x27;</span>]&lt;tCount[c-<span class="hljs-string">&#x27;A&#x27;</span>])&#123;<br>                 sCount[c - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>             &#125;<br>             <span class="hljs-keyword">if</span> (next==<span class="hljs-number">0</span>)&#123;<br>                 next = i;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span>(Arrays.equals(tCount, sCount))&#123;<br>             <span class="hljs-keyword">if</span> (minLen &gt; i - left+ <span class="hljs-number">1</span>)&#123;<br>                 res = s.substring(left, i + <span class="hljs-number">1</span>);<br>             &#125;<br>             minLen = Math.min(minLen, i - left + <span class="hljs-number">1</span>);<br>             i=next;<br>             left = next;<br>             sCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">256</span>];<br>             sCount[s.charAt(next) - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>             next=<span class="hljs-number">0</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>很遗憾，269个案例通过了265个，遇见超时了，气死我了！</p><h1 id="LC-54"><a href="#LC-54" class="headerlink" title="LC 54"></a>LC 54</h1><p><a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">螺旋矩阵</a></p><ul><li>这题第一眼看上去很懵，自然观察思考后，可以设置四个变量，分别表示最上面的行，最下面的行，最右边的列，最左边的列，有这四个边界去循环就可以了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>   List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right)&#123;<br>      <span class="hljs-comment">//最上面行</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right; i++) &#123;<br>          list.add(matrix[top][i]);<br>      &#125;<br>      top++;<br>      <span class="hljs-comment">//最右边列</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>          list.add(matrix[i][right]);<br>      &#125;<br>      right--;<br>      <span class="hljs-comment">//最下面行</span><br>      <span class="hljs-keyword">if</span> (top &lt;= bottom)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left; i--) &#123;<br>              list.add(matrix[bottom][i]);<br>          &#125;<br>          bottom--;<br>      &#125;<br>      <span class="hljs-comment">//最左边列</span><br>      <span class="hljs-keyword">if</span> (left &lt;= right)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>              list.add(matrix[i][left]);<br>          &#125;<br>          left++;<br>      &#125;<br>  &#125;<br>   <span class="hljs-keyword">return</span>  list;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="LC-160-相交链表"><a href="#LC-160-相交链表" class="headerlink" title="LC 160 相交链表"></a>LC 160 相交链表</h1><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">相交链表</a></li><li>双指针<br>两个指针分别走完 A + B 和 B + A，它们要么在交点相遇，要么都走到 null。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">A: a1 → a2 → c1 → c2 → c3<br>B:     b1 → b2 → b3 → c1 → c2 → c3<br></code></pre></td></tr></table></figure></li><li>相交节点是 c1<ul><li>p1 走的是路径：a1→a2→c1→c2→c3→null→b1→b2→b3→c1</li><li>p2 走的是路径：b1→b2→b3→c1→c2→c3→null→a1→a2→c1<br>所以最终两个指针都会在 c1 相遇。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> headB;<br><br>        <span class="hljs-comment">// 两个指针交替走完对方的链表，最终在交点相遇或都为 null</span><br>        <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>            p1 = (p1 == <span class="hljs-literal">null</span>) ? headB : p1.next;<br>            p2 = (p2 == <span class="hljs-literal">null</span>) ? headA : p2.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p1; <span class="hljs-comment">// 如果有交点，就是交点；否则为 null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC-206-反转链表"><a href="#LC-206-反转链表" class="headerlink" title="LC 206 反转链表"></a>LC 206 反转链表</h1><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">反转链表</a></li></ul></li><li>可以用三个指针实现反转链表<ul><li>prev：上一个节点（初始化为 null）</li><li>curr：当前节点（从 head 开始）</li><li>next：暂存 curr 的下一个节点（防止断链）<br>例如 初始链表:<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">head -&gt; 1 -&gt; 2 -&gt; 3 -&gt; null<br></code></pre></td></tr></table></figure>第一次交换后<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">prev: 1 -&gt; null<br>curr: 2 -&gt; 3 -&gt; null<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br><br>    ListNode(<span class="hljs-type">int</span> val) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;     <span class="hljs-comment">// 上一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;     <span class="hljs-comment">// 当前节点</span><br><br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next; <span class="hljs-comment">// 暂存下一个节点</span><br>            curr.next = prev;          <span class="hljs-comment">// 反转指针</span><br>            prev = curr;               <span class="hljs-comment">// prev 前进一步</span><br>            curr = next;               <span class="hljs-comment">// curr 前进一步</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// prev 最终指向新的头结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="LC-25-K-个一组翻转链表"><a href="#LC-25-K-个一组翻转链表" class="headerlink" title="LC 25. K 个一组翻转链表"></a>LC 25. K 个一组翻转链表</h1><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">K 个一组翻转链表</a></p><ul><li>递归+反转链表<br>刚看这个题的时候我想，我会反转链表，怎么给他转换一下，但是我没想到用递归，这个递归就完美解决了问题<br>每次都只反转K个，将剩下的交给下一次递归！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 1. 检查当前是否有 k 个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 不足 k 个，不反转</span><br>            cur = cur.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 翻转前 k 个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverse(head, cur); <span class="hljs-comment">// 左闭右开 [head, cur)</span><br><br>        <span class="hljs-comment">// 3. 递归处理后续节点，并接上</span><br>        head.next = reverseKGroup(cur, k);<br><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br><br>    <span class="hljs-comment">// 反转区间 [start, end) 的节点，end 不翻转（右开）</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode start, ListNode end)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> start;<br><br>        <span class="hljs-keyword">while</span> (curr != end) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;<br>            curr.next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> prev; <span class="hljs-comment">// 反转后的头结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC-148-排序链表"><a href="#LC-148-排序链表" class="headerlink" title="LC 148. 排序链表"></a>LC 148. 排序链表</h1><a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">排序链表</a></li></ul><p>我第一思路是直接遍历一遍链表，用数组存起来，数组排序。然后替换值。这属于是投机取巧了。再来看看正确的解法吧</p><ul><li>递归 代码逐步解析<ul><li>找到中位数，一个快指针走两步，一个慢指针走一步，当快指针走到头时，慢指针肯定走到中间了<ul><li>为什么要找中位数？ 目的是找到中位数，可以分割成左右两个链表，分别排序，然后合并一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">ListNode slow=head;ListNode fast=head.next;<br>  <span class="hljs-comment">//找到中位数</span><br>  <span class="hljs-keyword">while</span> (fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>      slow=slow.next;<br>      fast=fast.next.next;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>递归调用，将第一次分割的两个左右链表，都当作一个链表继续去分割成小的左右链表，知道不能分割为止<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> slow.next;<br> slow.next = <span class="hljs-literal">null</span>;             <span class="hljs-comment">// 必须先断链！</span><br> <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br> <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(mid); <span class="hljs-comment">// 再递归右半部分</span><br></code></pre></td></tr></table></figure></li><li>此时整体上是已经递归到最底层了 也就是被分割成了很多小链表了，合并两两小链表，返回合并后的大链表，知道递归到最上层<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">ListNode res= merge(left,right);<br></code></pre></td></tr></table></figure></li><li>示例流程<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">sortList([-1,5,3,4,0])<br>├─ left: [-1,5,3]<br>│   ├─ left: [-1]<br>│   └─ right: [5,3]<br>│        ├─ left: [5]<br>│        └─ right: [3]<br>│        └─ merge → [3,5]<br>│   └─ merge([-1], [3,5]) → [-1,3,5]<br>└─ right: [4,0]<br> ├─ left: [4]<br> └─ right: [0]<br> └─ merge → [0,4]<br>└─ merge([-1,3,5], [0,4]) → [-1,0,3,4,5]<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>    ListNode slow=head;ListNode fast=head.next;<br>    <span class="hljs-comment">//找到中位数</span><br>    <span class="hljs-keyword">while</span> (fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        slow=slow.next;<br>        fast=fast.next.next;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> slow.next;<br>    slow.next = <span class="hljs-literal">null</span>;             <span class="hljs-comment">// 必须先断链！</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(mid); <span class="hljs-comment">// 再递归右半部分</span><br>    ListNode res= merge(left,right);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode left,ListNode right)</span>&#123;<br>    ListNode dummy=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-keyword">while</span>(left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (left.val &lt; right.val)&#123;<br>            temp.next = left;<br>            left = left.next;<br>            temp=temp.next;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            temp.next = right;<br>            right = right.next;<br>            temp=temp.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (left !=<span class="hljs-literal">null</span>)&#123;<br>        temp.next = left;<br>        left = left.next;<br>        temp=temp.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (right !=<span class="hljs-literal">null</span>)&#123;<br>        temp.next = right;<br>        right = right.next;<br>        temp=temp.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LC-46-全排列"><a href="#LC-46-全排列" class="headerlink" title="LC 46. 全排列"></a>LC 46. 全排列</h1><p><a href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-100-liked">全排列</a></p><ul><li>递归＋回溯<ul><li>nums = [1, 2, 3] 的回溯全排列展开过程<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs text">第一层：<br>i = 0 → 选择 1 → path = [1]<br>    第二层：<br>    i = 0 → 已在 path 中，跳过<br>    i = 1 → 选择 2 → path = [1, 2]<br>        第三层：<br>        i = 0 → 已在 path 中，跳过<br>        i = 1 → 已在 path 中，跳过<br>        i = 2 → 选择 3 → path = [1, 2, 3]<br>            ✅ 满足条件，加入结果：result.add([1, 2, 3])<br>        🔙 回溯：移除 3 → path = [1, 2]<br>    🔙 回溯：移除 2 → path = [1]<br><br>    i = 2 → 选择 3 → path = [1, 3]<br>        第三层：<br>        i = 0 → 已在 path 中，跳过<br>        i = 1 → 选择 2 → path = [1, 3, 2]<br>            ✅ 满足条件，加入结果：result.add([1, 3, 2])<br>        🔙 回溯：移除 2 → path = [1, 3]<br>    🔙 回溯：移除 3 → path = [1]<br>🔙 回溯：移除 1 → path = []<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br> List&lt;List&lt;Integer&gt;&gt; result =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br> balance(path, result,nums);<br> <span class="hljs-keyword">return</span> result;<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">balance</span><span class="hljs-params">(ArrayList&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; list, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-keyword">if</span> (path.size() == nums.length)&#123;<br>         <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; path.size(); i++) &#123;<br>             arrayList.add(path.get(i));<br>         &#125;<br>         list.add(arrayList);<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;nums.length;i++)&#123;<br>         <span class="hljs-keyword">if</span>(!path.contains(nums[i])) &#123;<br>             path.add(nums[i]);<br>             balance(path, list, nums);<br>             path.remove(path.size() - <span class="hljs-number">1</span>);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="LC-39-组合总和"><a href="#LC-39-组合总和" class="headerlink" title="LC 39. 组合总和"></a>LC 39. 组合总和</h2><a href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">组合总和</a></li></ul></li><li>回溯<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 主函数：寻找所有可以组成 target 的组合</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> candidates 可选的数字数组（正整数）</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> target     目标和</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 所有组合的列表，每个组合是一个整数列表</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>       List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存放所有合法组合结果</span><br>       backtrack(res, candidates, <span class="hljs-number">0</span>, target, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()); <span class="hljs-comment">// 开始回溯搜索</span><br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 回溯函数：在 candidates 中从 index 开始选择数字，寻找所有和为 target 的组合</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> res        结果集，收集所有满足条件的组合</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> candidates 候选数字数组</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> index      当前搜索的起始位置（为了避免重复组合，始终从当前及后面开始）</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> target     当前剩余的目标和</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> path       当前路径（正在构建的组合）</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> target, List&lt;Integer&gt; path)</span> &#123;<br>       <span class="hljs-comment">// ✅ 剪枝条件：剩余值 &lt; 0，说明当前组合超了，直接返回</span><br>       <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>       <span class="hljs-comment">// 🎯 找到一个合法组合（路径之和刚好等于 target）</span><br>       <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path)); <span class="hljs-comment">// 注意要复制 path，否则后续回溯会修改</span><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       <span class="hljs-comment">// 从当前 index 开始尝试加入 candidates[i] 到组合中</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; candidates.length; i++) &#123;<br>           <span class="hljs-comment">// 选择 candidates[i]</span><br>           path.add(candidates[i]);<br><br>           <span class="hljs-comment">// 递归调用：因为一个数字可以无限使用，所以递归时传 i 而不是 i + 1</span><br>           backtrack(res, candidates, i, target - candidates[i], path);<br><br>           <span class="hljs-comment">// 回溯：撤销选择，尝试下一个数字</span><br>           path.remove(path.size() - <span class="hljs-number">1</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="LC-22-括号生成"><a href="#LC-22-括号生成" class="headerlink" title="LC 22. 括号生成"></a>LC 22. 括号生成</h1><p><a href="https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">括号生成</a></p><p>✅ 思路讲解<br>合法括号组合满足：</p><ul><li>任意前缀中左括号 ( 数量 ≥ 右括号 ) 数量。</li><li>最终左右括号数量必须相等，且都为 n。<br>用回溯法，每次选择添加 ( 或 )：</li><li>只有当左括号 &lt; n 时，才能添加 (；</li><li>只有当右括号 &lt; 左括号数量 时，才能添加 )。</li></ul><p>以 n = 2 为例，整个过程会尝试这些步骤（大致流程）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">start: &quot;&quot;<br>加左括号 -&gt; &quot;(&quot;<br>再加左括号 -&gt; &quot;((&quot;<br>不能再加左了，加右 -&gt; &quot;(()&quot;<br>再加右 -&gt; &quot;(())&quot; ✅<br><br>回溯一次，变成 &quot;(()&quot;，尝试别的路径<br>再回溯，变成 &quot;(&quot;, 尝试加右 -&gt; &quot;()&quot;<br>再加左 -&gt; &quot;()(&quot;，再加右 -&gt; &quot;()()&quot; ✅<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateParentheses</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        backtrack(res, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 回溯函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder current, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close, <span class="hljs-type">int</span> max)</span> &#123;<br>        <span class="hljs-comment">// 终止条件：左右括号都用完</span><br>        <span class="hljs-keyword">if</span> (current.length() == max * <span class="hljs-number">2</span>) &#123;<br>            res.add(current.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 可以添加左括号</span><br>        <span class="hljs-keyword">if</span> (open &lt; max) &#123;<br>            current.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtrack(res, current, open + <span class="hljs-number">1</span>, close, max);<br>            current.deleteCharAt(current.length() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 回溯</span><br>        &#125;<br><br>        <span class="hljs-comment">// 可以添加右括号（必须保证右括号 &lt; 左括号）</span><br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            current.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtrack(res, current, open, close + <span class="hljs-number">1</span>, max);<br>            current.deleteCharAt(current.length() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 示例测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GenerateParentheses</span> <span class="hljs-variable">gp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenerateParentheses</span>();<br>        List&lt;String&gt; result = gp.generateParenthesis(<span class="hljs-number">3</span>);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
.reveal-on-hover {
  background-color: #ccc;
  color: transparent;
  border-radius: 4px;
  padding: 4px 8px;
  transition: color 0.3</summary>
      
    
    
    
    <category term="小怪兽的刷题日记" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="LC" scheme="http://example.com/tags/LC/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程面试题</title>
    <link href="http://example.com/2025/07/13/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2025/07/13/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/</id>
    <published>2025-07-13T00:00:00.000Z</published>
    <updated>2025-07-13T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<style>.reveal-on-hover {  background-color: #ccc;  color: transparent;  border-radius: 4px;  padding: 4px 8px;  transition: color 0.3s ease;  cursor: pointer;}.reveal-on-hover:hover {  color: #000;}</style><h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="synchronized-的锁升级过程"><a href="#synchronized-的锁升级过程" class="headerlink" title="synchronized 的锁升级过程"></a>synchronized 的锁升级过程</h2><p><span class="reveal-on-hover">无锁  ↓（线程获得锁）偏向锁（记录线程ID）  ↓（出现其他线程竞争）撤销偏向锁  ↓（CAS 成功）轻量级锁（用户态自旋锁）  ↓（CAS 多次失败）重量级锁（内核态阻塞锁）</span></p><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><ul><li>面试官:介绍一下new线程的几种方式</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>继承Thread 最简单的</li><li>实现 Runnable 接口,需要重写run方法</li><li>继承 Callable 接口 + FutureTask (有返回值)</li></ol></div></details></li><li><p>面试官: 三个线程，依次打印数字 1 ~ 9，每个线程打印一个数字，三个线程之间 轮流执行，形成交替打印的效果。简单说一下思路</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>我会声明两个公共变量，一个记录线程id和应该打印的数字，并使用锁去锁住代码块，每一个线程过来的时候都需要拥有锁，并且判断线程id必须和公共变量的线程id一致才能打印，打印之后线程id会自增，并唤醒所有等待的线程，再次去竞争锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AlternatePrint</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前要打印的数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadFlag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前该哪个线程执行，取值为1/2/3</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> () -&gt; printNumber(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; printNumber(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task3</span> <span class="hljs-operator">=</span> () -&gt; printNumber(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task1, <span class="hljs-string">&quot;线程1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;线程2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task3, <span class="hljs-string">&quot;线程3&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-comment">// 如果当前不是该线程打印，进入等待</span><br>                <span class="hljs-keyword">while</span> (threadFlag != threadId) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 如果数字超过9，结束所有线程</span><br>                <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">9</span>) &#123;<br>                    lock.notifyAll();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 打印: &quot;</span> + number);<br>                number++;<br><br>                <span class="hljs-comment">// 设置下一个线程标识：1 -&gt; 2 -&gt; 3 -&gt; 1</span><br>                threadFlag = threadId % <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">// 唤醒所有线程</span><br>                lock.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div></details></li><li><p>面试官:线程之间的通信方式有什么</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>✅ 1. 共享变量通信（最常用）<br>  示例：使用 volatile 关键字保证可见性</li><li>✅ 2. wait() / notify() / notifyAll()（配合 synchronized 使用）</li><li><ol><li>Lock + Condition（更灵活的等待/通知机制）<ul><li>java.util.concurrent.locks.Condition 提供比 wait/notify 更灵活的方式，如多个条件队列。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (!conditionMet) &#123;<br>        condition.await(); <span class="hljs-comment">// 相当于 wait()</span><br>    &#125;<br>    <span class="hljs-comment">// do something</span><br>    condition.signal(); <span class="hljs-comment">// 相当于 notify()</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li><li>✅ 4. join() 方法<ul><li>让一个线程等待另一个线程执行完后再继续。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Child thread running&quot;</span>);<br>&#125;);<br>t.start();<br>t.join();  <span class="hljs-comment">// 当前线程等 t 执行完</span><br>System.out.println(<span class="hljs-string">&quot;Main thread resumes&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>✅ 5. 并发工具类（推荐使用）</p><p>  | 类名               | 功能说明                                                                 |<br>| ———————— | —————————————————————————————————— |<br>| <code>BlockingQueue</code>  | 如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>，线程安全队列，适用于<strong>生产者-消费者模型</strong> |<br>| <code>CountDownLatch</code> | 等待多个线程完成后再继续执行                                                       |<br>| <code>CyclicBarrier</code>  | 等待多个线程到达某一屏障点后一起执行                                                   |<br>| <code>Semaphore</code>      | 控制并发线程数量                                                             |<br>| <code>Exchanger</code>      | 两个线程之间<strong>交换数据</strong>                                                       |</p></li></ul></div></details></li><li><p>面试官:线程池的拒绝策略有哪些</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><div class="table-container"><table><thead><tr><th>策略类</th><th>行为说明</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛出 <code>RejectedExecutionException</code> 异常</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>谁提交任务，谁就自己去执行（同步）</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃任务，不抛异常</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃队列中最老的任务，尝试提交当前任务</td></tr></tbody></table></div></div></details></li></ul><ul><li>面试官:进程通信的有什么方式</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li><p>使用数据库和redis</p></li><li><p>Socket 通信 例如 netty</p><ul><li>适合多数 Java 多进程或多 JVM 程序之间通信。</li></ul></li><li>读写文件<ul><li>一个写、一个读</li></ul></li></ol></div></details></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;style&gt;
.reveal-on-hover {
  background-color: #ccc;
  color: transparent;
  border-radius: 4px;
  padding: 4px 8px;
  transition: color 0.3</summary>
      
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题</title>
    <link href="http://example.com/2025/07/11/interview/JAVA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2025/07/11/interview/JAVA%E5%9F%BA%E7%A1%80/</id>
    <published>2025-07-11T00:00:00.000Z</published>
    <updated>2025-07-11T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础篇"><a href="#JAVA基础篇" class="headerlink" title="JAVA基础篇"></a>JAVA基础篇</h1><h2 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>含义<br>反射是 Java 提供的一种机制，可以在运行时动态地获取类的信息、创建对象、调用方法、访问字段。</li></ol><ul><li>换句话说:<ul><li>平时你是写死调用类、方法</li><li>反射让你在“运行时”动态操作类和对象</li></ul></li></ul><ol><li>🧠 举个最简单的例子<br>👇 正常方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.sayHello();<br></code></pre></td></tr></table></figure>👇 反射方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;Person&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance(); <span class="hljs-comment">// 创建对象</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;sayHello&quot;</span>);               <span class="hljs-comment">// 找到方法</span><br>method.invoke(obj);                                        <span class="hljs-comment">// 调用方法</span><br></code></pre></td></tr></table></figure>🔍 说明：</li></ol><ul><li>Class.forName(“类名”)：加载类</li><li>getDeclaredConstructor().newInstance()：创建对象</li><li>getMethod(“方法名”)：获取方法</li><li>invoke()：执行方法</li></ul><ol><li>为什么说反射是在运行时<br>通过学习JVM，我们已经知道，我们编写一个类，会执行为class文件，类加载器会将class文件加载到JVM中，其中方法区存的是类的属性和方法信息。<br>👇当我们new了一个对象时，会在堆中开辟一块空间存放这个对象，这个过程是在编译过程中的，还没有开始运行，就已经知道了需要这个对象，所以开辟一块空间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.sayHello();<br></code></pre></td></tr></table></figure>当你执行：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.MyClass&quot;</span>);<br><br></code></pre></td></tr></table></figure>clazz.getMethod(“methodName”) 查的是：<br>查的是方法区中该类的“方法表”，而不是去堆中查找。<br>每个类在被加载的时候，JVM 会为它建立一个「类元信息结构」：</li></ol><ul><li>方法名</li><li>返回类型</li><li>参数类型</li><li>修饰符（public/private/static）</li><li>方法在字节码里的位置</li><li>字节码数组（code）</li></ul><p>反射就是读取这些信息，并用它来动态调用</p></div></details><h3 id="final，finally，finalize的区别是什么"><a href="#final，finally，finalize的区别是什么" class="headerlink" title="final，finally，finalize的区别是什么"></a>final，finally，finalize的区别是什么</h3><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><div class="table-container"><table><thead><tr><th>关键词</th><th>类型</th><th>用途</th><th>是否是关键字</th></tr></thead><tbody><tr><td><code>final</code></td><td>关键字</td><td>声明<strong>常量/不可变对象/类/方法</strong></td><td>✅ 是</td></tr><tr><td><code>finally</code></td><td>关键字</td><td>用于 <code>try-catch-finally</code> 中，<strong>一定会执行的代码块</strong></td><td>✅ 是</td></tr><tr><td><code>finalize()</code></td><td>Object 方法</td><td>垃圾回收前由 GC 调用的<strong>钩子函数</strong>，已过时</td><td>❌ 是方法</td></tr></tbody></table></div></div></details><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>面试官:JAVA的基础八大类型</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><div class="table-container"><table><thead><tr><th>类型</th><th>类别</th><th>示例</th></tr></thead><tbody><tr><td>byte</td><td>整数</td><td>byte a = 10;</td></tr><tr><td>short</td><td>整数</td><td>short b = 20;</td></tr><tr><td>int</td><td>整数</td><td>int c = 100;</td></tr><tr><td>long</td><td>整数</td><td>long d = 1000L;</td></tr><tr><td>float</td><td>浮点</td><td>float e = 3.14f;</td></tr><tr><td>double</td><td>浮点</td><td>double f = 3.1415;</td></tr><tr><td>char</td><td>字符</td><td>char g = ‘A’;</td></tr><tr><td>boolean</td><td>布尔</td><td>boolean h = true;</td></tr></tbody></table></div></div></details></li></ul><ul><li>面试官: 怎么把string类型的时间转换成时间类型</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>使用 DateTimeFormatter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">timeStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2025-07-24 15:30:00&quot;</span>;<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.parse(timeStr, formatter);<br><br>        System.out.println(<span class="hljs-string">&quot;转换后的 LocalDateTime：&quot;</span> + localDateTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></div></details></li><li><p>面试官: 判断一个字段是一个字符串的第几位，用哪个方法</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>String.indexOf()<br>底层是通过字符数组遍历+匹配来实现的。对于单字符查找，它会从字符串左边开始，逐个比较字符值是否相等；对于子字符串查找（indexOf(String)），JDK 使用的是一种改进版的暴力匹配算法</li></ul><div class="note info flat"><p>面试官问我的时候，我想不起来了，我说用charAt循环遍历一下，太好笑了，估计给面试官都整无语了，想得起来这个，想不起来 String.indexOf() </p></div></div></details></li><li><p>面试官:Spring Boot 启动核心注解</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCreateCacheAnnotation</span><br><span class="hljs-meta">@EnableMethodCache(basePackages = &quot;com.shortplay.server&quot;)</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(StartApp.class, args);<br>        <span class="hljs-type">Environment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> context.getEnvironment();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">active</span> <span class="hljs-operator">=</span> env.getProperty(<span class="hljs-string">&quot;spring.profiles.active&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;服务启动成功, active = &#123;&#125;&quot;</span>, active);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>✅ @SpringBootApplication（最核心）等价于以下三个注解的组合：</p><ul><li>@Configuration               // 表示该类是配置类（等同于配置文件）</li><li>@EnableAutoConfiguration     // 开启自动配置功能（根据 classpath 中的 jar 自动配置）</li><li>@ComponentScan               // 开启包扫描（默认扫描当前类所在包及其子包）</li></ul><div class="table-container"><table><thead><tr><th>注解</th><th>来源</th><th>作用</th></tr></thead><tbody><tr><td><code>@EnableScheduling</code></td><td>Spring</td><td>启用定时任务</td></tr><tr><td><code>@EnableMethodCache</code></td><td>JetCache</td><td>启用方法级缓存，识别 <code>@Cached</code> 等注解</td></tr><tr><td><code>@EnableCreateCacheAnnotation</code></td><td>JetCache</td><td>启用 <code>@CreateCache</code>，用于声明缓存对象</td></tr></tbody></table></div></div></details><h1 id="集合篇"><a href="#集合篇" class="headerlink" title="集合篇"></a>集合篇</h1></li><li><p>面试官:介绍一下hashmap</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>HashMap 是 Java 中最常用的集合类之一，它基于哈希表（Hash Table）实现，用于以键值对（Key-Value）的形式存储数据，属于 java.util 包中的一部分。<br>HashMap的特点:</p><ul><li>线程不安全</li><li>JDK8之前:数组 + 链表;JDK8之后:数组 + 链表/红黑树（链表长度超过 8 且数组长度大于 64 时转为红黑树）</li><li>✅ 允许一个 null 键和多个 null 值</li><li>初始容量     默认是 16</li><li>负载因子     默认是 0.75（即 75% 满时扩容）</li></ul><p>HashMap存储数据的原理:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></p><ul><li>✅ 第一步：计算哈希值（扰动函数）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br></code></pre></td></tr></table></figure></li><li>✅ 第二步：定位数组下标（index）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (table.length - <span class="hljs-number">1</span>) &amp; hash;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (n - <span class="hljs-number">1</span>) &amp; hash;<br></code></pre></td></tr></table></figure></li><li><p>✅ 第三步：判断该位置是否已有元素</p><ul><li>如果该位置是空的：说明没有哈希冲突，直接插入新节点。</li></ul></li><li><p>✅ 第四步：如果该位置不为空（发生哈希冲突）</p><ul><li>此时需要将该位置的数据取出，判断key是否相等<ul><li>相等的话则直接覆盖 value即可 （例如:map.put(“apple”, 1),key指的是apple）</li><li>不相等则遍历链表或者红黑树在末尾插入数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Node&lt;K,V&gt; p = table[index];<br><span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; (p.key == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(p.key)))) &#123;<br>    <span class="hljs-comment">// key 相等，直接覆盖旧值</span><br>    p.value = value;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 遍历链表或红黑树</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li>✅ 第五步：是否需要扩容<ul><li>每次插入后判断是否需要扩容</li></ul></li></ul><p>put(key, value)<br>     ↓<br>计算 hash → 计算 index = (n-1) &amp; hash<br>     ↓<br>判断 table[index]<br>     ↓<br>为空 → 直接插入新节点<br>     ↓<br>不为空 → 判断是否 key 相等<br>     ↓<br>key 相等 → 覆盖旧值<br>     ↓<br>key 不相等 → 链表尾部插入或转红黑树<br>     ↓<br>插入后判断是否需要扩容</p></div></details></li></ul><ul><li>面试官: hashmap为什么会选择红黑树而不是其他的树</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>红黑树是一种自平衡二叉搜索树，可以保证基本操作（查找、插入、删除）时间复杂度为 O(log n)。</li><li>兼顾查找速度和维护成本<ul><li>AVL 树查找速度稍优于红黑树，但插入/删除时旋转较多，开销大。(AVL树的性质：左子树高度 - 右子树高度，且值只能是 -1、0、1。)</li><li>红黑树牺牲一点查找效率，换来更少的重平衡操作，整体性能更均衡。</li></ul></li></ol></div></details></li><li><p>面试官: 什么是哈希表</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>哈希表的结构:<br>哈希表（Hash Table）的底层结构主要由 数组 组成，结合 链表 或 红黑树 来处理哈希冲突。</li></ol><ul><li>数组（Bucket 数组）<ul><li>核心存储结构是一个数组，每个数组位置称为“桶”（bucket）。</li><li>哈希函数计算出的哈希值会映射到数组的某个索引位置。</li><li>数组的每个元素是一个链表或红黑树的头节点，用来处理哈希冲突。</li></ul></li><li>链表（或红黑树）<ul><li>因为不同的键可能映射到相同的桶，产生冲突（哈希冲突）。</li><li>传统解决冲突的方法是用链表把冲突的元素串起来，存放在同一个桶中。</li><li>JDK8 及以后，当链表长度过长时，会将链表转换成红黑树，提高查找效率。</li></ul></li><li>结构示意图<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">table（数组）：<br>+----------+----------+----------+----------+------------------+<br>| bucket0  | bucket1  | bucket2  | bucket3  |    bucket4       |<br>|  null    |   ↓      |  null    |   ↓      |        ↓         |<br>|          | Node1    |          | Node3    |   TreeNodeA(B)   |  ← 红黑树根节点（黑）<br>|          |   ↓      |          |   ↓      |     /      \     |<br>|          | Node2    |          | Node4    |  R(B)     T(R)   |<br>|          |          |          |          |   /  \     \     |<br>|          |          |          |          | ...  ...   X(B)  |<br>+----------+----------+----------+----------+------------------+<br><br>说明：<br>- bucket0：为空（null）<br>- bucket1：有两个冲突元素，用链表 Node1 → Node2 存储<br>- bucket3：链表 Node3 → Node4<br>- bucket4：冲突太多，链表已转为红黑树（TreeNodeA 是根）<br></code></pre></td></tr></table></figure></li></ul></div></details></li></ul><ul><li>面试官:如果一个对象 没有重写 equals() 方法，将它作为 HashMap 的 key，会产生什么问题？</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>HashMap 判断两个 key 是否相同，要经过两个步骤：</p><ul><li>比较 hash 值是否相等：hash(key1) == hash(key2)</li><li>调用 equals() 方法判断是否真的“相等”：key1.equals(key2)<br>如果没有重写hashCode()，则两个对象的hash值可能会不同<br>如果没有重写equals的话，equals等价于 ==，只有引用相同时才会返回true<br>例如:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br><br>    Person(String name) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br>HashMap&lt;Person, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//new了两个对象，所以在JVM的堆内存中 会有两个对象属性 p1和p2</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>); <br><span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-comment">//将p1加到hashmap中</span><br>map.put(p1, <span class="hljs-string">&quot;Developer&quot;</span>);<br><span class="hljs-comment">//(前提:已经重写hashCode()，没有重写equles)因为没有重写equals，所以map.get的方法中的比较key时会是false,会发现没有一样的key，所以会返回null</span><br><span class="hljs-comment">//(前提:已经重写equles，没有重写hashCode())因为没有重写hashCode()，所以map.get的方法中通过计算hash来确定数据在哪一个位置，但是p2的hash值和p1的hash值不同，所以p1的位置在map中的第一个位置，但是却去第二个位置查找了，所以会一致查询不到</span><br>System.out.println(map.get(p2)); <span class="hljs-comment">// 输出NULL？</span><br></code></pre></td></tr></table></figure></li><li>重写equles和hashcode示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 equals() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                       <span class="hljs-comment">// 1. 引用相同</span><br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span> || getClass() != obj.getClass())    <span class="hljs-comment">// 2. 类型不同</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) obj;                       <span class="hljs-comment">// 3. 类型一样，强制转换</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp;                         <span class="hljs-comment">// 4. 按字段比较</span><br>               Objects.equals(name, person.name);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 hashCode() 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age); <span class="hljs-comment">// 推荐写法</span><br>    &#125;<br><br>    <span class="hljs-comment">// 可选：用于打印</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;, age=&quot;</span> + age + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></div></details></li><li><p>面试官:如何实现把hashmap的数据按key排序，可以利用其他数据结构也可以在hashmap上</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>✅ 方法一：使用 TreeMap （TreeMap会自动排序）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>);<br>        map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 将 HashMap 转成 TreeMap（自动按 key 升序排序）</span><br>        Map&lt;String, Integer&gt; sortedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(map);<br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : sortedMap.entrySet()) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot; = &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>✅ 方法二：使用 HashMap.entrySet() + List 排序<br>HashMap.entrySet():是 Java Map 接口中的一个非常重要的方法，它的作用是返回 该 Map 中所有键值对（Entry）的集合。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>);<br>        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>);<br>        map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 转换为 List&lt;Map.Entry&gt;</span><br>        List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.entrySet());<br><br>        <span class="hljs-comment">// 按 key 升序排序</span><br>        entryList.sort(Map.Entry.comparingByKey());<br><br>        <span class="hljs-comment">// 排序后插入 HashMap 保持顺序</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></div></details></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA基础篇&quot;&gt;&lt;a href=&quot;#JAVA基础篇&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础篇&quot;&gt;&lt;/a&gt;JAVA基础篇&lt;/h1&gt;&lt;h2 id=&quot;八股文&quot;&gt;&lt;a href=&quot;#八股文&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>简历项目面试题</title>
    <link href="http://example.com/2025/07/05/interview/%E7%AE%80%E5%8E%86%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2025/07/05/interview/%E7%AE%80%E5%8E%86%E9%9D%A2%E8%AF%95/</id>
    <published>2025-07-05T00:00:00.000Z</published>
    <updated>2025-07-05T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="短剧"><a href="#短剧" class="headerlink" title="短剧"></a>短剧</h1><p><img src="https://pic1.imgdb.cn/item/6868cc3af8595c5440cf7275.png" alt=""></p><ul><li>面试官:什么是S3</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>AWS 的 S3 是 AWS 提供的一种 对象存储服务，主要用于在云端存储和检索任何数量的数据。</p></div></details></li><li><p>面试官:用过MinIO吗？</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>我没有用过MinIO🧠<br>MinIO 是一个高性能、开源的对象存储系统，兼容 Amazon S3 接口，常用于私有云、本地部署或边缘计算场景下的对象存储。<br>MinIO 是一个轻量、兼容 S3 的对象存储服务，适合本地部署和私有云场景，特别适合企业内部或开发者使用。</p></div></details></li><li><p>面试官:对象存储，文件存储，块存储的区别是什么?</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>文件存储给人用、对象存储给程序用、块存储给操作系统用。</p><div class="table-container"><table><thead><tr><th>特性</th><th>文件存储</th><th>对象存储</th><th>块存储</th></tr></thead><tbody><tr><td>📦 存储单位</td><td>文件（File）</td><td>对象（Object）</td><td>块（Block）</td></tr><tr><td>📁 组织方式</td><td>文件夹 + 文件路径结构</td><td>扁平结构，用唯一ID访问</td><td>无结构，由操作系统管理</td></tr><tr><td>🔌 访问方式</td><td>路径访问（如 <code>/home/a.txt</code>）</td><td>API/URL 访问（如 <code>s3://...</code>）</td><td>挂载磁盘后由操作系统访问</td></tr><tr><td>🧠 元数据支持</td><td>有限（创建时间、大小等）</td><td>丰富（可自定义键值对）</td><td>几乎无（仅存数据）</td></tr><tr><td>🚀 性能/IO</td><td>中等</td><td>适中（适合大文件）</td><td>高性能、低延迟</td></tr><tr><td>🌐 可扩展性</td><td>一定限制</td><td>极强（PB 级别、全球访问）</td><td>通常限于单个实例或卷</td></tr><tr><td>🛠 典型用途</td><td>文件共享、代码仓库、日志文件</td><td>图片/音视频、备份、云应用资源</td><td>数据库、操作系统磁盘、VM磁盘</td></tr><tr><td>☁️ AWS 示例服务</td><td>Amazon EFS</td><td>Amazon S3</td><td>Amazon EBS</td></tr></tbody></table></div></div></details></li><li><p>面试官:你使用了谷歌登录，那你一定了解0auth2.0吧</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>是的，OAuth 2.0 是一种 授权协议，用于在第三方应用和资源服务器（如用户的数据）之间安全地进行授权访问，而无需暴露用户密码。<br>OAuth 2.0 解决了 用户想让一个应用访问 TA 的资源（比如 GitHub、微博、Google 相册）但又不想给密码 的问题，可以在没有密码的情况下，在用户允许的范围内访问你的信息</p></div></details></li><li><p>面试官:Oauth2.0的流程是怎样的</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>拿谷歌登录为例:</p><ol><li>登录谷歌控制台获取 KEY 和密钥，设置回调地址</li><li>web端用户点击谷歌登录后，我后端会生成一个谷歌登录页面的链接</li><li>用户同意之后，谷歌会进行回调并携带一个code</li><li>后端使用code，KEY 密钥 向谷歌发起请求获取到token</li><li>后端使用token调用谷歌API获取到用户信息</li></ol></div></details></li><li><p>面试官:你是怎么实现文件传到S3上的</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>使用 Multipart Upload（分片上传）<br>AWS 提供多部分上传 API：将大文件拆成 5MB~500MB 的小块上传，最后合并，具备：</li></ol><ul><li>✅ 断点续传能力</li><li>✅ 可并发分片上传，加快速度</li><li>✅ 上传大文件更安全、稳定</li></ul></div></details></li></ul><ul><li>面试官:你都使用redis实现了那些功能，具体怎么实现的</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>我使用redis实现了防止账号重复登陆的问题，具体实现:我在拦截器中会先解析传过来的token，解析出账号和id,并根据账号和id去查询redis中存放的token，判断两个token是否一致，不一致就将旧的token替换掉，实现防止账号重复登录问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><span class="hljs-comment">//加入到sprng容器里</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-comment">//令牌验证token</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//拦截器中判断redis中的是否存在token</span><br><br>            Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> (String) claims.get(<span class="hljs-string">&quot;account&quot;</span>);<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Integer) claims.get(<span class="hljs-string">&quot;id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">redisToken</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;Backstage&quot;</span>+account+id);<br>            <span class="hljs-keyword">if</span> (redisToken==<span class="hljs-literal">null</span>||!redisToken.equals(token))&#123;<br>                <span class="hljs-comment">// 设置响应头</span><br>                response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); <span class="hljs-comment">// 401</span><br><br>                <span class="hljs-comment">// 构造响应体</span><br>                Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                result.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">401</span>);<br>                result.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;登录已失效，请重新登录&quot;</span>);<br>                result.put(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-literal">null</span>);<br><br>                <span class="hljs-comment">// 返回 JSON</span><br>                response.getWriter().write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(result));<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;token已过期&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//将claims的值加载到线程ThreadLocal中</span><br>            ThreadLocalUtil.set(claims);<br>            <span class="hljs-comment">//放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <span class="hljs-comment">//http响应401</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//请求结束后清空线程</span><br>        ThreadLocalUtil.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></div></details></li><li><p>面试官:为什么要防止账号重复登录，一个账号在APP端和web端不能同事登录吗</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>APP端和web端当然可以同时登录，防止账号重复登录时为了解决同一个账号同时在两台电脑或者手机上同时登录，我是通过前端向后端发送请求的时候，会有请求头，请求头中会携带一个参数来判断是APP还是WEB，例如 参数是1 则是APP登录，参数是0 则是WEB端登录</p></div></details></li></ul><h1 id="ChatMate-—-类微信即时通讯系统"><a href="#ChatMate-—-类微信即时通讯系统" class="headerlink" title="ChatMate — 类微信即时通讯系统"></a>ChatMate — 类微信即时通讯系统</h1><p><img src="https://pic1.imgdb.cn/item/6885de2558cb8da5c8e448b4.png" alt=""></p><ul><li>面试官:什么是RTpoic 发布-订阅（Pub/Sub）</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>RTopic 是 Redisson（一个基于 Redis 的 Java 客户端）提供的一个基于 Redis 发布/订阅机制的接口。</p><ul><li>发布-订阅（Publish/Subscribe, Pub/Sub） 是一种消息传递模式，核心思想是：<ul><li>发布者（Publisher）：负责向一个或多个主题（Topic）发布消息。</li><li>订阅者（Subscriber）：订阅一个或多个主题，接收发布到这些主题的消息。</li><li>主题（Topic）：消息传递的逻辑通道，发布者发消息到主题，订阅者订阅主题消息。</li></ul></li><li>特点：<ul><li>发布者和订阅者相互独立，互不知晓对方存在。</li><li>订阅者接收所有发布到所订阅主题的消息，实现广播效果。</li></ul></li></ul></div></details></li><li><p>面试官:使用RTpoic 发布-订阅 做了什么？</p></li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>实现了消息跨实例也能传输，如果部署到多台服务器上，不使用消息队列，那么只能实现一台服务器上的用户通信，使用消息队列后可以实现不同服务器上的用户进行通信。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component(&quot;messageHandler&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageHandler</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MessageHandler.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MESSAGE_TOPIC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message.topic&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ChannelContextUtils channelContextUtils;<br><br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lisMessage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 订阅消息频道</span><br>        <span class="hljs-type">RTopic</span> <span class="hljs-variable">rTopic</span> <span class="hljs-operator">=</span> redissonClient.getTopic(MESSAGE_TOPIC);<br>        <span class="hljs-comment">// 监听消息，收到消息进行发送消息的方法</span><br>        rTopic.addListener(MessageSendDto.class, (MessageSendDto, sendDto) -&gt; &#123;<br>            logger.info(<span class="hljs-string">&quot;收到广播消息:&#123;&#125;&quot;</span>, JSON.toJSONString(sendDto));<br>            channelContextUtils.sendMessage(sendDto);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 发送消息，将消息发送到频道里</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(MessageSendDto sendDto)</span> &#123;<br>        <span class="hljs-type">RTopic</span> <span class="hljs-variable">rTopic</span> <span class="hljs-operator">=</span> redissonClient.getTopic(MESSAGE_TOPIC);<br>        rTopic.publish(sendDto);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></div></details></li><li><p>面试官:发送消息流程是怎样的</p></li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li><p>登录后会连接netty</p></li><li><p>通过http接口获取到发送的消息的内容</p><ul><li>这一步会将消息存数据库一份</li><li>接着会将消息 发给消息队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">    <span class="hljs-meta">@RequestMapping(&quot;/sendMessage&quot;)</span><br><span class="hljs-meta">@GlobalInterceptor</span><br><span class="hljs-keyword">public</span> ResponseVO <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                              <span class="hljs-meta">@NotEmpty</span> String contactId,</span><br><span class="hljs-params">                              <span class="hljs-meta">@NotEmpty</span> <span class="hljs-meta">@Max(500)</span> String messageContent,</span><br><span class="hljs-params">                              <span class="hljs-meta">@NotNull</span> Integer messageType,</span><br><span class="hljs-params">                              Long fileSize,</span><br><span class="hljs-params">                              String fileName,</span><br><span class="hljs-params">                              Integer fileType)</span> &#123;......&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>redis的rTopic 接收消息<ul><li>rTopic 收到消息后 会触发 channelContextUtils.sendMessage(sendDto)发送消息; </li><li>Redis 的 Pub/Sub（发布订阅）机制，它是<strong>“即时广播”机制，不会持久保存消息</strong>，也不会堆积在 Redis 里。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">   <span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lisMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RTopic</span> <span class="hljs-variable">rTopic</span> <span class="hljs-operator">=</span> redissonClient.getTopic(MESSAGE_TOPIC);<br>    rTopic.addListener(MessageSendDto.class, (MessageSendDto, sendDto) -&gt; &#123;<br>        logger.info(<span class="hljs-string">&quot;收到广播消息:&#123;&#125;&quot;</span>, JSON.toJSONString(sendDto));<br>        channelContextUtils.sendMessage(sendDto);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(MessageSendDto sendDto)</span> &#123;<br>    <span class="hljs-type">RTopic</span> <span class="hljs-variable">rTopic</span> <span class="hljs-operator">=</span> redissonClient.getTopic(MESSAGE_TOPIC);<br>    rTopic.publish(sendDto);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>发送消息 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"> <span class="hljs-type">Channel</span> <span class="hljs-variable">sendChannel</span> <span class="hljs-operator">=</span> USER_CONTEXT_MAP.get(reciveId);<br>   <span class="hljs-keyword">if</span> (sendChannel == <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">return</span>;<br>   &#125;<br>sendChannel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWebSocketFrame</span>(JsonUtils.convertObj2Json(messageSendDto)));<br></code></pre></td></tr></table></figure></li><li>前端渲染消息<ul><li>前端 WebSocket 实例监听到第4步的消息，会展示到聊天界面上</li></ul></li></ol></div></details></li></ul><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><ul><li>面试官: 如果有一个后端的接口，接口内需要访问其他四个服务，这四个服务都是100ms,如果顺序访问要400ms, 如果只用一个线程，不用多线程，怎么降到100ms多</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p>可以使用 异步非阻塞 IO（如异步 HTTP 客户端） 来实现“多个请求同时发出”，从而让接口总耗时≈最长的一个（即约 100ms），即使你用的是单线程</p><p>例如: webclient<br>特点:</p><ul><li>单线程+ 非阻塞</li><li>多个请求可同时发出</li></ul></div></details></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;短剧&quot;&gt;&lt;a href=&quot;#短剧&quot; class=&quot;headerlink&quot; title=&quot;短剧&quot;&gt;&lt;/a&gt;短剧&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic1.imgdb.cn/item/6868cc3af8595c5440cf7275.png&quot; alt</summary>
      
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL的面试题</title>
    <link href="http://example.com/2025/07/01/interview/MYSQL/"/>
    <id>http://example.com/2025/07/01/interview/MYSQL/</id>
    <published>2025-07-01T00:00:00.000Z</published>
    <updated>2025-07-01T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<style>.reveal-on-hover {  background-color: #ccc;  color: transparent;  border-radius: 4px;  padding: 4px 8px;  transition: color 0.3s ease;  cursor: pointer;}.reveal-on-hover:hover {  color: #000;}</style><h1 id="MYSQL的内连接和外连接的区别"><a href="#MYSQL的内连接和外连接的区别" class="headerlink" title="MYSQL的内连接和外连接的区别"></a>MYSQL的内连接和外连接的区别</h1><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black">答案</summary><div class="toggle-content"><p>内连接（INNER JOIN）和外连接（OUTER JOIN）是 SQL 中常用于多表查询的两种连接方式，它们的核心区别在于是否保留不匹配的记录。<br>内连接只会保留两个表都存在的列，而外连接分为两种，一种是左连接和右连接，分别会保留下左表或者右表的的列</p><div class="table-container"><table><thead><tr><th>类型</th><th>语义</th></tr></thead><tbody><tr><td>INNER JOIN</td><td><strong>只要匹配的，不匹配都不要</strong></td></tr><tr><td>LEFT JOIN</td><td><strong>以左表为主，不匹配补 NULL</strong></td></tr><tr><td>RIGHT JOIN</td><td><strong>以右表为主，不匹配补 NULL</strong></td></tr></tbody></table></div></div></details><h1 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h1><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black">答案</summary><div class="toggle-content"><p>SQL 注入 是一种将恶意 SQL 语句注入应用程序输入，从而欺骗服务器执行攻击者自定义 SQL 命令的安全漏洞。<br>例如: 后端这么写一条SQL<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">SELECT * FROM users <span class="hljs-type">WHERE</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> admin <span class="hljs-type">AND</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> password;<br></code></pre></td></tr></table></figure><br>攻击者输入：<br>用户名：’ OR ‘1’=’1<br>密码：任意</p><p>拼接后的SQL:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">SELECT * FROM users <span class="hljs-type">WHERE</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span> OR <span class="hljs-string">&#x27;1&#x27;</span>=<span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-type">AND</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span>;<br></code></pre></td></tr></table></figure><br>‘1’=’1’ 永远为真，所以这个 SQL 返回了所有用户，相当于绕过了登录验证。</p><p>一般情况下 mybatis会处理参数拼接的情况</p></div></details><h1 id="UPDATE的子查询特性"><a href="#UPDATE的子查询特性" class="headerlink" title="UPDATE的子查询特性"></a>UPDATE的子查询特性</h1><p>在 UPDATE 中不能在子查询里再次引用同一张表。 例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span>  product_collect <span class="hljs-keyword">set</span> salePlats <span class="hljs-operator">=</span>&quot;marketing_saleplat_swan&quot; <br><span class="hljs-keyword">where</span> uuid <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span> uuid <span class="hljs-keyword">from</span> product_collect <span class="hljs-keyword">where</span> productType <span class="hljs-keyword">in</span>(&quot;05&quot;,&quot;08&quot;,&quot;09&quot;))<br></code></pre></td></tr></table></figure><ul><li><p>为什么不可以呢？</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>MySQL 的执行方式是“一边读一边写”<ul><li>而 MySQL 在执行 UPDATE 时是这样工作的：按顺序扫描表 → 找到符合条件的行 → 更新它 。但同时，你又要求 MySQL 在更新过程中，再去读同一张可能正在被更新的表。</li></ul></li><li>MySQL 的扫描和更新顺序会破坏子查询结果<ul><li>由于 UPDATE 会修改表内容，子查询读取的数据可能：<ul><li>被 UPDATE 刚刚修改过</li><li>还没被更新</li><li>扫描顺序变化</li><li>甚至行可能被锁住<br>这会导致执行结果 不确定、不稳定、不安全。</li></ul></li></ul></li></ol></div></details></li><li><p>解决方法：</p></li></ul><ol><li>用子查询包一层 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">UPDATE</span> product_collect<br><span class="hljs-keyword">SET</span> salePlats <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;marketing_saleplat_swan&#x27;</span><br><span class="hljs-keyword">WHERE</span> uuid <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> uuid <span class="hljs-keyword">FROM</span> (<br>        <span class="hljs-keyword">SELECT</span> uuid<br>        <span class="hljs-keyword">FROM</span> product_collect<br>        <span class="hljs-keyword">WHERE</span> productType <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;05&#x27;</span>,<span class="hljs-string">&#x27;08&#x27;</span>,<span class="hljs-string">&#x27;09&#x27;</span>)<br>    ) <span class="hljs-keyword">AS</span> tmp<br>);<br></code></pre></td></tr></table></figure>原因： 最里面的子查询 会形成一个临时表 tem</li><li>使用临时表<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 1. 创建临时表，保存需要更新的 skuNo</span><br><span class="hljs-keyword">CREATE</span> TEMPORARY <span class="hljs-keyword">TABLE</span> tmp <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> uuid, <span class="hljs-string">&#x27;marketing_saleplat_swan&#x27;</span> <span class="hljs-keyword">AS</span> newSalePlats<br><span class="hljs-keyword">FROM</span> product_collect<br><span class="hljs-keyword">WHERE</span> productType <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;05&#x27;</span>, <span class="hljs-string">&#x27;08&#x27;</span>, <span class="hljs-string">&#x27;09&#x27;</span>);<br><br><span class="hljs-comment">-- 2. 用 JOIN 更新</span><br><span class="hljs-keyword">UPDATE</span> product_collect pc<br><span class="hljs-keyword">JOIN</span> tmp t <span class="hljs-keyword">ON</span> pc.uuid <span class="hljs-operator">=</span> t.uuid<br><span class="hljs-keyword">SET</span> pc.salePlats <span class="hljs-operator">=</span> t.newSalePlats;<br><br><span class="hljs-comment">-- 3. 更新完成后删除临时表</span><br><span class="hljs-keyword">DROP</span> TEMPORARY <span class="hljs-keyword">TABLE</span> tmp;<br></code></pre></td></tr></table></figure></li></ol><h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><ul><li>面试官: 怎么查询慢SQL</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li>查看慢查询日志（MySQL）<ul><li>MySQL 的 慢查询日志（slow query log） 会记录执行时间超过 long_query_time 的 SQL 语句，默认是关闭的。<br>打开配置文件（如 /etc/my.cnf 或 /etc/mysql/my.cnf）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL">[mysqld]<br>slow_query_log <span class="hljs-operator">=</span> <span class="hljs-number">1</span>                     # 开启慢查询日志<br>slow_query_log_file <span class="hljs-operator">=</span> <span class="hljs-operator">/</span>var<span class="hljs-operator">/</span>log<span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>mysql<span class="hljs-operator">-</span>slow.log  # 日志保存路径<br>long_query_time <span class="hljs-operator">=</span> <span class="hljs-number">1</span>                   # 超过 <span class="hljs-number">1</span> 秒的 <span class="hljs-keyword">SQL</span> 会被记录<br>log_queries_not_using_indexes <span class="hljs-operator">=</span> <span class="hljs-number">1</span>     # 是否记录未使用索引的查询（可选）<br><br>   <br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log_file&#x27;</span>; # 可通过该语句查看<br><br></code></pre></td></tr></table></figure></li></ul></li></ul></div></details></li></ul><ul><li>面试官: 如何分析慢SQL的原因</li><li>我:<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ul><li><ol><li>用 EXPLAIN 分析执行计划 例如<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><ul><li>重点看这些字段：</li></ul></li></ol></li></ul><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><strong>type</strong></td><td>访问类型，越靠近 <code>const</code> 越好；<code>ALL</code> 是全表扫描（最差）</td></tr><tr><td><strong>key</strong></td><td>实际使用的索引</td></tr><tr><td><strong>rows</strong></td><td>扫描的行数（预估）</td></tr><tr><td><strong>Extra</strong></td><td>是否出现 <code>Using temporary</code>、<code>Using filesort</code>（表示排序/中间表开销）</td></tr></tbody></table></div><div class="note primary flat"><p>如果看到 type=ALL 且 key=NULL：就说明没有使用索引，SQL 慢就是因为全表扫描！</p></div><ul><li><ol><li>查看字段是否有索引</li></ol></li><li><ol><li>对应数据库表的数据量</li></ol></li><li><ol><li>SOL书写</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li><ol><li>总结<br>SQL 慢 ≠ 语句长，通常是没走索引、扫描数据多、排序分页大、锁住了，建议用 EXPLAIN + 慢日志 + PROFILE 三板斧排查，再结合业务改写 SQL 或加索引。</li></ol></li></ul></div></details></li></ul><ul><li>面试官: 如何优化慢SQL</li><li><p>我:</p><details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><ol><li>尽可能走索引</li><li>避免 SELECT *，只取需要字段</li><li>用子查询 + 分页方式代替大范围 Join</li><li>数据量太大，建议分表减少数据量<br>总结：大部分情况 都是加索引为主</li></ol></div></details></li><li><p>面试官: mysql假如有一个用户表，有一个字段是name，并且为其创建了非唯一索引，并且当前表中有三条记录都是name=xx,那么开启一个事务后，并且执行select*from这个表where name=’XXX’for upd ate，加的什么锁？ 如果此时又来一个insert into这个表values(….),其中name也是’XXX’,能插入的了嘛?</p></li><li>我：<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><div class="table-container"><table><thead><tr><th>问题</th><th>答案</th></tr></thead><tbody><tr><td><strong>FOR UPDATE 加了什么锁？</strong></td><td>所有 <code>name=&#39;XXX&#39;</code> 记录的 <strong>排他锁（X 锁）</strong>，+ 对 <code>name=&#39;XXX&#39;</code> 范围的 <strong>间隙锁（Gap Lock）</strong></td></tr><tr><td><strong>能不能插入 name=’XXX’ 的记录？</strong></td><td>❌不能，会被阻塞，因为被间隙锁锁住了（防止幻读）</td></tr></tbody></table></div><ul><li><p>加锁原因分析:</p><ul><li>🔍 关键点：<ul><li>name 是 非唯一索引。所以 WHERE name=’XXX’ 会匹配多条记录。</li><li>FOR UPDATE 表示当前事务要对匹配的记录加排他锁（X锁）。</li><li>在使用非唯一索引时，InnoDB 为了防止幻读，不仅会锁住实际匹配的记录，还会对其所在的索引范围加 间隙锁（Gap Lock）。<br>所以: 排他锁+间隙锁</li></ul></li></ul></li><li><p>插入失败的原因:<br>因为你前一个事务对 name=’XXX’ 的索引范围加了 间隙锁（Gap Lock），插入同一个 name 的值时，会命中这个锁定范围。</p></li><li>扩展: 如果不加 FOR UPDATE 的结果是什么?<ul><li>答: 如果你不加 FOR UPDATE，只是普通的 SELECT 查询，另一个事务是可以正常 INSERT 插入的，即使插入的是相同的 name = ‘XXX’。</li></ul></li></ul></div></details></li></ul><ul><li>面试官: 有如下三张表<br>歌曲表 song (song_id,song_name,singer_id)<br>歌曲点唱信息表 song_status (song_id,listen_count)<br>歌手表 singer(singer_id,singer_name)<br>某歌手下歌曲数为n，这些歌曲点听数为m<br>写一个SQL，按照点听数之和m排序，查询m&gt;10000的歌手<br>输出格式：singer_id，singer_name，歌曲数，歌曲点听数之和</li><li>我：<details class="toggle" style="border: 1px solid  white"><summary class="toggle-button" style="background-color:  white;color:  black"></summary><div class="toggle-content"><p><span class="reveal-on-hover">我是傻子。面试的时候没写出来</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 选择歌手的ID、姓名、歌曲数、总点听数</span><br><span class="hljs-keyword">SELECT</span> <br>    s.singer_id,                                     <span class="hljs-comment">-- 歌手ID</span><br>    s.singer_name,                                   <span class="hljs-comment">-- 歌手姓名</span><br>    <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> so.song_id) <span class="hljs-keyword">AS</span> song_count,        <span class="hljs-comment">-- 去重后的歌曲数量</span><br>    <span class="hljs-built_in">SUM</span>(ss.listen_count) <span class="hljs-keyword">AS</span> total_listen_count       <span class="hljs-comment">-- 该歌手所有歌曲的点听总数</span><br><span class="hljs-keyword">FROM</span> <br>    singer s                                          <span class="hljs-comment">-- 从歌手表开始查起，起别名 s</span><br><span class="hljs-keyword">JOIN</span> <br>    song so <span class="hljs-keyword">ON</span> s.singer_id <span class="hljs-operator">=</span> so.singer_id            <span class="hljs-comment">-- 连接歌曲表：匹配歌手ID，找出该歌手的所有歌曲</span><br><span class="hljs-keyword">JOIN</span> <br>    song_status ss <span class="hljs-keyword">ON</span> so.song_id <span class="hljs-operator">=</span> ss.song_id        <span class="hljs-comment">-- 连接歌曲点听信息表：匹配歌曲ID，获取每首歌的点听数</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>    s.singer_id, s.singer_name                       <span class="hljs-comment">-- 按歌手ID和姓名分组，统计每个歌手的数据</span><br><span class="hljs-keyword">HAVING</span> <br>    <span class="hljs-built_in">SUM</span>(ss.listen_count) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span>                     <span class="hljs-comment">-- 只保留点听总数大于10000的歌手（聚合结果过滤）</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>    total_listen_count <span class="hljs-keyword">DESC</span>;                         <span class="hljs-comment">-- 按点听总数从高到低排序</span><br></code></pre></td></tr></table></figure></div></details></li></ul>]]></content>
    
    
    <summary type="html">数据库进阶学习</summary>
    
    
    
    <category term="小怪兽的面试题" scheme="http://example.com/categories/%E5%B0%8F%E6%80%AA%E5%85%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MYSQL" scheme="http://example.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="http://example.com/2025/06/30/studyDiary/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2025/06/30/studyDiary/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2025-06-30T00:00:00.000Z</published>
    <updated>2025-06-30T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a>什么是垃圾回收</h1><p>垃圾回收指的是：自动清除程序中不再被使用的对象所占用的内存空间。<br>JVM 会跟踪哪些对象仍然“可达”，哪些对象已经“不可达”，并自动释放不可达对象占用的内存。</p><p>内存泄漏:不再使用的对象在系统中未被回收。内存泄漏会导致内存溢出</p><ul><li>哪些内存区域会被回收？</li></ul><div class="table-container"><table><thead><tr><th>区域</th><th>是否 GC 管理</th></tr></thead><tbody><tr><td>Java 堆（Heap）</td><td>✅ 主要回收区</td></tr><tr><td>方法区（元空间）</td><td>✅ 部分可回收（如类元信息）</td></tr><tr><td>栈、本地方法栈、程序计数器</td><td>❌ 不受 GC 管理</td></tr></tbody></table></div><h1 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h1><p>🔹二、什么情况下类信息可以被回收？<br>前提：类必须“不可达”才能被卸载。</p><p>JVM 会回收类的元信息，但 只有满足以下条件时，类才会被认为“无用”：</p><ol><li><p>该类的所有实例都被回收；</p></li><li><p>加载该类的类加载器已被回收；</p></li><li><p>该类的 java.lang.Class 对象没有被引用。</p></li></ol><p>👉 一句话：类加载器 + 类本身 + 所有实例都“不可达”，才能触发卸载和方法区回收。</p><div class="note info flat"><p>使用的情况很少</p></div><h1 id="堆的回收"><a href="#堆的回收" class="headerlink" title="堆的回收"></a>堆的回收</h1><h2 id="如何判断对象是否可以回收"><a href="#如何判断对象是否可以回收" class="headerlink" title="如何判断对象是否可以回收"></a>如何判断对象是否可以回收</h2><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul><li>基本思想：</li></ul><p>从一组被称为 GC Roots 的根对象出发，沿着对象的引用链向下搜索，凡是能从 GC Roots 直接或间接访问到的对象都是“可达”的”，它们被认为“仍然活着”；而无法访问到的对象是“不可达”的”，就会被判定为垃圾，等待回收。</p><ul><li>GC Roots（根对象）有哪些？<br>GC Roots 是 JVM 内建的一组引用链起点，它们本身不会被垃圾回收，主要包括：</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>虚拟机栈中的引用变量</strong></td><td>各个线程正在调用的方法中的局部变量表中的对象引用</td></tr><tr><td><strong>方法区中的静态变量</strong></td><td>类的静态属性所引用的对象</td></tr><tr><td><strong>方法区中的常量引用</strong></td><td>字面量引用的对象，如字符串常量池</td></tr><tr><td><strong>本地方法栈中的 JNI 引用</strong></td><td>本地代码（C/C++）引用的对象</td></tr><tr><td><strong>运行中线程对象本身</strong></td><td>正在执行的线程默认不会被回收</td></tr></tbody></table></div><ul><li><p>示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">GC Roots<br>   |<br>   v<br>[Obj1] ---&gt; [Obj2] ---&gt; [Obj3]<br>                     ↘<br>                      [Obj4]<br><br>[Obj5] ←→ [Obj6]   ←→ [Obj7]<br> ↑                     ↓<br>GC 无法访问        GC 无法访问<br></code></pre></td></tr></table></figure><ul><li>Obj1~4 是可达的对象 → 存活</li><li>Obj5~7 互相引用，但没有任何一个能被 GC Roots 访问 → 不可达 → 可回收</li></ul></li><li><p>可达性分析的执行步骤</p></li></ul><ol><li>从 GC Roots 开始，把所有可直接访问到的对象标记为“可达”；</li><li>递归遍历这些对象引用的其他对象，也标记为“可达”；</li><li>最终未被标记的对象即为“不可达”；</li><li>不可达对象会被 GC 回收，但如果有自我拯救机制（如 finalize()），可能暂时保留。</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><div class="table-container"><table><thead><tr><th>引用类型</th><th>回收条件</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>强引用（StrongReference）</strong></td><td>永远不会被回收（只要还被引用）</td><td>普通对象引用</td></tr><tr><td><strong>软引用（SoftReference）</strong></td><td>只有在<strong>内存不足时</strong>才会被回收</td><td>缓存、图片缓存</td></tr><tr><td><strong>弱引用（WeakReference）</strong></td><td><strong>下一次 GC 时就会被回收</strong>，不论内存是否充足</td><td>ThreadLocal 的 key</td></tr><tr><td><strong>虚引用（PhantomReference）</strong></td><td><strong>随时可能被回收</strong>，不能通过引用获取对象</td><td>对象销毁后通知清理操作</td></tr></tbody></table></div><ul><li>强引用（Strong Reference）：是最常见的引用类型，也是默认的引用类型。如果一个对象具有强引用，那么即使内存空间不足，垃圾回收器也不会回收它。只有当该对象的所有强引用都失效时，对象才会被回收</li><li>软引用（Soft Reference）：是一种比强引用弱一些的引用类型。如果一个对象只具有软引用，那么当内存空间不足时，垃圾回收器可能会回收它。软引用通常用于实现内存敏感的缓存<br>可以配合引用队列来释放软引用自身</li><li>弱引用（Weak Reference）：是一种比软引用更弱一些的引用类型。如果一个对象只具有弱银用，那么垃圾回收器在下一次运行时，无论内存空间是否足够，都会回收该对象。若引用通常用于实现在对象可用时进行操作的场景<br>可以配合引用队列来释放软引用自身</li><li>虚引用（Phantom Reference）：是最弱的一种引用类型。如果一个对象只具有虚引用，那么在任何时候都可能被垃圾回收器回收。虚引用通常用于追踪对象被垃圾回收的状态<br>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li><li>终结器引用（Final Reference）：是一种特殊的弱引用类型，它只在对象被回收时被添加到引用队列中。当垃圾回收器准备回收一个对象时，会先执行对象的finallize()方法，如果finalize()方法中没有重新让对象与其他对象建立联系，那么这个对象就会被回收，并且它的Final引用会被加入到引用队列中。Final引用通常用于对象回收后的清理工作</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li>常见的垃圾回收算法</li></ul><div class="table-container"><table><thead><tr><th>算法名称</th><th>简介</th><th>特点</th></tr></thead><tbody><tr><td><strong>标记-清除（Mark-Sweep）</strong></td><td>标记所有存活对象，清除未标记的</td><td>简单、会产生<strong>内存碎片</strong></td></tr><tr><td><strong>复制（Copying）</strong></td><td>将存活对象从一块内存复制到另一块</td><td>快速、<strong>无碎片</strong>、适合年轻代</td></tr><tr><td><strong>标记-整理（Mark-Compact）</strong></td><td>标记所有存活对象，并移动整理成连续空间</td><td>适合老年代、<strong>无碎片</strong>，开销大</td></tr><tr><td><strong>分代收集（Generational GC）</strong></td><td>按对象生命周期分代，采用不同算法收集</td><td>实际应用最多，JVM 默认策略</td></tr></tbody></table></div><h3 id="标记清楚算法"><a href="#标记清楚算法" class="headerlink" title="标记清楚算法"></a>标记清楚算法</h3><p>标记清除算法的优点在于它简单易用，可以快速地回收大量的垃圾对象。但是，它也存在一些缺点，例如在清除和压缩阶段中可能会产生较大的内存碎片，从而影响后续的内存分配效率。此外，标记清除算法无法处理循环引用的情况，需要借助其他算法来处理循环引用问题，例如标记-压缩算法和复制算法等。<br>过程:</p><ul><li>标记阶段：从 GC Roots 出发，标记所有可达对象</li><li>清除阶段：清除未被标记的对象<br><img src="https://pic1.imgdb.cn/item/6863990c58cb8da5c8832464.png" alt=""></li></ul><p>缺点：</p><ul><li>会产生 大量内存碎片</li><li>分配新对象可能需要整理或空闲链查找</li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法是一种基于内存分区的垃圾回收算法，它将内存分成两个区域：From空间和To空间。在正常情况下，所有的对象都被分配在From空间中。当需要进行垃圾回收时，算法会扫描From空间中的所有对象，并将存活的对象复制到To空间中。复制完成后，From空间中的对象都可以被视为垃圾，并可以被回收。</p><ol><li>接下来，详细介绍一下复制算法的工作原理：</li></ol><ul><li>内存分配：在程序运行过程中，对象的内存分配只在From空间中进行。当From空间快要用完时，算法会触发一次垃圾回收操作。</li><li>扫描存活对象：在进行垃圾回收时，算法会遍历From空间中的所有对象，并标记存活的对象。为了标记存活对象，复制算法使用了一种叫做可达性分析的技术，这个技术可以判断一个对象是否是存活对象。与标记清除算法和标记整理算法不同的是，复制算法并不需要进行标记和清除的分离过程，因为复制算法是将存活对象复制到To空间中，所以只要扫描完From空间中的所有对象，并将存活对象复制到To空间中，就可以直接清除From空间了。</li><li>复制存活对象：在扫描存活对象之后，算法会将所有存活对象从From空间复制到To空间。复制的过程是按照对象的存活顺序进行的，也就是说，如果对象A引用了对象B，那么对象B会被先复制到To空间中。复制完成后，To空间的使用量会变得很满，From空间的使用量则变得很少。</li><li>交换空间：在复制完所有存活对象之后，From空间中剩余的对象都可以视为垃圾，并可以被回收。为了保证下一次的内存分配，To空间和From空间会进行交换，也就是说，To空间成为了新的From空间，From空间成为了新的To空间。这样一来，内存分配就可以在新的From空间中进行了。<br><img src="https://pic1.imgdb.cn/item/68639a4c58cb8da5c883329e.jpg" alt=""><br><img src="https://pic1.imgdb.cn/item/68639a6b58cb8da5c8833422.jpg" alt=""></li></ul><p>优点：</p><ul><li><p>快速、高效</p></li><li><p>回收过程简单：只复制存活对象，然后清空原区域 → 无碎片</p></li></ul><p>缺点：</p><ul><li><p>空间浪费大（总有一块 Survivor 区是空的）</p></li><li><p>复制成本高（如果存活对象多）</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记-整理算法的流程分为两步：</p></li><li>标记（Mark）阶段：从 GC Roots 出发，标记所有“存活对象”；</li><li>整理（Compact）阶段：将所有存活对象移动到一端，并按顺序排列，清理无用对象所占内存。<br><img src="https://pic1.imgdb.cn/item/68639adc58cb8da5c883394f.jpg" alt=""><br><img src="https://pic1.imgdb.cn/item/68639b4a58cb8da5c8833d9a.png" alt=""></li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>JVM（Java虚拟机）的分代垃圾回收是一种优化内存回收的技术。它利用对象的生命周期来将堆（heap）分为不同的区域，然后针对不同区域的特点采用不同的垃圾回收算法。<br><img src="https://pic1.imgdb.cn/item/68639f3b58cb8da5c8835f5f.png" alt=""></p><ul><li>各代说明</li></ul><ol><li>年轻代（Young Generation）<ul><li>所有新创建的对象都首先进入 Eden 区。</li><li>当 Eden 区满了，会触发 Minor GC。</li><li>存活对象进入 Survivor 区（两个区轮流使用）。</li><li>若对象多次经历 Minor GC 仍未被回收，会被提升（晋升）到老年代。<br>回收策略：复制算法（Copying）</li></ul></li><li>老年代（Old Generation）<ul><li>存放生命周期较长或大的对象。</li><li>空间较大，但回收频率低。</li><li>当空间不足时触发 Major GC 或 Full GC，回收代价高，停顿时间长。</li><li>回收策略：标记-整理或 G1 的分区整理</li></ul></li><li>工作原理<ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄+1并且交换from和to minor gc会引发stop the world（砸瓦鲁多！！），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15<ul><li>Java中的对象头中确实分配了一定的字节用来记录对象的年龄，而这个字节的位数是4，因此其二进制最大值为1111，即十进制的15</li></ul></li><li>当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么触发full gc，STW的时间更长</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是垃圾回收&quot;&gt;&lt;a href=&quot;#什么是垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;什么是垃圾回收&quot;&gt;&lt;/a&gt;什么是垃圾回收&lt;/h1&gt;&lt;p&gt;垃圾回收指的是：自动清除程序中不再被使用的对象所占用的内存空间。&lt;br&gt;JVM 会跟踪哪些对象仍然“</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://example.com/2025/06/27/studyDiary/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2025/06/27/studyDiary/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2025-06-27T00:00:00.000Z</published>
    <updated>2025-06-27T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM的组成的运行时数据区"><a href="#JVM的组成的运行时数据区" class="headerlink" title="JVM的组成的运行时数据区"></a>JVM的组成的运行时数据区</h1><p>JVM 由三大部分组成:</p><pre><code>- 类加载器- 运行时数据区- 执行引擎</code></pre><p><img src="https://pic1.imgdb.cn/item/685e47d158cb8da5c8762114.png" alt=""></p><p>运行数据区也分五个小区域，两大类</p><div class="table-container"><table><thead><tr><th>区域名称</th><th>线程共享</th><th>线程私有</th><th>用途说明</th></tr></thead><tbody><tr><td>程序计数器</td><td></td><td>✅</td><td>当前执行指令位置</td></tr><tr><td>Java 虚拟机栈</td><td></td><td>✅</td><td>方法调用过程中的数据存储</td></tr><tr><td>本地方法栈</td><td></td><td>✅</td><td>本地方法调用</td></tr><tr><td>堆（Heap）</td><td>✅</td><td></td><td>所有对象存储</td></tr><tr><td>方法区/元空间</td><td>✅</td><td></td><td>类信息、常量、静态变量</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>内存区域</th><th>存储内容</th><th>生命周期</th></tr></thead><tbody><tr><td>堆（Heap）</td><td>所有对象实例、数组</td><td>和JVM同生共死</td></tr><tr><td>栈（Stack）</td><td>每个线程的方法调用栈帧</td><td>随线程创建与销毁</td></tr><tr><td>方法区</td><td>类的结构、常量池、静态变量等</td><td>和JVM同生共死</td></tr><tr><td>本地方法栈</td><td>Native方法调用信息</td><td>随线程创建与销毁</td></tr><tr><td>程序计数器</td><td>当前线程执行字节码的行号指示器</td><td>随线程创建与销毁</td></tr></tbody></table></div><h1 id="程序技术器"><a href="#程序技术器" class="headerlink" title="程序技术器"></a>程序技术器</h1><p>程序计数器是 JVM 中的一块非常小的内存空间，用于记录当前线程所执行字节码的行号地址。</p><pre><code>- 因为在Java虚拟机的多线程环境下，为了支持线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，否则就会出现线程切换后执行位置混乱的问题。</code></pre><ul><li>JAVA源代码会先编译成字节码指令，并由类加载器加载到方法区，程序计数器的作用就是记录下一步应该执行的字节码指令的地址<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"> <span class="hljs-number">0</span> iconst_0<br> <span class="hljs-number">1</span> istore_1<br> <span class="hljs-number">2</span> iload_1<br> <span class="hljs-number">3</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><br> <span class="hljs-number">6</span> istore_1<br> <span class="hljs-number">7</span> getstatic #<span class="hljs-number">7</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">10</span> iload_1<br><span class="hljs-number">11</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/io/PrintStream.println : (I)V&gt;<br><span class="hljs-number">14</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>程序计数器</li><li>作用：保存当前线程下一条要执行的指令的地址</li><li>特点：<ul><li>线程私有</li><li>不存在内存溢出</li></ul></li></ul><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>Java虚拟机栈（Java Virtual Machine Stacks）是Java虚拟机为每个线程分配的一块内存区域，用于存储线程的方法调用和局部变量等信息。</li><li>每个线程在运行时都有自己的Java虚拟机栈，线程开始时会创建一个新的栈帧（Stack Frame），用于存储该线程的方法调用信息。当方法调用完成后，该栈帧会被弹出，回到上一次方法调用的位置。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><p>虚拟机栈（一个线程）<br>┌────────────┐ ← 栈顶<br>│ 方法C栈帧     │ ← 当前正在执行的方法<br>├────────────┤<br>│ 方法B栈帧     │<br>├────────────┤<br>│ 方法A栈帧     │ ← 最先被调用的方法（main）<br>└────────────┘ ← 栈底</p><div class="note primary flat"><p>当我们看到程序报错出现异常的时候，就会从上到下依次弹出虚拟机栈，所以第一个弹出的就是关键的报错异常</p></div><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>一个栈帧保存一个方法执行过程中的所有信息，包括:</p><div class="table-container"><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><strong>局部变量表</strong></td><td>存储方法的参数和局部变量（int、long、Object 引用等）</td></tr><tr><td><strong>操作数栈</strong></td><td>执行字节码指令时用来做计算和临时数据存储</td></tr><tr><td><strong>动态链接</strong></td><td>方法中调用其他方法时的符号引用信息（类似“函数指针”）</td></tr><tr><td><strong>返回地址</strong></td><td>方法返回时跳转的字节码地址</td></tr><tr><td><strong>附加信息</strong></td><td>如异常处理表等，供调试/异常处理用</td></tr></tbody></table></div><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><h3 id="栈帧太多导致栈内存溢出"><a href="#栈帧太多导致栈内存溢出" class="headerlink" title="栈帧太多导致栈内存溢出"></a>栈帧太多导致栈内存溢出</h3><p>无限递归或者递归太深会导致栈帧过多会导致栈内存溢出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            method();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(count);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>        method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><div class="note info flat"><p>递归最终停在23678次出现了栈内存溢出的异常</p></div></p><ul><li>设置栈内存大小<br><img src="https://pic1.imgdb.cn/item/685f8e0858cb8da5c87a41ff.png" alt=""></li></ul><h3 id="单个栈帧过大"><a href="#单个栈帧过大" class="headerlink" title="单个栈帧过大"></a>单个栈帧过大</h3><p>这个情况出现在 一个类A中引用了B类，B类中又引用了A类的时候，也就是循环引用的时候才会出现</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法是指由非Java语言编写的代码，如C或C++，并被编译为本地二进制代码。<br>因为JAVA没法直接和操作系统底层交互，所以需要用到本地方法栈来调用本地的C或C++的方法<br>例如Object类的源码中就有本地方法，用native关键字修饰本地方法<br>本地方法只有函数声明，没有函数体，因为函数体是C或C++写的，通常是通过JNI（Java Native Interface）技术来实现的。</p><div class="table-container"><table><thead><tr><th>项目</th><th>虚拟机栈（JVM Stack）</th><th>本地方法栈（Native Method Stack）</th></tr></thead><tbody><tr><td>作用</td><td>管理 Java 方法的调用和执行</td><td>管理 Native 方法的调用</td></tr><tr><td>内容</td><td>栈帧（方法局部变量、操作数栈等）</td><td>本地方法所需的结构、变量</td></tr><tr><td>是否必须存在</td><td>是</td><td>不是所有 JVM 实现都支持（HotSpot 把它与 JVM Stack 合并）</td></tr><tr><td>触发异常</td><td><code>StackOverflowError</code>、<code>OutOfMemoryError</code></td><td>同上，如果单独存在</td></tr></tbody></table></div><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>✅ 定义：<br>JVM 堆是所有线程共享的一块内存区域，用于存放对象实例、数组等，只要用 new 创建的对象，基本都在堆中分配内存。<br><img src="https://pic1.imgdb.cn/item/685f93d958cb8da5c87a5b4e.png" alt=""></p><p>Heap堆</p><ul><li>通过new关键字创建的对象都会使用堆空间</li><li>特点:<ul><li>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li></ul><h2 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h2><p>可以通过 JVM 启动参数设置堆的初始大小和最大大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">java -Xms512m -Xmx1024m MyApp<br></code></pre></td></tr></table></figure><br>-Xms: 初始堆大小<br>-Xmx: 最大堆大小<br>注意：堆太小，容易频繁 GC；堆太大，Full GC 时间可能过长</p><h2 id="堆溢出（OutOfMemoryError）"><a href="#堆溢出（OutOfMemoryError）" class="headerlink" title="堆溢出（OutOfMemoryError）"></a>堆溢出（OutOfMemoryError）</h2><p>当堆内存不够用时，会出现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br></code></pre></td></tr></table></figure><br>常见原因：</p><ul><li>创建过多对象且未释放；</li><li>内存泄漏（引用未置 null 导致 GC 无法回收）；</li><li>数据结构过大（如 List 无限添加元素）；</li></ul><div class="note info flat"><p>arthas 工具可查看堆内存使用情况</p></div><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>✅定义:<br>在Java虚拟机（JVM）中，方法区（Method Area）是内存的一部分，属于JVM运行时数据区的一种。它用于存储类的结构信息，而不是对象的实例数据。方法区在JVM中有时也被称为永久代（PermGen）（在JDK 7及以前版本中），在JDK 8中被称为元空间（Metaspace）。</p><p>✅方法区主要存储以下内容：</p><ol><li>类的结构信息（Class信息）：</li></ol><ul><li>类的完全限定名（类名 + 包名）</li><li>类的访问修饰符（public、abstract等）</li><li>父类名称</li><li>实现的接口</li><li>字段信息（字段名、类型、修饰符）</li><li>方法信息（方法名、参数、返回值、修饰符）</li></ul><ol><li>运行时常量池（Runtime Constant Pool）：</li></ol><ul><li>字符串字面量（如 “Hello”）</li><li>数字常量、方法引用、字段引用等</li></ul><ol><li>静态变量</li></ol><ul><li>类的构造方法和普通方法的字节码</li></ul><div class="note info flat"><p>JVM会通过类加载器将类的信息加载到方法区，在类的加载期完成</p></div><p>PermGen与Metaspace的区别</p><div class="table-container"><table><thead><tr><th>特性</th><th>PermGen（JDK 7及以前）</th><th>Metaspace（JDK 8及以后）</th></tr></thead><tbody><tr><td>所在内存</td><td>JVM内存</td><td>本地内存（Native memory）</td></tr><tr><td>是否容易内存溢出</td><td>是（PermGen space OOM）</td><td>较少（可通过参数控制增长）</td></tr><tr><td>可调参数</td><td><code>-XX:PermSize</code>，<code>-XX:MaxPermSize</code></td><td><code>-XX:MetaspaceSize</code>，<code>-XX:MaxMetaspaceSize</code></td></tr></tbody></table></div><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><p>StringTable 是一个专门存放 String.intern() 方法返回的字符串对象 的哈希表。</p><ul><li><p>来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo_08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3 == s4);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;<br>        System.out.println(s3 == s5);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译结果如下，可以看到s5对象的创建，就是去常量池中直接获取ab，而不会创建新的字符串对象，故s3 == s5的结果是true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>  descriptor: ([Ljava/lang/String;)V<br>  flags: ACC_PUBLIC, ACC_STATIC<br>  Code:<br>    stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><br>       <span class="hljs-number">5</span>: astore_2<br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>       <span class="hljs-number">8</span>: astore_3<br>       <span class="hljs-number">9</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>      <span class="hljs-number">12</span>: dup<br>      <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>      <span class="hljs-number">16</span>: aload_1<br>      <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>      <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span><br>      <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><br>      <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用intern方法，主动将串池中还没有的字符串对象放入串池</p><ul><li>1.8中，将这个字符串对象尝试放入串池<ul><li>如果串池中已有，则不会放入</li><li>如果串池中没有，则放入串池，并将串池中的结果返回<br>下面是示例代码讲解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo_10</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;            <span class="hljs-comment">// 常量池：[&quot;a&quot;]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;            <span class="hljs-comment">// 常量池：[&quot;a&quot;, &quot;b&quot;]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;      <span class="hljs-comment">// 常量池：[&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;        <span class="hljs-comment">// 堆：new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;           <span class="hljs-comment">// s5引用常量池中已有的对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s4.intern();    <span class="hljs-comment">// 常量池中已有&quot;ab&quot;，将常量池中的&quot;ab&quot;的引用返回，s6引用常量池中已有的对象</span><br><br>        System.out.println(s3 == s4);   <span class="hljs-comment">// s3在常量池，s4在堆，false</span><br>        System.out.println(s3 == s5);   <span class="hljs-comment">// s3在常量池，s5在常量池，true</span><br>        System.out.println(s3 == s6);   <span class="hljs-comment">// s3在常量池，s6在常量池，true</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cd&quot;</span>;     <span class="hljs-comment">// 常量池：[&quot;cd&quot;]</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;c&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);    <span class="hljs-comment">// 堆：new String(&quot;cd&quot;)</span><br>        str2.intern();  <span class="hljs-comment">// 常量池中已有&quot;cd&quot;，放入失败</span><br>        System.out.println(str1 == str2);   <span class="hljs-comment">// str1在常量池，str2在堆，false</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;e&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;f&quot;</span>);    <span class="hljs-comment">// 堆：new String(&quot;ef&quot;)</span><br>        str4.intern();          <span class="hljs-comment">// 常量池中没有&quot;ef&quot;，放入成功，并返回常量池&quot;ef&quot;的引用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ef&quot;</span>;     <span class="hljs-comment">// 常量池：[&quot;ef&quot;]</span><br>        System.out.println(str3 == str4);   <span class="hljs-comment">// str4是常量池的引用，str3也是常量池的引用，true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM的组成的运行时数据区&quot;&gt;&lt;a href=&quot;#JVM的组成的运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;JVM的组成的运行时数据区&quot;&gt;&lt;/a&gt;JVM的组成的运行时数据区&lt;/h1&gt;&lt;p&gt;JVM 由三大部分组成:&lt;/p&gt;
&lt;pre&gt;&lt;cod</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM字节码和类加载</title>
    <link href="http://example.com/2025/06/23/studyDiary/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2025/06/23/studyDiary/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/</id>
    <published>2025-06-23T00:00:00.000Z</published>
    <updated>2025-06-23T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节码的组成"><a href="#字节码的组成" class="headerlink" title="字节码的组成"></a>字节码的组成</h1><p>+——————————+<br>| 魔数（Magic Number）     |<br>+——————————+<br>| 版本信息（Version）      |<br>+——————————+<br>| 常量池（Constant Pool）  |<br>+——————————+<br>| 访问标志（Access Flags）|<br>+——————————+<br>| 类信息（This/ Super）   |<br>+——————————+<br>| 接口（Interfaces）       |<br>+——————————+<br>| 字段（Fields）         |<br>+——————————+<br>| 方法（Methods）        |<br>+——————————+<br>| 属性（Attributes）     |<br>+——————————+</p><ol><li>一个简单的HelloWorld程序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>打开class文件<br><img src="https://pic1.imgdb.cn/item/685a6a7958cb8da5c86b69dd.png" alt=""></li></ol><ul><li>0-3字节(ca fe ba be)，表示它是否是class类型的文件<div class="note info flat"><p>在Java中，所有的.class文件都以魔数ca fe ba be开头，这个魔数的前4个字节用于识别该文件是否为Java类文件，如果这个魔数不匹配，那么Java虚拟机将无法加载该文件。</p></div></li></ul><ol><li>类文件结构<br><img src="https://pic1.imgdb.cn/item/685a685558cb8da5c86b5d22.png" alt=""></li></ol><ul><li>主版本号-44 = JDK版本</li></ul><h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><ul><li>常量池的组成<br>当你编写 Java 代码后，编译器会将常量（如字面量、类名、字段名、方法签名等）存入 .class 文件中的常量池表（Constant Pool Table）。</li></ul><div class="table-container"><table><thead><tr><th>Tag</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CONSTANT_Utf8</td><td>UTF-8编码的字符串</td></tr><tr><td>3</td><td>CONSTANT_Integer</td><td>整型常量</td></tr><tr><td>4</td><td>CONSTANT_Float</td><td>浮点型常量</td></tr><tr><td>5</td><td>CONSTANT_Long</td><td>长整型常量（占两个槽）</td></tr><tr><td>6</td><td>CONSTANT_Double</td><td>双精度浮点常量（占两个槽）</td></tr><tr><td>7</td><td>CONSTANT_Class</td><td>类或接口的符号引用</td></tr><tr><td>8</td><td>CONSTANT_String</td><td>字符串字面量的引用</td></tr><tr><td>9</td><td>CONSTANT_Fieldref</td><td>字段的符号引用</td></tr><tr><td>10</td><td>CONSTANT_Methodref</td><td>方法的符号引用</td></tr><tr><td>11</td><td>CONSTANT_InterfaceMethodref</td><td>接口方法的引用</td></tr><tr><td>12</td><td>CONSTANT_NameAndType</td><td>字段或方法的名称与描述符</td></tr><tr><td>15</td><td>CONSTANT_MethodHandle</td><td>方法句柄</td></tr><tr><td>16</td><td>CONSTANT_MethodType</td><td>方法类型</td></tr><tr><td>18</td><td>CONSTANT_InvokeDynamic</td><td>动态调用信息</td></tr></tbody></table></div><ul><li>常量池的特点<ul><li>字符串常量池是运行时常量池的一部分，存储字符串字面量，并支持字符串常量共享。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(s1 == s2); <span class="hljs-comment">// true，因为指向相同的字符串常量池对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note primary flat"><p>s1和s2会指向同一地址</p></div></li></ul></li></ul><h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><ul><li>解析 i=i++<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        i=i++;<br>        System.out.println(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>这是一个简单的i=i++,我们来看这个程序的字节码指令<br><img src="https://pic1.imgdb.cn/item/685b9fcd58cb8da5c86faedb.png" alt=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"> <span class="hljs-number">0</span> iconst_0<br> <span class="hljs-number">1</span> istore_1<br> <span class="hljs-number">2</span> iload_1<br> <span class="hljs-number">3</span> iinc <span class="hljs-number">1</span> by <span class="hljs-number">1</span><br> <span class="hljs-number">6</span> istore_1<br> <span class="hljs-number">7</span> getstatic #<span class="hljs-number">7</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">10</span> iload_1<br><span class="hljs-number">11</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/io/PrintStream.println : (I)V&gt;<br><span class="hljs-number">14</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>当这个程序开始运行后:<ol><li>在栈中开辟内存<br>会开启两个空间，数组[0] 是 main函数的参数 args<br><img src="https://pic1.imgdb.cn/item/685ba5ff58cb8da5c86fbf91.jpg" alt=""></li><li>iconst_0<br>将0放入操作数栈中</li><li>istore_1<br>将操作数栈中的值放入数组[1]中</li><li>iload_1<br>数组[1]中的值放入操作数栈中</li><li>iinc 1 by 1<br>将 数组[1]中的值 加 1</li><li>istore_1<br>将操作数栈中的值放入数组[1]中</li><li>getstatic #7<br>从类 System 中获取静态字段 out</li><li>iload_1<br>数组[1]中的值放入操作数栈中</li><li>invokevirtual #13<br>调用对象的实例方法。</li></ol></li></ul><ol><li>return<br>方法结束</li></ol><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>加载<br> │<br> ▼<br>连接（验证 → 准备 → 解析）<br> │<br> ▼<br>初始化（执行 <clinit>）<br> │<br> ▼<br>使用<br> │<br> ▼<br>卸载（由 GC 回收 Class 对象）</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul><li>JVM 通过类的全限定名查找 .class 文件 ，由类加载器将字节码读入内存(即方法区)，创建 Class 对象</li><li>在堆中创建一个 java.lang.Class 对象用于封装方法区中的类信息，程序中我们使用 MyClass.class 或 Class.forName() 得到的就是这个对象</li></ul><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接是 JVM 将类的二进制表示转换为可以被虚拟机使用的状态的过程，包括验证、准备和解析三个子阶段。</p><h3 id="🧪-验证"><a href="#🧪-验证" class="headerlink" title="🧪 验证"></a>🧪 验证</h3><p>✅ 目的：<br>确保字节码文件的合法性、安全性、符合 JVM 规范，避免崩溃或恶意代码入侵。</p><p>🔍 主要验证内容：<br>文件格式验证：字节码文件的魔数、版本号等是否合法。<br>元数据验证：类的父类是否存在，字段类型是否正确。<br>字节码验证：方法中指令是否合法，操作数栈使用是否正确。<br>符号引用验证：常量池中的类名、字段、方法是否合法。</p><h3 id="🧱-准备"><a href="#🧱-准备" class="headerlink" title="🧱 准备"></a>🧱 准备</h3><p>✅ 目的：<br>为类中的 静态变量（static 字段）分配内存，并赋予默认值。<br>🔍 特点：<br>赋默认值，不是编写代码中设置的值(final除外)。<br>🌰 示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>准备阶段时：<br>a = 0（默认值）<br>b 会直接在编译期被放入常量池（JVM 优化，可能不参与连接）</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>0</code></td></tr><tr><td><code>short</code></td><td><code>0</code></td></tr><tr><td><code>int</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td><code>0L</code></td></tr><tr><td><code>float</code></td><td><code>0.0f</code></td></tr><tr><td><code>double</code></td><td><code>0.0d</code></td></tr><tr><td><code>char</code></td><td><code>\u0000</code>（空字符）</td></tr><tr><td><code>boolean</code></td><td><code>false</code></td></tr><tr><td>引用类型（如 String）</td><td><code>null</code></td></tr></tbody></table></div><h3 id="🧩-解析"><a href="#🧩-解析" class="headerlink" title="🧩 解析"></a>🧩 解析</h3><p>✅ 目的：<br>将常量池中的符号引用（如类名、字段名、方法名）转为 直接引用（指向内存地址的指针、偏移量等）。</p><div class="table-container"><table><thead><tr><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>符号引用</td><td>“java/lang/String”</td></tr><tr><td>直接引用</td><td>指向 <code>String.class</code> 的地址</td></tr></tbody></table></div><h3 id="✅-初始化"><a href="#✅-初始化" class="headerlink" title="✅  初始化"></a>✅  初始化</h3><p>✅ 目的：<br>初始化阶段指执行类的初始化方法 <clinit>，完成静态变量的显式赋值和静态代码块的执行，确保类处于可用状态。</p><ul><li>初始化顺序示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块执行&quot;</span>);<br>        a = <span class="hljs-number">20</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>初始化过程：</li></ul><ol><li><p>准备阶段时，a 被赋默认值 0。</p></li><li><p>初始化阶段执行 <clinit>：</p><ul><li><p>a = 10;</p></li><li><p>执行静态代码块，a = 20;，同时打印输出。</p></li></ul></li><li><p>main 方法输出：a = 20</p></li></ol><p>📋 何时触发初始化:<br>首次主动使用类时触发，如：</p><pre><code>- 创建类实例（new）- 访问类的静态字段（非 final 常量）- 调用静态方法- 使用反射 Class.forName()- 初始化子类时，先初始化父类</code></pre><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="常见的类加载器"><a href="#常见的类加载器" class="headerlink" title="常见的类加载器:"></a>常见的类加载器:</h3><div class="table-container"><table><thead><tr><th>类加载器</th><th>简称</th><th>是否 Java 实现</th><th>加载内容</th><th>类加载路径</th></tr></thead><tbody><tr><td>启动类加载器</td><td><strong>Bootstrap</strong></td><td>❌（C/C++ 实现）</td><td>JDK 核心类库，如 <code>java.lang.*</code>、<code>java.util.*</code></td><td><code>$JAVA_HOME/lib/rt.jar</code>（JDK8及以下）</td></tr><tr><td>扩展类加载器</td><td><strong>Extension</strong></td><td>✅</td><td>JDK 扩展类库</td><td><code>$JAVA_HOME/lib/ext/</code> 或 <code>-Djava.ext.dirs</code></td></tr><tr><td>应用类加载器</td><td><strong>AppClassLoader</strong></td><td>✅</td><td>应用程序类（用户编写的类）</td><td><code>classpath</code> 环境变量指定的路径</td></tr><tr><td>自定义类加载器</td><td><strong>Custom</strong></td><td>✅</td><td>根据用户定义的逻辑加载类</td><td>自定义路径、加密文件、网络等</td></tr></tbody></table></div><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制的核心是解决一个类应该由哪个类加载器去加载</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>双亲委派机制的执行流程如下：</p><ol><li>当某个类加载器收到类加载请求时，它不会立刻去尝试加载这个类；</li><li>它会先将这个请求委托给父加载器去加载；</li><li>如果父加载器还有父加载器，则继续向上委托，直到顶层的启动类加载器（Bootstrap ClassLoader）；</li><li>如果父加载器能找到这个类，就直接返回类的Class对象；</li><li>如果父加载器找不到，才由当前类加载器尝试自己去加载这个类。<h3 id="类加载器的层次结构"><a href="#类加载器的层次结构" class="headerlink" title="类加载器的层次结构"></a>类加载器的层次结构</h3></li></ol><p>Bootstrap ClassLoader（启动类加载器）<br>   ↑<br>ExtClassLoader（扩展类加载器）<br>   ↑<br>AppClassLoader（应用程序类加载器）<br>   ↑<br>自定义ClassLoader</p><h3 id="为什么使用双亲委派机制"><a href="#为什么使用双亲委派机制" class="headerlink" title="为什么使用双亲委派机制"></a>为什么使用双亲委派机制</h3><p>安全性：防止核心 Java 类被恶意覆盖或篡改。例如自定义一个 java.lang.String 类。<br>避免重复加载：保证同一个类只会被一个类加载器加载一次，确保类的唯一性。<br>模块化和可扩展性：通过自定义类加载器，实现模块隔离（例如 OSGi、Tomcat 的 WebAppClassLoader）。</p><h3 id="打破双亲委派的情况"><a href="#打破双亲委派的情况" class="headerlink" title="打破双亲委派的情况"></a>打破双亲委派的情况</h3><p>有些场景中需要打破双亲委派，例如：<br>热部署（如 Tomcat 加载 Web 应用）；<br>插件化开发（如 IDEA 插件机制）；<br>某些框架需要优先加载自己的类版本（比如 Spring Boot 的 LaunchedURLClassLoader）。</p><p>方法:<br>自定义类加载器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节码的组成&quot;&gt;&lt;a href=&quot;#字节码的组成&quot; class=&quot;headerlink&quot; title=&quot;字节码的组成&quot;&gt;&lt;/a&gt;字节码的组成&lt;/h1&gt;&lt;p&gt;+——————————+&lt;br&gt;| 魔数（Magic Number）     |&lt;br&gt;+—————————</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM导学</title>
    <link href="http://example.com/2025/06/23/studyDiary/JVM%E5%AF%BC%E5%AD%A6/"/>
    <id>http://example.com/2025/06/23/studyDiary/JVM%E5%AF%BC%E5%AD%A6/</id>
    <published>2025-06-23T00:00:00.000Z</published>
    <updated>2025-06-23T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h1><ul><li>定义:<br>JVM（Java Virtual Machine，Java 虚拟机）是一个可以运行 Java 字节码程序的虚拟计算机，它是 Java 技术的核心组件之一。<br>简单来说：<br>JVM 是一种 运行 Java 程序的虚拟环境，它把 Java 编译后的 .class 字节码文件转换成机器可以理解的指令，并在不同的操作系统上执行，使得 Java 实现了“一次编写，到处运行”（Write Once, Run Anywhere）的理念。</li><li>主要作用:</li></ul><ol><li>执行 Java 字节码：Java 源代码被编译为字节码（.class 文件），由 JVM 来加载和执行。</li><li>内存管理：包括堆内存、栈内存、方法区等，是 JVM 自动垃圾回收（GC）机制的基础。</li><li>跨平台支持：JVM 为 Java 提供平台无关性，字节码在任意支持 JVM 的系统上都能运行。</li><li>安全性与隔离性：JVM 能隔离不同的应用程序并进行权限控制，防止恶意代码破坏系统。</li><li>性能优化：如 JIT（即时编译器），能在运行时将热点代码编译为本地机器码，提高执行效率。</li></ol><ul><li>比较JVM、JRE、JDK</li></ul><div class="table-container"><table><thead><tr><th>名称</th><th>全称</th><th>简要定义</th></tr></thead><tbody><tr><td><strong>JVM</strong></td><td>Java Virtual Machine</td><td>Java 虚拟机，用于执行字节码（.class 文件）</td></tr><tr><td><strong>JRE</strong></td><td>Java Runtime Environment</td><td>Java 运行环境，包含 JVM 和 Java 的核心类库</td></tr><tr><td><strong>JDK</strong></td><td>Java Development Kit</td><td>Java 开发工具包，包含 JRE 以及编译器等开发工具</td></tr></tbody></table></div><p><img src="https://pic1.imgdb.cn/item/685a57d558cb8da5c86b0d06.png" alt=""></p><h1 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h1><p><img src="https://pic1.imgdb.cn/item/685a58e858cb8da5c86b0db5.jpg" alt=""></p><h1 id="JVM主要组成"><a href="#JVM主要组成" class="headerlink" title="JVM主要组成"></a>JVM主要组成</h1><ul><li>类加载器</li><li>运行时数据区域</li></ul><div class="table-container"><table><thead><tr><th>区域名称</th><th>是否线程私有</th><th>主要作用</th></tr></thead><tbody><tr><td><strong>程序计数器</strong></td><td>是</td><td>记录当前线程执行的字节码行号（指令地址）</td></tr><tr><td><strong>虚拟机栈</strong></td><td>是</td><td>管理方法调用、局部变量、操作数栈、返回地址等</td></tr><tr><td><strong>本地方法栈</strong></td><td>是</td><td>为本地方法（如 JNI）服务</td></tr><tr><td><strong>堆（Heap）</strong></td><td>否</td><td>存放所有对象实例，垃圾收集的主要区域</td></tr><tr><td><strong>方法区（Metaspace）</strong></td><td>否</td><td>存放类信息、常量池、静态变量、JIT 编译代码等</td></tr><tr><td><strong>运行时常量池</strong></td><td>否</td><td>方法区中的一部分，用于存储编译期产生的常量和符号引用</td></tr></tbody></table></div><ul><li>执行引擎<br><img src="https://pic1.imgdb.cn/item/685a595358cb8da5c86b0e9f.jpg" alt=""></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是JVM&quot;&gt;&lt;a href=&quot;#什么是JVM&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM&quot;&gt;&lt;/a&gt;什么是JVM&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;定义:&lt;br&gt;JVM（Java Virtual Machine，Java 虚拟机）是一个可以运行</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JUC编程</title>
    <link href="http://example.com/2025/06/03/studyDiary/JUC/"/>
    <id>http://example.com/2025/06/03/studyDiary/JUC/</id>
    <published>2025-06-03T00:00:00.000Z</published>
    <updated>2025-06-03T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>原子性的定义：原子性是指一个操作(多条指令)是不可分割的。 在一个线程在执行某一段指令时，其他的线程如果也想执行，需要等待前一个线程执行完毕后才能执行。<br><div class="note primary flat"><p>例如 i++，在代码中只有一行代码，看着是只有一个操作，但是对有CPU来说这是三个操作，1. 将i取出放入cpu，2.对i进行加1操作 3.将结果返回</p></div><br>原子性可以解决线程安全问题。在多个线程在同时对一个共享资源（共享变量）进行操作时，出现的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">// 如果方法不追加synchronized，会导致200次++操作结束后，结果不是200</span><br>    <span class="hljs-comment">// 如果方法追加上了synchronized，200次++的操作结束后，结果就是预期的200了。</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                increment();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                increment();<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">//等待线程结束</span><br>        t1.join();<br>        t2.join();<br>        System.out.println(count);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在多线程环境下，每个线程可能会将变量缓存到自己的工作内存（即 CPU 缓存）中，而不是直接从主内存读取和写入。</p><div class="note primary flat"><p>线程 A 修改了变量 x，但线程 B 仍然看到旧值，因为它从自己的工作内存中读到了旧的副本，而不是主内存中的最新值。</p></div><p>实现可见性的三种方式：<br>1.volatile关键字<br>volatile关键字是专门用来实现可见性的，不加volatile则永远不会输出 t1线程结束！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束！&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">100</span>);<br>    flag = <span class="hljs-literal">false</span>;<br>    System.out.println(<span class="hljs-string">&quot;main线程将flag改为false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><ol><li>synchronized 重量级锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>    <span class="hljs-comment">// 这里的println操作中，涉及到了synchronized操作，间接实现了可见性</span><br>            System.out.println(<span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束！&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">100</span>);<br>    flag = <span class="hljs-literal">false</span>;<br>    System.out.println(<span class="hljs-string">&quot;main线程将flag改为false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>lock (lock的底层是volatile)</li></ol><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性是为了防止多线程中的指令重排序造成的不一样的结果</p><h3 id="什么是指令重排序"><a href="#什么是指令重排序" class="headerlink" title="什么是指令重排序"></a>什么是指令重排序</h3><ol><li>指令重排序是指编译器或处理器为了提升性能，在不改变单线程语义的前提下，重新调整指令的执行顺序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>x = a + b;<br></code></pre></td></tr></table></figure><p>即使你写的顺序是 a→b→x，编译器或 CPU 可能会先执行 b = 2，然后再执行 a = 1，只要单线程运行的结果是正确的，这种调整就是允许的。</p><ol><li>指令重排序的三种类型：</li></ol><div class="table-container"><table><thead><tr><th></th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>编译器重排序</td><td>编译器在生成字节码时进行的重排序</td></tr><tr><td>JVM 重排序</td><td>JVM 将字节码翻译为机器码时进行的重排序</td></tr><tr><td>CPU 重排序</td><td>CPU 在执行时进行的乱序执行和写缓冲等优化</td></tr></tbody></table></div><ol><li>指令重排序的危害<br>在单线程中，重排序是无害的。但在多线程环境下，如果没有适当的同步机制，指令重排序会导致难以察觉的并发错误。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//双重检查锁（DCL）中的重排序问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//第二次判断是为了防止以下情况：A线程拿到锁了，并且new了对象，而B线程此时正好在 synchronized 获取锁这一行代码，A释放锁后，B会获取到锁，如果不加第二次判断，B线程也会new一个对象</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 这行会被重排序！</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><div class="note primary flat"><p> instance = new Singleton() 在JVM和CPU中分为以下三步</p><ol><li>分配内存</li><li>将引用赋值给 instance</li><li>调用构造函数初始化对象</li></ol><p>这三个操作是可能出现指令重排序的情况，可能就会造成，test != null，但是还没用执行第二步的初始化属性，导致其他线程拿着一个还未初始化完成的，或者说一个半成品对象去操作，这会带来一些线程安全的问题。</p></div><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 被重排序</span><br>&#125;<br><br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>    use(instance);  <span class="hljs-comment">// ⚠️可能访问未初始化的对象！</span><br>&#125;<br><span class="hljs-comment">// 发生指令重排序后</span><br>线程 A：<br><span class="hljs-number">1.</span> 分配内存<br><span class="hljs-number">2.</span> 调用构造函数初始化对象     <span class="hljs-comment">// instance ≠ null，但对象没构造好</span><br><span class="hljs-number">3.</span> 将引用赋值给 instance;          <span class="hljs-comment">// 构造函数稍后才执行</span><br><br>线程 B：<br>看到 instance ≠ <span class="hljs-literal">null</span>，立刻使用它<br></code></pre></td></tr></table></figure></p><h1 id="new一个新线程的方法"><a href="#new一个新线程的方法" class="headerlink" title="new一个新线程的方法"></a>new一个新线程的方法</h1><h2 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程运行中：&quot;</span> + Thread.currentThread().getName());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        t1.start(); <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2.实现 Runnable 接口"></a>2.实现 Runnable 接口</h2><p>需要重写run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程正在运行：&quot;</span> + Thread.currentThread().getName());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();    <span class="hljs-comment">// 创建任务</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);      <span class="hljs-comment">// 创建线程</span><br>        thread.start();                        <span class="hljs-comment">// 启动线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>用匿名内部类简化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程运行中：&quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-使用-Callable-接口-FutureTask"><a href="#3-使用-Callable-接口-FutureTask" class="headerlink" title="3. 使用 Callable 接口 + FutureTask"></a>3. 使用 Callable 接口 + FutureTask</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程返回结果：&quot;</span> + Thread.currentThread().getName();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        t1.start();<br><br>        <span class="hljs-comment">// 获取线程执行结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>        System.out.println(<span class="hljs-string">&quot;线程执行结果：&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1>线程中断（Thread Interruption）是 Java 提供的一种优雅终止线程的机制，它并不会强制终止线程，而是向线程发送一个“中断请求”信号，由线程自己决定何时响应、如何响应。</li></ul><p>核心方法:</p><div class="table-container"><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>interrupt()</code></td><td>向目标线程发出中断请求</td></tr><tr><td><code>isInterrupted()</code></td><td>判断线程是否被中断（不清除中断状态）</td></tr><tr><td><code>interrupted()</code>（静态方法）</td><td>判断当前线程是否中断，同时清除中断状态</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadInterruptExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建一个线程任务</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程启动：&quot;</span> + Thread.currentThread().getName());<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;执行任务：&quot;</span> + i);<br><br>                    <span class="hljs-comment">// 模拟耗时操作，支持响应中断</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">// 可选：额外判断中断状态（即使 sleep 不被中断）</span><br>                    <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;检测到中断状态，准备退出...&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// 如果 sleep 被中断，会进入此处</span><br>                System.out.println(<span class="hljs-string">&quot;线程在休眠中被中断！&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程资源清理完毕，退出！&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 启动线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;工作线程&quot;</span>);<br>        worker.start();<br><br>        <span class="hljs-comment">// 主线程等待 3 秒后中断子线程</span><br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>        System.out.println(<span class="hljs-string">&quot;主线程发送中断信号...&quot;</span>);<br>        worker.interrupt(); <span class="hljs-comment">// 向 worker 发出中断请求</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子展示了一个线程中断的情况，当主线程执行了 worker.interrupt()，就会将 Thread.currentThread().isInterrupted() 设置为true,这样可以进行判断手动停止线程，如果该线程没有sleep，wait等阻塞的话，进行线程中断的话，不会有任何影响，直到该线程执行到代码 Thread.currentThread().isInterrupted()的时候会为true，可手动停止代码，如果线程处于sleep,wait的阻塞状态会立刻抛出异常</p><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h2 id="悲观锁-amp-乐观锁"><a href="#悲观锁-amp-乐观锁" class="headerlink" title="悲观锁&amp;乐观锁"></a>悲观锁&amp;乐观锁</h2><p>Java中的悲观锁，比如synchronized，ReentrantLock，ReentrantReadWriteLock。</p><p>Java中的乐观锁，采用的CAS操作，CompareAndSwap（比较和交换），CAS是基于CPU原语实现的。</p><p>悲观锁： 悲观锁在获取不到锁资源后，会将当前线程挂起（BLOCKED，WAITING，TIMED_WAITING），线程挂起这个事情，不是JVM层面能解决的问题。需要操作系统来完成这个事情。那就需要涉及到用户态和内核态之间的切换，这种切换，会影响一定效率。</p><p>乐观锁： 乐观锁不涉及线程挂起，不涉及用户态和内核态之间的切换。如果长时间执行乐观锁的机制，但是一直无法成功，会浪费一些CPU性能，都在做尝试，但是一直没成功。</p><p>如果可以，最好是在尝试几次就能成功的场景，使用乐观锁实现。如果这个锁资源获取需要一定的时间，最好使用悲观锁。</p><h2 id="公平锁-amp-amp-非公平锁"><a href="#公平锁-amp-amp-非公平锁" class="headerlink" title="公平锁&amp;&amp;非公平锁"></a>公平锁&amp;&amp;非公平锁</h2><p>公平锁：用于在多线程环境中控制资源的访问顺序。它的核心目的是保证线程获取锁的顺序是公平的，也就是说，先请求锁的线程应当先获得锁，避免线程“饿死”。<br>非公平锁：是一种允许线程在任何时刻尝试获取锁的机制，不保证先请求的线程一定先获得锁。这可能会导致某些线程“插队”，从而提高整体性能</p><p>在Java中，synchronized只支持非公平锁。</p><p>ReentrantLock和ReentrantReadWriteLock既支持公平锁也支持非公平锁，可以通过有参构造传递boolean的值类决定是否公平（默认非公平锁）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 默认不传递，fair是false，new的是NonfairSync，如果主动传递true作为参数，构建FairSync作为公平锁的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure></p><h2 id="可重入锁-amp-amp-不可重入锁"><a href="#可重入锁-amp-amp-不可重入锁" class="headerlink" title="可重入锁&amp;&amp;不可重入锁"></a>可重入锁&amp;&amp;不可重入锁</h2><ol><li>可重入锁：同一个线程在外层方法获取锁之后，能在内层方法中自动获得锁的代码执行权。**不会因为再次获取锁而被阻塞<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outer</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;outer&quot;</span>);<br>            inner(); <span class="hljs-comment">// 同一个线程再次加锁</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inner</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 如果是不可重入锁，这里会死锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;inner&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantExample</span>().outer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note primary flat"><p>可重入锁中会有一个计数器，记录了获取锁的次数，获取几次锁就需要释放几次锁  Java 中的 synchronized 和 ReentrantLock 都是可重入锁</p></div></li><li>不可重入锁：同一个线程如果尝试再次获取自己已经持有的锁，会被阻塞或死锁。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonReentrantLock</span>();<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">outer</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    inner(); <span class="hljs-comment">// 会死锁</span><br>    lock.unlock();<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">inner</span><span class="hljs-params">()</span> &#123;<br>    lock.lock(); <span class="hljs-comment">// 死锁，因为当前线程已经持有锁</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><div class="table-container"><table><thead><tr><th>特性</th><th>可重入锁 (<code>synchronized</code>, <code>ReentrantLock</code>)</th><th>不可重入锁（需要自己实现）</th></tr></thead><tbody><tr><td>重入能力</td><td>支持</td><td>不支持</td></tr><tr><td>死锁风险</td><td>低（递归调用安全）</td><td>高（递归调用可能死锁）</td></tr><tr><td>实现复杂度</td><td>较高，需维护线程状态和计数器</td><td>简单</td></tr><tr><td>典型应用</td><td><code>synchronized</code>、<code>ReentrantLock</code></td><td>自定义锁、嵌入式系统</td></tr></tbody></table></div><h2 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁&amp;共享锁"></a>互斥锁&amp;共享锁</h2><ol><li><p>互斥锁：同一时间只允许一个线程/事务持有该锁并访问资源，其他线程必须等待锁释放才能继续。也称写锁<br>特点：</p><ul><li><p>也叫 写锁（Write Lock）</p></li><li><p>独占访问：一个线程获取后，其它线程必须阻塞</p></li><li><p>适用于修改资源的场景，确保数据一致性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 修改资源（独占访问）</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM table_name WHERE id = 1 FOR UPDATE;<br>//FOR UPDATE 是一种 互斥锁（排它锁），阻止其他事务修改或读取该记录（视隔离级别而定）。<br></code></pre></td></tr></table></figure></li></ul></li><li><p>共享锁：允许多个线程/事务同时持有锁来读取资源，但不允许写入。<br>特点：</p><ul><li><p>也叫 读锁（Read Lock）</p></li><li><p>多个线程可并发读取，但不能写入</p></li><li><p>旦某线程申请了写锁，读写都需等待写锁释放</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>lock.readLock().lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 并发读取资源</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.readLock().unlock();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">SELECT * FROM table_name WHERE id = 1 LOCK IN SHARE MODE;<br><br>//LOCK IN SHARE MODE 是共享锁，多个事务可读取，但不能修改该行。<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>特性</th><th>互斥锁（写锁）</th><th>共享锁（读锁）</th></tr></thead><tbody><tr><td>是否独占</td><td>✅ 是</td><td>❌ 否（可共享）</td></tr><tr><td>读操作</td><td>❌ 阻塞其他线程读取</td><td>✅ 允许多个线程读取</td></tr><tr><td>写操作</td><td>✅ 允许写</td><td>❌ 禁止写</td></tr><tr><td>典型用途</td><td>数据写入、修改</td><td>数据读取</td></tr><tr><td>性能</td><td>较低（锁粒度粗）</td><td>较高（读多写少场景）</td></tr></tbody></table></div><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS 是一种无锁（lock-free）并发编程技术，用于实现线程安全的操作。它是 CPU 层面支持的原子操作指令，Java 在底层通过调用它来实现原子变量更新（如 AtomicInteger、AtomicReference 等）。</p><ol><li>为什么称CAS是一种无锁的并发编程<div class="note primary flat"><p>CAS 更像是一种编程思想，核心思想是：<br>当且仅当预期值与内存中的当前值一致时，才更新为新值。否则什么都不做。<br>这是一种乐观锁策略：认为并发很少发生，所以先尝试修改，失败了再重试。</p></div>假设我们有一个变量 V，预期值为 E，新值为 N，那么：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">if (V == E) &#123;<br>    V = N;<br>    return true;<br>&#125; else &#123;<br>    return false;<br>&#125;<br></code></pre></td></tr></table></figure>如果变量当前值和期望值相等，就将其更新为新值；</li></ol><p>否则，表示有其他线程已经修改了它，更新失败。</p><ol><li>CAS的优点</li></ol><div class="table-container"><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>✅ 无锁机制</td><td>避免传统锁带来的上下文切换开销，提高并发性能</td></tr><tr><td>✅ 原子性强</td><td>硬件保证，天然线程安全</td></tr><tr><td>✅ 效率高</td><td>没有加锁阻塞，线程不会被挂起</td></tr></tbody></table></div><ol><li>CAS的缺点</li></ol><p>❌ 1. ABA 问题<br>A 线程看到变量从 A → B → A，CAS 会认为没有变化，但实际上已经变化过；</p><p>解决办法：使用 AtomicStampedReference 或 AtomicMarkableReference，引入版本号或标记位。</p><p>❌ 2. 自旋消耗 CPU(会进行while操作)<br>在高并发冲突严重时，线程可能会不断地自旋重试，浪费 CPU。</p><p>❌ 3. 只能操作一个变量<br>不能实现多个变量的原子更新；</p><p>解决办法：使用加锁或 AtomicReferenceFieldUpdater 等更复杂的机制。</p><ol><li>Java中提供了一个类，Unsafe类，Unsafe中提供了CAS的操作方法 </li></ol><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized的锁是基于对象实现的。在Java中，Object类中提供了wait和notify之类的，做一个锁的操作。而Java中所有的类都是继承Object的，所以所有对象都可以作为一把锁。</p><h2 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h2><ol><li>对象锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个synchronized方法是基于LockTest的对象，作为一把锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        LockTest.count++;<br>    &#125;<br><br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此时调用test.increment()方法时，底层使用的就是test对象作为锁。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LockTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockTest</span>();<br>        test.increment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个synchronized的static方法是基于LockTest.class，作为一把锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        LockTest.count++;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此时这种方式，就是基于LockTest.class作为锁，全局就一把</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LockTest.increment();<br>        LockTest.increment();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note primary flat"><p>static 强调的是“附属于类”，适合设计那些无需实例就能使用、且由所有对象共享的成员；例如例子中的 public static int count = 0，这个count在类加载的时候就会存在了，所有的实例化对象(例如 LockTest test = new LockTest())都能访问这个count，而不是每个对象都有一个属于自己的count，static用来修饰方法也是一样的</p></div></li><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * synchronized (对象)，此时这个对象就是当前锁资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (LockTest.class)&#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * synchronized (对象)，此时这个对象就是当前锁资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (LockTest.class)&#123;<br>            count--;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h2></li><li>锁消除：锁消除就是编译器的一个优化的技术（JIT），用于消除不必要的同步锁操作，提升程序的执行效率。</li><li>锁膨胀/粗化：锁膨胀也是编译器JIT做的一个优化手段，用于扩大锁的范围，从而避免频繁的加锁释放锁操作，从而提升程序的性能。</li><li>锁升级:锁升级是指 随着锁竞争的加剧，JVM 自动将锁从低级别升级到高级别<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br></code></pre></td></tr></table></figure><div class="note primary flat"><p>锁升级是 不可逆的，一旦升级，不能降级。例如，一旦进入重量级锁，就不会退回轻量级锁。</p></div></li></ol><p>1.无锁（No Lock）</p><p>对象没有被任何线程访问。</p><p>普通的非同步对象处于此状态。</p><ol><li>偏向锁</li></ol><p>当只有一个线程访问对象同步块时，为了减少无竞争情况下的开销，会将锁偏向某个线程。</p><p>适用于线程偏向性强的场景（即，大多数时间都是一个线程访问该对象）。</p><ol><li>轻量级锁</li></ol><p>有多个线程交替访问（无实际竞争），通过使用 CAS 操作避免重量级的线程阻塞和唤醒。</p><p>在同步块进入前尝试使用 CAS 抢占锁。</p><ol><li>重量级锁</li></ol><p>多个线程同时访问某个对象时发生了实际竞争，系统不得不使用操作系统的互斥量机制。</p><p>会造成线程阻塞，性能开销较大。</p><div class="table-container"><table><thead><tr><th>升级路径</th><th>触发条件说明</th></tr></thead><tbody><tr><td>无锁 → 偏向锁</td><td>对象第一次被线程访问，JVM 开启偏向锁，且没有竞争</td></tr><tr><td>偏向锁 → 轻量级锁</td><td>另一个线程尝试访问被偏向的对象（产生潜在竞争）</td></tr><tr><td>轻量级锁 → 重量级锁</td><td>多线程并发争用同一锁对象，CAS 自旋失败</td></tr></tbody></table></div><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><div class="note primary flat"><p>ReentrantLock 也是互斥锁</p></div><h2 id="ReentrantLock在加锁方面就提供了4中方式："><a href="#ReentrantLock在加锁方面就提供了4中方式：" class="headerlink" title="ReentrantLock在加锁方面就提供了4中方式："></a>ReentrantLock在加锁方面就提供了4中方式：</h2><p>lock()死等的方式<br>lockInterruptibly()死等的方式，但是在死等时，允许中断<br>tryLock()蜻蜓点水，尝试一下，拿到返回true，没拿到返回false。<br>tryLock(time,unit)尝试time.unit时间，拿到返回true，没拿到返回false，同时在time.unit时间内，允许中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">xx</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// lock.lock() -&gt; 排队拿锁，拿不到死等。等到拿到锁。</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是业务逻辑&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// ==================================================================</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// lock.lockInterruptibly() -&gt; 允许被中断的拿锁方式 interrupt</span><br>        lock.lockInterruptibly();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是业务逻辑&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// ==================================================================</span><br>    <span class="hljs-comment">// lock.tryLock() -&gt; 尝试一下拿锁，拿到执行业务，拿不到，返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> lock.tryLock();<br>    <span class="hljs-keyword">if</span> (b1) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是业务逻辑&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ==================================================================</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// lock.tryLock(2, TimeUnit.SECONDS); -&gt; 尝试2s，拿锁，拿到返回true。没拿到返回false，在2s内，如果被中断了，就抛出异常</span><br>        b2 = lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b2) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是业务逻辑&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁&amp;非公平锁"></a>公平锁&amp;非公平锁</h2><p>非公平锁（默认）：多个线程抢锁，没有顺序，性能高；</p><p>公平锁（可选）：按照请求顺序排队，防止“饥饿”，但性能稍差。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Lock fairLock = new ReentrantLock(true);  // 公平锁<br>Lock unfairLock = new ReentrantLock();    // 非公平锁<br></code></pre></td></tr></table></figure></p><ul><li>非公平锁的加锁流程:</li></ul><ol><li>调用 lock() 方法<br>↓</li><li>先尝试直接 CAS 修改 state = 0 → 1<ul><li>成功：抢锁成功，设置当前线程为持有者，直接进入临界区</li><li>失败：进入 AQS.acquire()<br>↓</li></ul></li><li>tryAcquire() 再尝试获取锁：<ul><li>state == 0：再直接 CAS 抢锁（允许插队）</li><li>否则如果当前线程是持有锁线程 → 支持重入 → state++</li><li>否则 → 抢锁失败，准备排队<br>↓</li></ul></li><li>addWaiter(Node.EXCLUSIVE)<ul><li>把当前线程封装成 Node 加入 AQS 队列尾部<br>↓</li></ul></li><li>acquireQueued()<ul><li>若自己是 head.next → 继续尝试抢锁</li><li>否则挂起（LockSupport.park）<br>↓</li></ul></li><li>等待持有锁的线程 unlock()，调用 unparkSuccessor() 唤醒下一个</li></ol><ul><li>公平锁的加锁流程:</li></ul><ol><li>调用 lock() 方法<br>↓</li><li>直接调用 AQS.acquire()<br>↓</li><li>tryAcquire()<ul><li>state == 0 &amp;&amp; !hasQueuedPredecessors()：<br>  → 若前面没有排队线程 → 尝试 CAS 抢锁</li><li>否则：<ul><li>当前线程是否是持有者？ → 是：重入</li><li>否：抢锁失败，准备排队<br>↓</li></ul></li></ul></li><li>addWaiter(Node.EXCLUSIVE)<ul><li>把当前线程封装成 Node 加入 AQS 队列尾部<br>↓</li></ul></li><li>acquireQueued()<ul><li>若自己是 head.next → 再次尝试 tryAcquire()</li><li>否则挂起（LockSupport.park）<br>↓</li></ul></li><li>等待前驱线程释放锁，unpark 唤醒当前线程</li></ol><ul><li>流程对比:</li></ul><div class="table-container"><table><thead><tr><th>步骤</th><th>非公平锁</th><th>公平锁</th></tr></thead><tbody><tr><td>1</td><td><code>lock()</code> → 先直接 CAS 抢锁</td><td><code>lock()</code> → 直接进入 <code>acquire()</code></td></tr><tr><td>2</td><td><code>tryAcquire()</code> 中直接 CAS 抢锁</td><td><code>tryAcquire()</code> 中先判断是否排队再抢锁</td></tr><tr><td>3</td><td>插队？✔️ 支持</td><td>❌ 不支持，必须排队</td></tr><tr><td>4</td><td>加入 AQS 队列：Node（线程）</td><td>加入 AQS 队列：Node（线程）</td></tr><tr><td>5</td><td>是 head.next？尝试获取锁</td><td>是 head.next？判断排队情况再尝试获取锁</td></tr><tr><td>6</td><td>否则 LockSupport.park 阻塞线程</td><td>否则 LockSupport.park 阻塞线程</td></tr><tr><td>7</td><td>唤醒下一个等待节点</td><td>唤醒下一个等待节点</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>项目</th><th>非公平锁</th><th>公平锁</th></tr></thead><tbody><tr><td>lock() 方法</td><td>先尝试直接 CAS 抢锁，失败才排队</td><td>直接调用 <code>acquire()</code>，不抢锁</td></tr><tr><td>tryAcquire() 方法中逻辑</td><td>state == 0 → 直接 CAS 抢锁</td><td>state == 0 → 先检查队列是否有前驱再决定是否抢锁</td></tr><tr><td>抢锁行为</td><td>不管队列有没有线程，优先尝试抢锁</td><td>若前面有等待线程，自己不能插队</td></tr><tr><td>性能</td><td>更快，但可能导致<strong>线程饥饿</strong></td><td>更公平，线程获取锁的顺序更可控，但<strong>吞吐量略低</strong></td></tr></tbody></table></div><h2 id="ReentrantLock-与-synchronized-的区别"><a href="#ReentrantLock-与-synchronized-的区别" class="headerlink" title="ReentrantLock 与 synchronized 的区别"></a>ReentrantLock 与 synchronized 的区别</h2><div class="table-container"><table><thead><tr><th>对比项</th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>锁机制类型</td><td>隐式锁，基于 JVM</td><td>显式锁，由程序员控制</td></tr><tr><td>解锁方式</td><td>自动释放（方法/代码块执行完）</td><td>需手动 <code>unlock()</code>，否则可能死锁</td></tr><tr><td>是否可中断</td><td>不可中断</td><td>可通过 <code>lockInterruptibly()</code> 实现中断响应</td></tr><tr><td>是否可限时尝试加锁</td><td>不支持</td><td>支持 <code>tryLock(timeout)</code> 设定等待时间</td></tr><tr><td>是否公平锁</td><td>不支持，默认非公平</td><td>支持公平锁和非公平锁构造方式</td></tr><tr><td>性能表现</td><td>较轻量，适合简单同步场景</td><td>功能强大，适合复杂并发控制</td></tr></tbody></table></div><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池通过重复利用固定数量的线程来执行大量任务，可以大幅降低线程创建和销毁的开销，提升系统性能和响应速度。</p><h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> corePoolSize,      // 核心线程数</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maximumPoolSize,   // 最大线程数</span><br><span class="hljs-params">    <span class="hljs-type">long</span> keepAliveTime,    // 线程空闲存活时间</span><br><span class="hljs-params">    TimeUnit unit,         // 上面时间单位</span><br><span class="hljs-params">    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列</span><br><span class="hljs-params">    ThreadFactory threadFactory,       // 线程工厂</span><br><span class="hljs-params">    RejectedExecutionHandler handler   // 拒绝策略</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure><ol><li>corePoolSize（核心线程数）<br>指线程池中保留的最小线程数。</li></ol><p>即使这些线程处于空闲状态，也不会被回收，始终保留。</p><p>当有任务来时，先用核心线程执行。</p><ol><li>maximumPoolSize（最大线程数）<br>线程池中允许存在的最大线程数量。</li></ol><p>当任务太多，队列满了，就会创建非核心线程来执行任务，直到达到最大线程数。</p><p>超过该值，就会触发拒绝策略。</p><ol><li>③ keepAliveTime（非核心线程空闲存活时间）<br>非核心线程在空闲状态下最多保持多长时间不被销毁。</li></ol><p>超过这个时间未被使用，线程会被自动回收。</p><p>⚠️ 注意：</p><p>默认情况下只对非核心线程有效；<br>但可以使用 allowCoreThreadTimeOut(true) 让核心线程也超时回收。</p><ol><li>④ unit（时间单位）<br>keepAliveTime 的时间单位，使用 TimeUnit 枚举，如：</li></ol><ul><li>TimeUnit.SECONDS</li><li>TimeUnit.MILLISECONDS 等</li></ul><ol><li>⑤ workQueue（任务队列）<br>存放提交但尚未执行的任务。<br>队列种类影响线程池的行为模型。</li></ol><div class="table-container"><table><thead><tr><th>队列类型</th><th>特点说明</th></tr></thead><tbody><tr><td><code>ArrayBlockingQueue</code></td><td>有界阻塞队列，FIFO，常用于限制任务数量</td></tr><tr><td><code>LinkedBlockingQueue</code></td><td>无界队列，任务会无限堆积，容易 OOM（⚠️默认Executors使用）</td></tr><tr><td><code>SynchronousQueue</code></td><td>直接交接，不存储任务（用于 <code>CachedThreadPool</code>）</td></tr><tr><td><code>PriorityBlockingQueue</code></td><td>支持任务优先级排序</td></tr></tbody></table></div><ol><li>⑥ threadFactory（线程工厂）<br>用于创建线程，可以自定义线程名称、是否守护线程、线程组等。</li></ol><p>便于线程监控和调试。</p><p>默认实现是 Executors.defaultThreadFactory()，你也可以自定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;my-thread-&quot;</span> + count.incrementAndGet());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>⑦ RejectedExecutionHandler（拒绝策略）<br>当线程池 线程数达到最大，任务队列满时，执行失败任务的处理策略。</p><p>四种内置策略：</p><div class="table-container"><table><thead><tr><th>策略类</th><th>行为说明</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>抛出 <code>RejectedExecutionException</code> 异常</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>谁提交任务，谁就自己去执行（同步）</td></tr><tr><td><code>DiscardPolicy</code></td><td>直接丢弃任务，不抛异常</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃队列中最老的任务，尝试提交当前任务</td></tr></tbody></table></div><h2 id="线程池的简单使用"><a href="#线程池的简单使用" class="headerlink" title="线程池的简单使用"></a>线程池的简单使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建线程池</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">2</span>,                      <span class="hljs-comment">// 核心线程数</span><br>                <span class="hljs-number">4</span>,                      <span class="hljs-comment">// 最大线程数</span><br>                <span class="hljs-number">60</span>,                     <span class="hljs-comment">// 非核心线程空闲时间</span><br>                TimeUnit.SECONDS,       <span class="hljs-comment">// 空闲时间单位</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>), <span class="hljs-comment">// 任务队列（最多排队2个任务）</span><br>                Executors.defaultThreadFactory(), <span class="hljs-comment">// 默认线程工厂</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略</span><br>        );<br><br>        <span class="hljs-comment">// 提交5个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() +<br>                        <span class="hljs-string">&quot; 执行任务：&quot;</span> + taskId);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟任务执行耗时</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池（执行完任务再关闭）</span><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>🧾 解释说明：<br>核心线程：2 个 → 最多同时有 2 个线程在工作</p><p>队列容量：2 → 除了正在执行的任务外，还能再缓冲两个任务</p><p>最大线程：4 → 如果队列满了，最多还能额外启动 2 个线程</p><p>提交 5 个任务：</p><ul><li><p>任务 1 和 2 → 被核心线程直接执行</p></li><li><p>任务 3 和 4 → 被放入等待队列</p></li><li><p>任务 5 → 队列已满，创建新线程执行</p></li></ul><p>超过最大线程 + 队列容量时（第 7 个以上任务）→ 触发拒绝策略<br><img src="https://pic1.imgdb.cn/item/685904b058cb8da5c8656048.png" alt=""></p><h3 id="submit-和-execute-的区别"><a href="#submit-和-execute-的区别" class="headerlink" title="submit() 和 execute() 的区别"></a>submit() 和 execute() 的区别</h3><p>submit()可以获取到现成的返回值，execute() 不能获取到线程的返回值</p><div class="table-container"><table><thead><tr><th>方法名</th><th>返回值</th><th>是否能获取任务执行结果</th><th>是否能捕获异常</th></tr></thead><tbody><tr><td><code>execute()</code></td><td><code>void</code></td><td>❌ 不能获取</td><td>❌ 无法捕获异常（除非 try-catch）</td></tr><tr><td><code>submit()</code></td><td><code>Future&lt;?&gt;</code></td><td>✅ 可以获取</td><td>✅ 能捕获异常通过 <code>Future.get()</code> 抛出</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubmitExample2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br>        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>        &#125;);<br><br>        <span class="hljs-comment">// 获取任务返回值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get();  <span class="hljs-comment">// 会阻塞直到任务完成</span><br>        System.out.println(<span class="hljs-string">&quot;任务返回结果：&quot;</span> + result);<br><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>多线程的知识先到此结束，其实很早之前学过一遍了，但是忘的一干二净了，所以来复习一遍，其实还有很多多线程的知识没有学完，等后面有时间了或者遇到没见过的多线程问题会继续补充</p>]]></content>
    
    
    <summary type="html">重新认识JUC</summary>
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
</feed>

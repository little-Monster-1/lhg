<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Little Monste&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-10T08:31:34.932Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>小怪兽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/09/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-09-10T08:20:20.287Z</published>
    <updated>2024-09-10T08:31:34.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>将业务的所有功能集中在一个项目中开发，打成一个包部署</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>架构简单</li><li>部署成本低<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>团队协作成本高</li><li>系统发布效率低</li><li>系统可用性差<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2>把单体架构的功能模块拆分成多个独立的项目<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3></li><li>粒度小： 拆分的项目可以可以只是一个单独的功能</li><li>团队自治</li><li>服务自治</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;h2 id=&quot;单体架构&quot;&gt;&lt;a href=&quot;#单体架构&quot; class=&quot;headerlink&quot; title=&quot;单体架构&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="http://example.com/2024/09/07/vue3/"/>
    <id>http://example.com/2024/09/07/vue3/</id>
    <published>2024-09-07T09:53:12.890Z</published>
    <updated>2024-09-08T10:34:00.690Z</updated>
    
    <content type="html"><![CDATA[<p>什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧</p><h1 id="vue3概要"><a href="#vue3概要" class="headerlink" title="vue3概要"></a>vue3概要</h1><p>Vue是一套前端框架，用于简化JavaScript中的DOM操作，简化书写。</p><p>在之前我们也学习过后端的框架MyBatis，MyBatis是用来简化JDBC代码编写的；而Vue是前端框架，简化JavaScript代码编写的</p><h2 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h2><ol><li>vue3的使用前提需要下载安装好node.js版本要在15.0以上</li><li>在命令窗中输入 npm init vue@laste 即可创建一个初始的vue文件夹</li><li>hello vue<br>值得一提的是每个绑定仅支持单一的js表达式，如{ {n+1} },页面会显示11，{ {ok?yes:no} }，页面会显示ok<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123; &#123;meg&#125; &#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123; &#123;n+1&#125; &#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123; &#123;ok?yes:no &#125; &#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script &gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">      data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">          meg:&quot;hello jsp&quot;,</span><br><span class="line">          n:10,</span><br><span class="line">          ok:true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么破学校还要学jsp,jsp是学不了了，浅学一下VUE3，应付一下期末考试吧&lt;/p&gt;
&lt;h1 id=&quot;vue3概要&quot;&gt;&lt;a href=&quot;#vue3概要&quot; class=&quot;headerlink&quot; title=&quot;vue3概要&quot;&gt;&lt;/a&gt;vue3概要&lt;/h1&gt;&lt;p&gt;Vue是一套前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/"/>
    <id>http://example.com/2024/09/07/%E6%B5%85%E5%AD%A6Docker/</id>
    <published>2024-09-07T07:10:34.612Z</published>
    <updated>2024-09-09T13:14:35.219Z</updated>
    
    <content type="html"><![CDATA[<p>每次学新东西，就想到当初选JAVA后端，我就想扇自己<br>一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了<br>虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦<br>为什么不能docker一键安装docker呢</p><h1 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h1><p>Docker是一款应用容器引擎，可以帮助我们快速部署和搭建<br>Docker需要在Linux环境下运行，所以需要虚拟机搭建环境</p><p>使用Docker的前提当然是搭建虚拟机了<br>具体安装虚拟机和Docker可看<a href="https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d">https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d</a></p><h2 id="基于Docker安装mysql"><a href="#基于Docker安装mysql" class="headerlink" title="基于Docker安装mysql"></a>基于Docker安装mysql</h2><p>只需要一条命令即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> docker run -d \</span><br><span class="line">&gt;   --name mysql \</span><br><span class="line">&gt;    -p 3306:3306 \</span><br><span class="line">&gt;    -e TZ=Asia/Shanghai \</span><br><span class="line">&gt;    -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">&gt;    mysql</span><br></pre></td></tr></table></figure><br><img src="https://t.tutu.to/img/0mlwr" alt=""><br>以上就是Docker安装mysql，真是太简单了，我大一安装mysql可是一直出错，安装了一整天了<br>Docker安装部署这么容易是因为Docker下载的是已经部署好的mysql镜像，而且Docker运行这些镜像的时候<br>会创建一个隔离环境，称为容器。所以同时运行多个镜像也是可以的<br>正是因为如此Docker可以解决依赖兼容问题<br><img src="https://pic.imgdb.cn/item/639872ecb1fccdcd3695de9e.jpg" alt=""></p><h2 id="Docker的常见命令"><a href="#Docker的常见命令" class="headerlink" title="Docker的常见命令"></a>Docker的常见命令</h2><ol><li>docker run 创建并运行镜像</li><li>-d 让镜像在后台运行<br>如果不加 -d 镜像会在控制台执行，不能进行其他操作直到停止</li><li>-p 端口映射<br>因为我们的Docker是在Linux虚拟机上部署的，假设虚拟机的IP是192.168.150.101.<br>Docker运行镜像会创建单独的容器，其实这个容器也是有IP地址的，但是我们直接访问容器的IP会失败<br>所以会进行映射，通过访问虚拟机的IP端口映射到容器的IP端口<br><img src="https://t.tutu.to/img/0mtW6" alt=""></li><li>-e 设置环境变量 格式为 KEY=VALUE<br>具体的环境变量需要查看Docker的镜像官网</li><li>—name 设置镜像的名称</li><li>docker pull 从镜像仓库拉取镜像到本地仓库</li><li>docker images 查看本地镜像</li><li>docker rmi 删除本地镜像</li><li>docker push 将本地镜像推送到镜像仓库</li><li>docker stop 停止容器</li><li>docker start 启动容器</li><li>docker ps 查看容器运行状态</li><li>docker rm 删除容器</li><li>docker exec -it 容器名 bash 通过命令行操作容器</li></ol><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><ol><li>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录的之间映射的桥梁；<br>数据卷解决的问题：docker为我们下载的镜像文件只包含了该文件运行所需要的依赖环境，<br>所以如果我们通过docker exec -it 容器名 bash命令进入该容器去操作容器内文件时，<br>会发现容器内并没有 vi 等操作文件的命令，所以我们不能在容器里操作容器里的文件<br>因此数据卷可以为我们解决这个问题<br>解决的原理     ：数据卷可以进行双向映射，创建数据卷目录，然后分别对应容器中的目录和<br>虚拟机docker中的目录，映射成功后，通过操作虚拟机中的目录就可以达到操作容器目录的效果<br>数据卷对应的虚拟机目录一般都在volume目录下<br><img src="https://pic.imgdb.cn/item/66dd5deed9c307b7e9d22582.png" alt=""> <h2 id="数据卷命令"><a href="#数据卷命令" class="headerlink" title="数据卷命令"></a>数据卷命令</h2><img src="https://pic.imgdb.cn/item/66dd5f38d9c307b7e9d538f6.png" alt=""><h2 id="数据卷映射目录"><a href="#数据卷映射目录" class="headerlink" title="数据卷映射目录"></a>数据卷映射目录</h2>docker run -v 数据卷名（自定义）：容器目录</li><li>docker run 是创造并执行容器，所以如果一个容器已经被创造，但是没有挂载数据卷，即就不能挂载数据卷或者会自动挂载一个匿名卷</li><li>如果执行该命令的时候数据卷不存在，会自动创建，数据卷会和虚拟机volums目录下和数据卷同名的文件目录自动挂载，<h2 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h2>使用命令：docker run -v 本地目录（自定义）：容器目录</li><li>本地目录必须以 / 或者 ./开头</li><li>和数据卷挂载的区别：直接将本地目录 和容器目录挂载，本地目录不需要是在volume目录下<h3 id="本地挂载mysql"><a href="#本地挂载mysql" class="headerlink" title="本地挂载mysql"></a>本地挂载mysql</h3></li><li>创建对应的文件夹<br><img src="https://pic.imgdb.cn/item/66deb3c1d9c307b7e9dd1fc9.png" alt=""></li><li>将提前准备好的sql语句脚本和dockerfile文件导入mysql文件夹</li><li>运行命令<br>记得前提把上面示例创造的mysql容器删除，不然会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66deb4b5d9c307b7e9de2474.png" alt=""><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3>镜像就是包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程其实就是把上述文件打包的过程。</li></ol><h3 id="docker镜像的结构"><a href="#docker镜像的结构" class="headerlink" title="docker镜像的结构"></a>docker镜像的结构</h3><ol><li>基础镜像是通用的，因为是分层结构，所以其他镜像也可以使用<br><img src="https://pic.imgdb.cn/item/66dd7842d9c307b7e9ff4976.png" alt=""></li><li>设置镜像结构 Dockerfile<br><img src="https://pic.imgdb.cn/item/66dd7934d9c307b7e901e387.png" alt=""><h3 id="尝试自定义镜像"><a href="#尝试自定义镜像" class="headerlink" title="尝试自定义镜像"></a>尝试自定义镜像</h3></li><li>编写Dockerfile<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 基础镜像</span><br><span class="line">FROM openjdk:11.0-jre-buster</span><br><span class="line"># 设定时区</span><br><span class="line">ENV TZ=Asia/Shanghai</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</span><br><span class="line"># 拷贝jar包</span><br><span class="line">COPY docker-demo.jar /app.jar</span><br><span class="line"># 入口</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure></li><li>将准备好的demo.jar和Dockerfile上传到虚拟机中</li><li>执行 docker build -t docker-demo .<br>-t :给镜像命名<br>. :表示当前路径，如果不在上传的demo文件下，需要指定demo的位置</li><li>执行 docker run -d —name dd -p 8080:8080 docker-dome<br><img src="https://pic.imgdb.cn/item/66dd7b60d9c307b7e90673d4.png" alt=""><br>如图成功，访问8080端口<br><img src="https://pic.imgdb.cn/item/66dd7bc7d9c307b7e906e7ab.png" alt=""></li></ol><h2 id="容器网络互联"><a href="#容器网络互联" class="headerlink" title="容器网络互联"></a>容器网络互联</h2><p>如果在创建容器的时候没有指定网段IP，docker会通过网桥自动分配给容器一个IP，但是容器关闭后，这个IP会被分配给其他容器<br><img src="https://pic.imgdb.cn/item/66deb600d9c307b7e9df983f.png" alt=""></p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>加入自定义网络的容器可以通过容器名互相访问<br><img src="https://pic.imgdb.cn/item/66deb669d9c307b7e9e00690.png" alt=""><br>创建自定义网络 hmall<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create hmall</span><br></pre></td></tr></table></figure><br>使mysql处于自定义网络中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect hmall mysql</span><br></pre></td></tr></table></figure></p><h2 id="部署JAVA应用"><a href="#部署JAVA应用" class="headerlink" title="部署JAVA应用"></a>部署JAVA应用</h2><ol><li>对JAVA应用打包，将写好的dockerfile和jar导入虚拟机root目录下<br><img src="https://pic.imgdb.cn/item/66deba94d9c307b7e9e842f0.png" alt=""></li><li>构建镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hmall .</span><br></pre></td></tr></table></figure></li><li>创造运行容器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name hmall --network hmall -p 8080:8080 hmall</span><br></pre></td></tr></table></figure>本地浏览器访问<br><img src="https://pic.imgdb.cn/item/66debb41d9c307b7e9ea3f41.png" alt=""><h2 id="部署前端应用"><a href="#部署前端应用" class="headerlink" title="部署前端应用"></a>部署前端应用</h2>emmm~,这个最后一步一直报错 404，花了一下无，给我气红温了，就先跳过了<h2 id="一键部署DockerCompose"><a href="#一键部署DockerCompose" class="headerlink" title="一键部署DockerCompose"></a>一键部署DockerCompose</h2>DockerCompose是通过一个单独的YAML格式的文件来定义一组相关联的应用容器，帮<br>助我们实现多个相互关联的Docker容器的快速部署。<br>右边即是YAML格式的容器等同于左边<br><img src="https://pic.imgdb.cn/item/66def3b0d9c307b7e94885ac.png" alt=""><br><img src="https://pic.imgdb.cn/item/66def40ad9c307b7e949b63a.png" alt=""><br>将准备好的YAML文件传入虚拟机中，再执行 docker compose up 即可一键部署</li></ol><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>Docker并不作为JAVA后端的一个重点，再加上最近有些浮躁，很难静下心来，所以学的有点粗糙，<br>也想早点开启下一章微服务的学习<br>Docker就作为了解吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每次学新东西，就想到当初选JAVA后端，我就想扇自己&lt;br&gt;一款运维工具也需要JAVA后端掌握，学不完根本学不完。还需要虚拟机环境，我是真不喜欢虚拟机，太难用了&lt;br&gt;虽然Docker可以帮助我们快速部署和搭建，但是部署Docker也是真麻烦&lt;br&gt;为什么不能docker一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MybatisPlus</title>
    <link href="http://example.com/2024/09/06/MybatisPlus/"/>
    <id>http://example.com/2024/09/06/MybatisPlus/</id>
    <published>2024-09-06T05:46:45.235Z</published>
    <updated>2024-09-07T10:28:42.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识MybatisPlus"><a href="#初识MybatisPlus" class="headerlink" title="初识MybatisPlus"></a>初识MybatisPlus</h1><p>MybatisPlus的特点</p><ol><li>可以对现有工程只做增强不做改变，引入MybatisPlus后Mybatis的代码依旧可以使用</li><li>方便快捷实现对单表的增删改查</li><li>功能丰富 例如 代码生成，自动分页，自动填充<h2 id="使用MybatisPlus"><a href="#使用MybatisPlus" class="headerlink" title="使用MybatisPlus"></a>使用MybatisPlus</h2></li><li>引入MybatisPlus<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>自定义的Mapper 继承MybatisPlus提供的BaseMapper<br> 注意：BaseMapper需要指定实体类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MybatisPlus的常用注解"><a href="#MybatisPlus的常用注解" class="headerlink" title="MybatisPlus的常用注解"></a>MybatisPlus的常用注解</h2></li><li>@TableName : 用于指定表名<br>当实体类名和数据库表名不一致的时候使用</li><li>@TableId :用于指定表中的主键字段信息<br>可以指定主键的憎长类型，共有三种，（AUTO）数据库自增长，(INPUT)get方式输入,（ASSIGN_ID）自带的雪花算法<br>若不指定则默认为yaml配置的方式</li><li>@TableFieId :用于指定表中的普通字段信息<br>直接上图<br><img src="https://www.helloimg.com/i/2024/09/04/66d81e5d52204.png" alt=""></li></ol><h2 id="MybatisPlus的配置"><a href="#MybatisPlus的配置" class="headerlink" title="MybatisPlus的配置"></a>MybatisPlus的配置</h2><p><img src="https://www.helloimg.com/i/2024/09/04/66d820a887981.png" alt=""></p><h1 id="MybatisPlus的条件构造器"><a href="#MybatisPlus的条件构造器" class="headerlink" title="MybatisPlus的条件构造器"></a>MybatisPlus的条件构造器</h1><p>MybatisPlus提供了三种条件构造器</p><ol><li>QueryWrapper<br>提供了很多关于查询的条件方法,方法很多就不一一展示了，通过一个示例简单说明一下<br><img src="https://www.helloimg.com/i/2024/09/04/66d826f608f60.png" alt=""><br>将图中sql可简化为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper queryWrapper = new QueryWrapper&lt;User&gt;()</span><br><span class="line">             .select(&quot;id&quot;,&quot;username&quot;,&quot;info&quot;,&quot;balance&quot;).like(&quot;username&quot;,&quot;o&quot;)</span><br><span class="line">             .gt(&quot;blance&quot;,1000);</span><br><span class="line"></span><br><span class="line">      List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure></li><li>UpdateWrapper<br>提供了更新的条件方法<br><img src="https://www.helloimg.com/i/2024/09/04/66d82981d5053.png" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;User&gt;()</span><br><span class="line">             .setSql(&quot;balance =balance - 200&quot;).in(&quot;id&quot;,&quot;1,2,4&quot;);</span><br><span class="line"></span><br><span class="line">     userMapper.update(null,updateWrapper);</span><br></pre></td></tr></table></figure><img src="https://www.helloimg.com/i/2024/09/04/66d8262a6963d.png" alt=""></li></ol><h1 id="IService接口"><a href="#IService接口" class="headerlink" title="IService接口"></a>IService接口</h1><p><img src="https://www.helloimg.com/i/2024/09/05/66d966d0eb1d4.png" alt=""><br>MybatisPuls提供了IService接口更帮助我们实现对单表的增删改查<br>使用IService接口需要两步</p><ol><li>自定义的XXXService接口去继承Iservice接口</li><li>XXXService的实现类XXXServiceImpl实现Service的同时也要继承IService的实现类<br>注意！！ XXXServiceImpl继承IService的实现类的时候需要给IService的实现类两个参数</li><li>第一个参数所对应的Mapper接口，因为在IService的实现类里面是需要引入对应的mapper<br> 即IService里面很多方法底层还是通过MybatisPuls提供的Mapper的方法实现</li><li>第二个参数为对应的实体对象<br>例如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService extends IService&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IService的应用"><a href="#IService的应用" class="headerlink" title="IService的应用"></a>IService的应用</h2>IService提供更多的方法供我们使用，同样这么多方法也就不一一介绍了<br>值得一提的是IService提供的批量插入方法saveBeach方法<br>假设我们需要像数据库中插入10000条数据</li><li>单条数据插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void test1() &#123;</span><br><span class="line">        long a =System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt;10000 ; i++) &#123;</span><br><span class="line">            Test1 test =new Test1();</span><br><span class="line">            test.setUser(i);</span><br><span class="line">            test.setName(&quot;test&quot;+i);</span><br><span class="line">            tsetService.save(test);</span><br><span class="line">        &#125;</span><br><span class="line">        long b =System.currentTimeMillis();</span><br><span class="line">        System.out.println(b-a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>最后耗时10180毫秒</li><li>批量插入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void test2() &#123;</span><br><span class="line">        long a =System.currentTimeMillis();</span><br><span class="line">        List&lt;Test1&gt; list =new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;10000 ; i++) &#123;</span><br><span class="line">            Test1 test =new Test1();</span><br><span class="line">            test.setUser(i);</span><br><span class="line">            test.setName(&quot;test&quot;+i);</span><br><span class="line">            list.add(test);</span><br><span class="line">            if (list.size()==100) &#123;</span><br><span class="line">                tsetService.saveBatch(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long b =System.currentTimeMillis();</span><br><span class="line">        System.out.println(b-a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>最后耗时264毫秒，显著提升了50倍速度！！！<br>当然啦这还不是最快的</li><li>MYSQL的rewriteBatchedStatements=true<br>在配置数据库的url后面添加rewriteBatchedStatements=true 即可<br>代码与上面代码相同不变<br>最后耗时202毫秒，由于我直插入了10000条数据所以性能不明显，数据越多明显越大</li></ol><p>最后再来说一下rewriteBatchedStatements=true的作用</p><ol><li>如果不加，我们操作会是将一千条数据封装到list中，由list传入数据库，然后每一条数据执行一次insert语句<br>所以提升速度的原因是减少了连接数据库的次数</li><li>加上rewriteBatchedStatements=true后，list传入后数据库只需要执行一次insert语句，因为者一千条数据会进行拼接</li></ol><h2 id="DB静态工具"><a href="#DB静态工具" class="headerlink" title="DB静态工具"></a>DB静态工具</h2><p>介绍之前先看几个需求,前置条件，用户和地址是两个表，用外键链接<br><img src="https://www.helloimg.com/i/2024/09/06/66db1b101f551.png" alt=""><br>根据已经学习到的知识，如果我们想解决第一个问题就需要</p><ol><li>在UserService中不仅仅调用自己的IService提供的方法，也需要调用AddressService<br>(当然啦也可以调用AddressMapper)</li><li>解决第三个问题呢就需要在AddressService中调用UserService,这样互相调用的话，业务复杂<br>很多个Service层或者Mapper互相调用很大可能会造成循环依赖<br>为了解决循环依赖问题，MybatisPlus提供了DB静态工具(注意：需要3.5.0版本以上)</li><li>DB提供了和IService几乎一摸一样的方法 不过在调用DB的时候需要将所对应的实体类传入<br>利用DB解决问题1<br><img src="https://www.helloimg.com/i/2024/09/06/66db2070aef10.png" alt=""></li></ol><h2 id="JOSN处理器"><a href="#JOSN处理器" class="headerlink" title="JOSN处理器"></a>JOSN处理器</h2><p>作用：如果数据库表中有字段类型为JOSN时，可以使用Mybatis提供的JOSN处理器，简化开发<br>普通方法我会用一个String类型的变量去接收 表中JOSN类型的字段，但是这样后续业务处理比较麻烦<br>使用JSON处理器可以解决这个问题，需要三步</p><ol><li>定义一个表中JOSN类型字段锁对应的实体类，用这个实体类类型的变量去接收</li><li>同时需要使用@TableFiled中添加JOSN处理器 即typeHandler=JacksonTypeHandler.class</li><li>在@TableName中加上 autoResultMap =true 返回映射<br><img src="https://www.helloimg.com/i/2024/09/07/66dbc04951e2e.png" alt=""></li></ol><h2 id="MybatisPlus的分页功能"><a href="#MybatisPlus的分页功能" class="headerlink" title="MybatisPlus的分页功能"></a>MybatisPlus的分页功能</h2><p>MybatisPlus提供了很多拓展功能其中较为常用的就是分页功能</p><ol><li><p>分页功能的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisConfig &#123;</span><br><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">    // 1.初始化核心插件</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    // 2.添加分更插件 和指定数据库类型</span><br><span class="line">    PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MysOL)</span><br><span class="line">    pageInterceptor.setMaxLimit(1000L);//设置分页上限</span><br><span class="line">    interceptor.addInnerInterceptor(pagenterceptor);</span><br><span class="line">    return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解：先new一个MybatisPlus的拦截器对象，在new一个分页对象并设置初始值添加到拦截器中</p></li><li><p>分页功能的基本使用</p><ol><li>这是简单封装了一个PageVO,用于处理分页查询后的数据，方便返回前端<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pubilc class PageVO&lt;T&gt;&#123;</span><br><span class="line">    public Ingter pages;</span><br><span class="line">    public Ingter total;</span><br><span class="line">    public List&lt;T&gt; list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>简单使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public PageVO&lt;UserVO&gt; queryUsersPage(UserQuery query)&#123;</span><br><span class="line">    String name = query.getName();</span><br><span class="line">    Integer status = query.getstatus();</span><br><span class="line">    //1.构建分页条件</span><br><span class="line">    // 1.1.分页条件 Page.of()需要两个参数 一个当前的页数，一个每页查询的数据量</span><br><span class="line">    Page&lt;User&gt;page = Page.of(query.getPageNo(),query.getPagesize());</span><br><span class="line">    // 1.2.排序条件</span><br><span class="line">    page.addorder(new orderItem(query.getSortBy(), query.getIsAsc()));</span><br><span class="line">    //1 2.分页查询</span><br><span class="line">    Page&lt;User&gt; p=lambdaQuery()</span><br><span class="line">    .like( condition: name != null, User::getUsername, name)</span><br><span class="line">    .eq( condition: status != null, User::getstatus, status)</span><br><span class="line">    .page(page);</span><br><span class="line">    // 处理数据</span><br><span class="line">    PageVO(UserVO)  pagevo =new PageVO()</span><br><span class="line">    pagevo.setPages(p.getPages);</span><br><span class="line">    pagevo.setTotal(p.getTotal);</span><br><span class="line">    List&lt;User&gt; list = p.getRecords();</span><br><span class="line">    List&lt;UserVO&gt; vo= BeanUtil.copyToList(list,UserVo.class)</span><br><span class="line">    pagevo.setlist(vo);</span><br><span class="line">    return pagevo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上就是一个分页查询用户的简单例子<br>在实际功能中 构建分页条件 排序条件 处理数据 这三个步骤在多次分页中代码基本相同<br>所以其实可以将这几部分代码抽取成三个工具类，使用到这几个步骤的时候直接调用对应的工具类</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识MybatisPlus&quot;&gt;&lt;a href=&quot;#初识MybatisPlus&quot; class=&quot;headerlink&quot; title=&quot;初识MybatisPlus&quot;&gt;&lt;/a&gt;初识MybatisPlus&lt;/h1&gt;&lt;p&gt;MybatisPlus的特点&lt;/p&gt;
&lt;ol&gt;
&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis学习</title>
    <link href="http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2024/09/03/redis%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-03T02:34:21.000Z</published>
    <updated>2024-09-06T07:15:18.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis雪崩"><a href="#redis雪崩" class="headerlink" title="redis雪崩"></a>redis雪崩</h1><p>  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>  对key的过期时间进行调整，防止大量key同时失效，最简单的方法对key的过期时间统一成 固定时间+random</p><h1 id="redis击穿"><a href="#redis击穿" class="headerlink" title="redis击穿"></a>redis击穿</h1><p>   缓存击穿是指一个非常 “热” 的 key（通常是被频繁访问的数据）在某个时间点过期，此时若有大量并发请求过来，这些请求发现缓存中没有数据，就会同时去数据库查询该数据，对数据库造成巨大的压力。</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="加互斥锁"><a href="#加互斥锁" class="headerlink" title="加互斥锁"></a>加互斥锁</h3><pre><code>在高并发下，只有获取锁成功的线程才会去查询数据库，并更新缓存，其他线程则等待一段时间。</code></pre><h4 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h4><p>   利用redis中的nx命令自定义实现锁<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Boolean trylock(String key)&#123;</span><br><span class="line">    Boolean falg = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, 10, TimeUnit.MINUTES);</span><br><span class="line">    return BooleanUtil.isTrue(falg);</span><br><span class="line">&#125;</span><br><span class="line">public void unlock(String key)&#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h4><pre><code>当一个线程执行到这里时，会先从缓存中查询，则会先进入StrUtil.isNotBlank(s)判断，StrUtil.isNotBlank()的作用为判断是否字符串是否不为空且不为仅包含空白字符的方法；如果为true,则说明缓存中存在且不为空，直接返回。如果为false，则说明缓存中不存在或者值为空，即进入下一个判断，如果是s！=null为true，说明缓存中存在s,但是s的值为空所以返回null,当s！=null为false后尝试获取锁，获取锁失败则等待重试，获取锁成功则查询数据库，如果数据库中存在则写入缓存中，如果不存在则向缓存中写入空值，这样可以保证在高并发的情况下只有获取锁成功的线程会访问数据库</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public Shop queryWithMutex(Long id) &#123;</span><br><span class="line">    String key = RedisConstants.CACHE_SHOP_KEY + id;</span><br><span class="line">    //从redis中查询</span><br><span class="line">    String s = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    if (StrUtil.isNotBlank(s)) &#123;</span><br><span class="line">        return JSONUtil.toBean(s, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否为空值</span><br><span class="line">    if (s != null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //不存在尝试获取锁</span><br><span class="line">    String lockkey = &quot;lock:shop:&quot; + id;</span><br><span class="line">    Boolean islock = trylock(lockkey);</span><br><span class="line">    Shop shop=null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取锁不成功则等待反复尝试</span><br><span class="line">        if (!islock) &#123;</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            return queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不存在查询数据库</span><br><span class="line">        shop = getById(id);</span><br><span class="line">        //模拟实际</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        if (shop != null) &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库</span><br><span class="line">        else &#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        unlock(lockkey);</span><br><span class="line">    &#125;</span><br><span class="line">    return shop;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><pre><code>设置逻辑过期时间，这样可以保证key永远存在，只需要判断是否逻辑过期进行更形即可</code></pre><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>  查询一个一定不存在的数据，由于缓存中没有该数据，所有的请求都会落到数据库上，导致数据库压力瞬间增大。如果有人利用这个漏洞不断发起这种查询，就可能使数据库因承受不住大量请求而崩溃。</p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-添加NULL值"><a href="#1-添加NULL值" class="headerlink" title="1 添加NULL值"></a>1 添加NULL值</h3><p><img src="https://www.helloimg.com/i/2024/09/03/66d6b0ae1fcda.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Shop redisPassThrought(Long id) &#123;</span><br><span class="line">        String key =RedisConstants.CACHE_SHOP_KEY+id;</span><br><span class="line">        //从redis中查询</span><br><span class="line">        String s= stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        if (StrUtil.isNotBlank(s)) &#123;</span><br><span class="line">            return JSONUtil.toBean(s,Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否为空值</span><br><span class="line">        if (s!=null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不存在查询数据库</span><br><span class="line">        Shop shop =getById(id);</span><br><span class="line">        if (shop != null)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),RedisConstants.CACHE_SHOP_TTL);</span><br><span class="line">        &#125;</span><br><span class="line">        //如果数据库中没有该shop对象,则根据id设置为一个空值存入redis中，当下次查询该id时会在上一个if截至，不会重新查数据库</span><br><span class="line">        else &#123; stringRedisTemplate.opsForValue().set(key,&quot;&quot;,RedisConstants.CACHE_NULL_TTL);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="Redis分布式锁-："><a href="#Redis分布式锁-：" class="headerlink" title="Redis分布式锁 ："></a>Redis分布式锁 ：</h1><h2 id="1-自定义分布式锁："><a href="#1-自定义分布式锁：" class="headerlink" title="1 自定义分布式锁："></a>1 自定义分布式锁：</h2><pre><code>  调用该方法的时候需要new一个RedisLock的对象，并传入两个需要的参数key</code></pre><h3 id="原理-："><a href="#原理-：" class="headerlink" title="原理 ："></a>原理 ：</h3><pre><code> 利用Redis中的NX命令判断是否存在，不存在则创建，存在创建会失败  注意 ： 返回值是Boolean类型时,不建议直接返回对象success，自动拆箱可能会空指针</code></pre><p>自定义分布式锁：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleRedisLock implements ILock &#123;</span><br><span class="line">    //锁的前缀</span><br><span class="line">    private static final String KEY_PREFIX = &quot;lock:&quot;;</span><br><span class="line">    //具体业务名称，将前缀和业务名拼接之后当做Key</span><br><span class="line">    private String name;</span><br><span class="line">    //这里不是@Autowired注入，采用的是构造器注入，在创建SimpleRedisLock时，将RedisTemplate作为参数传入</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryLock(long timeoutSec) &#123;</span><br><span class="line">        //获取线程标识</span><br><span class="line">        long threadId = Thread.currentThread().getId();</span><br><span class="line">        //获取锁，使用SETNX方法进行加锁，同时设置过期时间，防止死锁</span><br><span class="line">        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + &quot;&quot;, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        //自动拆箱可能会出现null，这样写更稳妥</span><br><span class="line">        return Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        //通过DEL来删除锁</span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>业务逻辑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SeckillVoucher&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">    //1. 查询优惠券</span><br><span class="line">    queryWrapper.eq(SeckillVoucher::getVoucherId, voucherId);</span><br><span class="line">    SeckillVoucher seckillVoucher = seckillVoucherService.getOne(queryWrapper);</span><br><span class="line">    //2. 判断秒杀时间是否开始</span><br><span class="line">    if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀还未开始，请耐心等待&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3. 判断秒杀时间是否结束</span><br><span class="line">    if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) &#123;</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4. 判断库存是否充足</span><br><span class="line">    if (seckillVoucher.getStock() &lt; 1) &#123;</span><br><span class="line">        return Result.fail(&quot;优惠券已被抢光了哦，下次记得手速快点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    // 创建锁对象</span><br><span class="line">    SimpleRedisLock redisLock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span><br><span class="line">    // 获取锁对象</span><br><span class="line">    boolean isLock = redisLock.tryLock(120);</span><br><span class="line">    // 加锁失败，说明当前用户开了多个线程抢优惠券，但是由于key是SETNX的，所以不能创建key，得等key的TTL到期或释放锁（删除key）</span><br><span class="line">    if (!isLock) &#123;</span><br><span class="line">        return Result.fail(&quot;不允许抢多张优惠券&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取代理对象</span><br><span class="line">        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        return proxy.createVoucherOrder(voucherId);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 释放锁</span><br><span class="line">        redisLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h4><ol><li><p>逻辑说明<br>持有锁的线程1在锁的内部出现了阻塞，导致他的锁TTL到期，自动释放<br>此时线程2也来尝试获取锁，由于线程1已经释放了锁，所以线程2可以拿到<br>但是现在线程1阻塞完了，继续往下执行，要开始释放锁了<br>那么此时就会将属于线程2的锁释放，这就是误删别人锁的情况</p></li><li><p>解决方案<br>解决方案就是在每个线程释放锁的时候，都判断一下这个锁是不是自己的，如果不属于自己，则不进行删除操作。<br>假设还是上面的情况，线程1阻塞，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1阻塞完了，继续往下执行，开始删除锁，但是线程1发现这把锁不是自己的，所以不进行删除锁的逻辑，当线程2执行到删除锁的逻辑时，如果TTL还未到期，则判断当前这把锁是自己的，于是删除这把锁<br><img src="https://www.helloimg.com/i/2024/09/04/66d87a2c99d06.png" alt=""></p><h4 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">      public class RedisLock &#123;</span><br><span class="line">    private static  final  String KEY_PREFIX = UUID.randomUUID().toString(true)+&quot;-&quot;;</span><br><span class="line">    private String key;</span><br><span class="line">    private StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    public RedisLock(String key, StringRedisTemplate redisTemplate) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean tryLock(Long timeout) &#123;</span><br><span class="line">        //获取锁的时候将该线程标识（UUID+线程Id）存入缓存中，释放锁是判断，防止误删</span><br><span class="line">       String threadId = KEY_PREFIX +Thread.currentThread().getId();</span><br><span class="line">       Boolean success= redisTemplate.opsForValue().setIfAbsent(key, threadId , timeout, TimeUnit.SECONDS);</span><br><span class="line">       return Boolean.TRUE.equals(success);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        String threadId = KEY_PREFIX +Thread.currentThread().getId();</span><br><span class="line">         String id = redisTemplate.opsForValue().get(key);</span><br><span class="line">         if(threadId.equals(id)) &#123;</span><br><span class="line">             redisTemplate.delete(key);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redisson-可重入锁"><a href="#Redisson-可重入锁" class="headerlink" title="Redisson 可重入锁"></a>Redisson 可重入锁</h2><p>基于SETNX实现的分布式锁存在以下问题</p><ol><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li><li>重入问题是指获取锁的线程，可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以可重入锁的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的</li><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患</li><li>主从一致性<br>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题<h2 id="那么什么是Redisson呢"><a href="#那么什么是Redisson呢" class="headerlink" title="那么什么是Redisson呢"></a>那么什么是Redisson呢</h2>Redisson是一个在Redis的基础上实现的Java驻内存数据网格(In-Memory Data Grid)。它不仅提供了一系列的分布式Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现<br>Redis提供了分布式锁的多种多样功能</li></ol></li><li>可重入锁(Reentrant Lock)</li><li>公平锁(Fair Lock)</li><li>联锁(MultiLock)</li><li>红锁(RedLock)</li><li>读写锁(ReadWriteLock)</li><li>信号量(Semaphore)</li><li>可过期性信号量(PermitExpirableSemaphore)</li><li>闭锁(CountDownLatch)</li></ol><h3 id="需要提前导入依赖坐标"><a href="#需要提前导入依赖坐标" class="headerlink" title="需要提前导入依赖坐标"></a>需要提前导入依赖坐标</h3><h3 id="对其进行配置"><a href="#对其进行配置" class="headerlink" title="对其进行配置"></a>对其进行配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//配置Redisson，用于分布式锁</span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient RedissonClient() &#123;</span><br><span class="line">        //配置</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class="line">        //创建RedissonClient对象</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">void testRedisson() throws InterruptedException &#123;</span><br><span class="line">    //获取可重入锁</span><br><span class="line">    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);</span><br><span class="line">    //尝试获取锁，三个参数分别是：获取锁的最大等待时间(期间会重试)，锁的自动释放时间，时间单位</span><br><span class="line">    boolean success = lock.tryLock(1,10, TimeUnit.SECONDS);</span><br><span class="line">    //判断获取锁成功</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;执行业务&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理的话要读源码，读不懂一点好吧，太难读了。等我回头学会了再来补充。<br>目前只知道一点Redisson可重入的原理大概是 采用了hash结构存储锁，外层key代表锁存在，<br>内层key代表是线程的标识 即一个方法会先获取外层key，如果锁存在，则该方法继续获取<br>内层key,如果内层key和自己的线程标识相同，则获取锁成功，此时value +1,方法执行完后<br>也不是直接释放锁，而是value -1，直到value =0时才释放锁</p><h1 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a>认识消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>  字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<br>  消息队列：存储和管理消息，也被称为消息代理（Message Broker）<br>  生产者：发送消息到消息队列<br>  消费者：从消息队列获取消息并处理消息</p><h2 id="使用队列的好处在于解耦："><a href="#使用队列的好处在于解耦：" class="headerlink" title="使用队列的好处在于解耦："></a>使用队列的好处在于解耦：</h2><p>  举个例子，快递员(生产者)把快递放到驿站/快递柜里去(Message Queue)去，我们(消费者)从快递柜/驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的<br>  那么在这种场景下我们的秒杀就变成了：在我们下单之后，利用Redis去进行校验下单的结果，然后在通过队列把消息发送出去，然后在启动一个线程去拿到这个消息，完成解耦，同时也加快我们的响应速度<br>  这里我们可以直接使用一些现成的(MQ)消息队列，如kafka，rabbitmq等，但是如果没有安装MQ，我们也可以使用Redis提供的MQ方案(学完Redis我就去学微服务)</p><h2 id="redis基于List的消息队列"><a href="#redis基于List的消息队列" class="headerlink" title="redis基于List的消息队列"></a>redis基于List的消息队列</h2><p> 消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果<br>  队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。<br> 不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用BRPOP或 者BLPOP来实现阻塞效果</p><h3 id="基于List的消息队列有哪些优缺点？"><a href="#基于List的消息队列有哪些优缺点？" class="headerlink" title="基于List的消息队列有哪些优缺点？"></a>基于List的消息队列有哪些优缺点？</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)<h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息<br>SUBSCRIBE channel [channel]：订阅一个或多个频道<br>PUBLISH channel msg：向一个频道发送消息<br>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</li></ol><h3 id="基于PubSub的消息队列有哪些优缺点"><a href="#基于PubSub的消息队列有哪些优缺点" class="headerlink" title="基于PubSub的消息队列有哪些优缺点"></a>基于PubSub的消息队列有哪些优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>采用发布订阅模型，支持多生产，多消费</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不支持数据持久化<br>2 .无法避免消息丢失（如果向频道发送了消息，却没有人订阅该频道，那发送的这条消息就丢失了）<br>3 .消息堆积有上限，超出时数据丢失（消费者拿到数据的时候处理的太慢，而发送消息发的太快）<h2 id="Stream的单消费模式"><a href="#Stream的单消费模式" class="headerlink" title="Stream的单消费模式"></a>Stream的单消费模式</h2><img src="https://www.helloimg.com/i/2024/09/03/66d6ef96a5d79.jpg" alt=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID</span><br><span class="line">XADD users * name jack age 21</span><br></pre></td></tr></table></figure></li></ol><p>读取队列方法之一 ：XREAD<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure></p><ol><li>[COUNT count]<br>每次读取消息的最大数量</li><li>[BLOCK milliseconds]<br>当没有消息时，是否阻塞，阻塞时长</li><li>STREAMS key [key …]<br>要从哪个队列读取消息，key就是队列名</li><li>ID [ID …]<br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始</li></ol><p>注意：<br> 当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题</p><h3 id="STREAM类型消息队列的XREAD命令特点"><a href="#STREAM类型消息队列的XREAD命令特点" class="headerlink" title="STREAM类型消息队列的XREAD命令特点"></a>STREAM类型消息队列的XREAD命令特点</h3><ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol><h2 id="Sream的组消费模式"><a href="#Sream的组消费模式" class="headerlink" title="Sream的组消费模式"></a>Sream的组消费模式</h2><pre><code>将多个消费者划分为一组，监听一个队列</code></pre><h3 id="1-消息分流"><a href="#1-消息分流" class="headerlink" title="1.消息分流"></a>1.消息分流</h3><p>队列中消息分给组内不同的消费者，而不是重复消费者（也可以消费者重复去执行）提高效率</p><h3 id="2-消息标识"><a href="#2-消息标识" class="headerlink" title="2. 消息标识"></a>2. 消息标识</h3><p>消费者在读取一个消息后，会给该消息添加一个标识，从而可以记录到最后被处理的消息，即使消费者宕机。重启后可以<br>继续从标识的地方继续读取，直到消费者执行完毕该消息，进行确认后，该消息才会被消息队列移除，确保了每个消息最少执行一遍</p><h3 id="3。消息确认"><a href="#3。消息确认" class="headerlink" title="3。消息确认"></a>3。消息确认</h3><p>消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后，需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除</p><h2 id="基于Stream实现异步秒杀"><a href="#基于Stream实现异步秒杀" class="headerlink" title="基于Stream实现异步秒杀"></a>基于Stream实现异步秒杀</h2><pre><code>异步秒杀所以需要子线程中消费队列思路：在子线程中一直循环，循环中该线程指定g1组的消费者c1读取Stream中的消息，然后判断读取的消息是否为空，为空则进行下一次循环，不为空则解析消息中的数据，得到需要的对象，然后创建订单，订单完成后进行消息确认消息队列会移除该消息，如果执行过程中出现异常，就会先捕捉异常，然后执行pending-list中的消息，因为出现异常消息被读取加上标识，但是并未确定，所以会在pending-list中。读取消息，判断是否为空，不为空则创建订单，确认消息，如果为空说明pending-list中没有消息，直接break。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">String queuename =&quot;stream.order&quot;;</span><br><span class="line">private class  VoucherOrderHander implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          while(true)&#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  //1.2 stream</span><br><span class="line">                  //获取消息队列中的信息</span><br><span class="line">                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(&quot;g1&quot;, &quot;c1&quot;),</span><br><span class="line">                          //.count(1) 表示只读取一个元素， .block(Duration.ofSeconds(2))表示如果没有消息则等待两秒,</span><br><span class="line">                          StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),</span><br><span class="line">                          // ReadOffset.lastConsumed()表示从最新元素开始读取</span><br><span class="line">                          StreamOffset.create(queuename, ReadOffset.lastConsumed()));</span><br><span class="line">                  //判断是否获取成功</span><br><span class="line">                  if (list ==null || list.isEmpty())&#123;</span><br><span class="line">                      continue;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //解析信息</span><br><span class="line">                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(0);</span><br><span class="line">                  Map&lt;Object,Object&gt; value = mapRecord.getValue();</span><br><span class="line">                 VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, new VoucherOrder(),true);</span><br><span class="line">                  //创建订单</span><br><span class="line">                  porxy.CreateVoucher1(voucherOrder);</span><br><span class="line">                  //xack确认</span><br><span class="line">                  stringRedisTemplate.opsForStream().acknowledge(queuename,&quot;g1&quot;,mapRecord.getId());</span><br><span class="line">              &#125; catch (Exception e) &#123;</span><br><span class="line">                  log.info(&quot;异步订单&quot;,e);</span><br><span class="line">                  //获取消息队列中的信息</span><br><span class="line">                  //0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span><br><span class="line">                  List&lt;MapRecord&lt;String,Object,Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(Consumer.from(&quot;g1&quot;, &quot;c1&quot;),</span><br><span class="line">                          StreamReadOptions.empty().count(1),</span><br><span class="line">                          StreamOffset.create(queuename,ReadOffset.from(&quot;0&quot;)));</span><br><span class="line">                  //判断是否获取成功</span><br><span class="line">                  if (list ==null || list.isEmpty())&#123;</span><br><span class="line">                     break;</span><br><span class="line">                  &#125;</span><br><span class="line">                  //解析信息</span><br><span class="line">                  MapRecord&lt;String,Object,Object&gt; mapRecord = list.get(0);</span><br><span class="line">                  Map&lt;Object,Object&gt; value = mapRecord.getValue();</span><br><span class="line">                  VoucherOrder voucherOrder= BeanUtil.fillBeanWithMap(value, new VoucherOrder(),true);</span><br><span class="line">                  //创建订单</span><br><span class="line">                  porxy.CreateVoucher1(voucherOrder);</span><br><span class="line">                  //xack确认</span><br><span class="line">                  stringRedisTemplate.opsForStream().acknowledge(queuename,&quot;g1&quot;,mapRecord.getId());</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p> 主线程中的异步秒杀的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*  Long userId = UserHolder.getUser().getId();</span><br><span class="line">        long orderId= redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        //执行lua脚本</span><br><span class="line">        Long result = stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT, Collections.emptyList(),</span><br><span class="line">                voucherId.toString(), userId.toString(),String.valueOf(orderId)</span><br><span class="line">        );</span><br><span class="line">        //判断是否为0</span><br><span class="line">        int r = result.intValue();</span><br><span class="line">        if (r!=0)&#123;</span><br><span class="line">            return Result.fail(r==1? &quot;库存不足&quot; : &quot;不能重复下单&quot;) ;</span><br><span class="line">        &#125;</span><br><span class="line">        porxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        return Result.ok(orderId); </span><br></pre></td></tr></table></figure><br>Lua脚本的代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 订单id</span><br><span class="line">local voucherId = ARGV[1]</span><br><span class="line">-- 用户id</span><br><span class="line">local userId = ARGV[2]</span><br><span class="line">-- 新增orderId，但是变量名用id就好，因为VoucherOrder实体类中的orderId就是用id表示的</span><br><span class="line">local id = ARGV[3]</span><br><span class="line">-- 优惠券key</span><br><span class="line">local stockKey = &#x27;seckill:stock:&#x27; .. voucherId</span><br><span class="line">-- 订单key</span><br><span class="line">local orderKey = &#x27;seckill:order:&#x27; .. voucherId</span><br><span class="line">-- 判断库存是否充足</span><br><span class="line">if (tonumber(redis.call(&#x27;get&#x27;, stockKey)) &lt;= 0) then</span><br><span class="line">    return 1</span><br><span class="line">end</span><br><span class="line">-- 判断用户是否下单</span><br><span class="line">if (redis.call(&#x27;sismember&#x27;, orderKey, userId) == 1) then</span><br><span class="line">    return 2</span><br><span class="line">end</span><br><span class="line">-- 扣减库存</span><br><span class="line">redis.call(&#x27;incrby&#x27;, stockKey, -1)</span><br><span class="line">-- 将userId存入当前优惠券的set集合</span><br><span class="line">redis.call(&#x27;sadd&#x27;, orderKey, userId)</span><br><span class="line">-- 将下单数据保存到消息队列中</span><br><span class="line">redis.call(&quot;sadd&quot;, &#x27;stream.orders&#x27;, &#x27;*&#x27;, &#x27;userId&#x27;, userId, &#x27;voucherId&#x27;, voucherId, &#x27;id&#x27;, id)</span><br><span class="line">return 0</span><br></pre></td></tr></table></figure><br>redis的学习就先到这里吧，时间紧任务重就要先去学微服务啦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis雪崩&quot;&gt;&lt;a href=&quot;#redis雪崩&quot; class=&quot;headerlink&quot; title=&quot;redis雪崩&quot;&gt;&lt;/a&gt;redis雪崩&lt;/h1&gt;&lt;p&gt;  雪崩是指在redis缓存中，大量key同时失效，此时会对后台数据库造成巨大压力&lt;/p&gt;
&lt;h2 </summary>
      
    
    
    
    
  </entry>
  
</feed>
